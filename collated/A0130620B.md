# A0130620B
###### /todolist/logic/CaseExecuter.java
``` java
package todolist.logic;

public class CaseExecuter {
	private Logic logic;

	protected CaseExecuter(Logic logic) {
		this.logic = logic;
	}

	protected void add(String[] arg) {
		String type = arg[0];
		switch (type) {
		case "task":
			addTask(arg);
			break;
		case "event":
			addEvent(arg);
			break;
		case "deadline":
			addDeadline(arg);
			break;
		case "recurring":
			addRecurring(arg);
			break;
		default:
		}
	}

	protected void addTask(String[] arg) {
		logic.addTask(arg[1]);
	}

	protected void addEvent(String[] arg) {
		if (arg.length == 6) {
			logic.addEvent(arg[1], arg[2], arg[3], arg[4], arg[5]);
		} else {
			logic.addEventLess(arg[1], arg[2], arg[3], arg[4]);
		}
	}

	protected void addDeadline(String[] arg) {
		if (arg.length == 4) {
			logic.addDeadline(arg[1], arg[2], arg[3]);
		} else {
			logic.addDeadlineLess(arg[1], arg[2]);
		}
	}

	protected void addRecurring(String[] arg) {
		switch (arg[1]) {
		case "event":
			addRecurringEvent(arg);
			break;
		case "deadline":
			addRecurringDeadline(arg);
			break;
		default:
		}
	}

	protected void addRecurringEvent(String[] arg) {
		if (arg.length == 8) {
			logic.addRecurringEvent(arg[2], arg[3], arg[4], arg[5], arg[6], arg[7]);
		} else {
			logic.addRecurringEventLess(arg[2], arg[3], arg[4], arg[5], arg[6]);
		}
	}

	protected void addRecurringDeadline(String[] arg) {
		if (arg.length == 6) {
			logic.addRecurringDeadline(arg[2], arg[3], arg[4], arg[5]);
		} else {
			logic.addRecurringDeadlineLess(arg[2], arg[3], arg[4]);
		}
	}

	protected void edit(String[] arg) {
		actionOnIndex("EDIT", arg);
	}

	protected void delete(String[] arg) {
		actionOnIndex("DELETE", arg);
	}

	protected void search(String[] arg) {
		logic.search(arg[0]);
	}

	protected void filter(String[] arg) {
		logic.filter(arg[0]);
	}

	protected void sort(String[] arg) {
		logic.sort(arg[0], arg[1]);
	}

	protected void label(String[] arg) {
		actionOnIndex("LABEL", arg);
	}

	protected void setRecurring(String[] arg) {
		actionOnIndex("SET-RECURRING", arg);
	}

	protected void removeRecurring(String[] arg) {
		actionOnIndex("REMOVE-RECURRING", arg);
	}

	protected void postpone(String[] arg) {
		actionOnIndex("POSTPONE", arg);
	}

	protected void forward(String[] arg) {
		actionOnIndex("FORWARD", arg);
	}

	protected void addRemind(String[] arg) {
		logic.addRemind(arg);
	}

	protected void remind(String[] arg) {
		actionOnIndex("REMIND", arg);
	}

	protected void addRemindBef(String[] arg) {
		String[] restOfArgs = new String[arg.length - 2];
		for (int i = 0; i < arg.length; i++) {
			restOfArgs[i] = arg[i + 2];
		}
		logic.addRemindBef(arg[0], arg[1], restOfArgs);
	}

	protected void remindBef(String[] arg) {
		actionOnIndex("REMIND-BEF", arg);
	}

	protected void removeRemind(String[] arg) {
		actionOnIndex("REMOVE-REMIND", arg);
	}

	protected void done(String[] arg) {
		actionOnIndex("DONE", arg);
	}

	protected void undone(String[] arg) {
		actionOnIndex("UNDONE", arg);
	}

	protected void exit(String[] arg) {
		logic.exit();
	}

	protected void undo(String[] arg) {
		logic.undo(Integer.parseInt(arg[0]));
	}

	protected void redo(String[] arg) {
		logic.redo(Integer.parseInt(arg[0]));
	}

	protected void reset(String[] arg) {
		logic.reset();
	}

	protected void save(String[] arg) {
		logic.setNewFile(arg[0]);
	}

	protected void open(String[] arg) {
		logic.openNewFile(arg[0]);
	}

	protected void tab(String[] arg) {
		logic.tab(arg[0]);
	}

	protected void help(String[] arg) {
		logic.tab("help");
	}

	protected void invalid(String[] arg) {
		logic.invalid(arg[0]);
	}

	protected void clean(String[] arg) {
		logic.clean();
	}

	private void actionOnIndex(String type, String[] arg) {
		String temp[] = arg[0].split(",");
		int index = -1;
		String name[] = new String[temp.length];
		Boolean flag = true;
		for (int i = 0; i < temp.length; i++) {
			if (isInteger(temp[i])) {
				index = Integer.parseInt(temp[i]);
				name[i] = logic.getMainApp().getTaskAt(index).getName().getName();
			} else {
				flag = false;
			}
		}

		if (flag) {
			for (int i = 0; i < name.length; i++) {
				typeCaseSwitcher(type, name[i], arg);
			}
		} else {
			typeCaseSwitcher(type, arg[0], arg);
		}
	}

	private void typeCaseSwitcher(String type, String taskname, String[] arg) {
		switch (type) {
		case "EDIT":
			logic.edit(taskname, arg[1], arg[2]);
			break;
		case "DELETE":
			logic.delete(taskname);
			break;
		case "LABEL":
			logic.label(taskname, arg[1]);
			break;
		case "SET-RECURRING":
			logic.setRecurring(taskname, true, arg[1]);
			break;
		case "REMOVE-RECURRING":
			logic.setRecurring(taskname, false, null);
			break;
		case "POSTPONE":
			logic.postpone(taskname, arg[1], arg[2]);
			break;
		case "FORWARD":
			logic.forward(arg[0], arg[1], arg[2]);
			break;
		case "REMIND":
			logic.remind(taskname);
			break;
		case "REMIND-BEF":
			logic.remindBef(taskname, arg[1], arg[2]);
			break;
		case "REMOVE-REMIND":
			logic.removeRemind(taskname);
			break;
		case "DONE":
			logic.done(taskname);
			break;
		case "UNDONE":
			logic.undone(taskname);
			break;
		default:

		}
	}

	private boolean isInteger(String s) {
		try {
			@SuppressWarnings("unused")
			int i = Integer.parseInt(s);
			return true;
		} catch (NumberFormatException er) {
			return false;
		}
	}
}
```
###### /todolist/logic/CaseSwitcher.java
``` java
package todolist.logic;

import todolist.model.InputException;
import todolist.model.TokenizedCommand;
import todolist.storage.DataBase;

public class CaseSwitcher {

	private Logic logic;
	private DataBase dataBase;
	private InputErrorChecker inputErrorChecker;
	private CaseExecuter caseExecuter;

	protected CaseSwitcher(Logic logic, DataBase dataBase) {
		this.logic = logic;
		this.dataBase = dataBase;
		this.inputErrorChecker = new InputErrorChecker(this.logic, this.dataBase);
		this.caseExecuter = new CaseExecuter(logic);
	}

	protected void execute(TokenizedCommand command) {
		InputException inputException = inputErrorChecker.validate(command);
		if (inputException.getCorrectness()) {
			forceExecute(command);
		} else {
			logic.getUIHandler().sendMessage(inputException.getErrorMessage(), true);
		}
	}

	protected void forceExecute(TokenizedCommand command) {

		String action = command.getAction();
		String arg[] = command.getArgs();

		switch (action) {

		case "add":
			caseExecuter.add(arg);
			break;
		case "edit":
			caseExecuter.edit(arg);
			break;
		case "delete":
			caseExecuter.delete(arg);
			break;
		case "search":
			caseExecuter.search(arg);
			break;
		case "filter":
			caseExecuter.filter(arg);
			break;
		case "sort":
			caseExecuter.sort(arg);
			break;
		case "label":
			caseExecuter.label(arg);
			break;
		case "set-recurring":
			caseExecuter.setRecurring(arg);
			break;
		case "remove-recurring":
			caseExecuter.removeRecurring(arg);
			break;
		case "postpone":
			caseExecuter.postpone(arg);
			break;
		case "forward":
			caseExecuter.forward(arg);
			break;
		case "add-remind":
			caseExecuter.addRemind(arg);
			break;
		case "remind":
			caseExecuter.remind(arg);
			break;
		case "remove-remind":
			caseExecuter.removeRemind(arg);
			break;
		case "remind-bef":
			caseExecuter.addRemindBef(arg);
			break;
		case "add-remind-bef":
			caseExecuter.addRemindBef(arg);
			break;
		case "done":
			caseExecuter.done(arg);
			break;
		case "undone":
			caseExecuter.undone(arg);
			break;
		case "exit":
			caseExecuter.exit(arg);
			break;
		case "undo":
			caseExecuter.undo(arg);
			break;
		case "redo":
			caseExecuter.redo(arg);
			break;
		case "reset":
			caseExecuter.reset(arg);
			break;
		case "save":
			caseExecuter.save(arg);
			break;
		case "open":
			caseExecuter.open(arg);
			break;
		case "tab":
			caseExecuter.tab(arg);
			break;
		case "invalid":
			caseExecuter.invalid(arg);
			break;
		case "clean":
			caseExecuter.clean(arg);
			break;
		case "help":
			caseExecuter.help(arg);
		default:

		}

		if (!action.equals("undo") && !action.equals("redo")) {
			logic.stepForward();
		}
	}
}
```
###### /todolist/logic/CommandChecker.java
``` java
package todolist.logic;

import todolist.model.InputException;
import todolist.storage.DataBase;

public class CommandChecker {
	private Logic logic;
	private DataBase dataBase;
	private FunctionChecker functionChecker;

	protected CommandChecker(Logic logic, DataBase dataBase) {
		this.logic = logic;
		this.dataBase = dataBase;
		this.functionChecker = new FunctionChecker(this.logic, this.dataBase);
	}

	protected InputException add(String[] arg) {
		String type = "null";
		if (arg.length == 0) {
			return new InputException("ADD", "INCOMPLETE");
		} else {
			type = arg[0];
		}

		switch (type) {
		case "task":
			return addTask(arg);
		case "event":
			return addEvent(arg);
		case "deadline":
			return addDeadline(arg);
		case "recurring":
			return addRecurring(arg);
		default:
			return new InputException("ADD", "INCOMPLETE");
		}
	}

	protected InputException addTask(String[] arg) {
		if (arg.length != 2) {
			return new InputException("ADD TASK", "INCOMPLETE");
		} else {
			return functionChecker.addTaskChecker(arg[1]);
		}
	}

	protected InputException addEvent(String[] arg) {
		if (arg.length != 6 && arg.length != 5) {
			return new InputException("ADD EVENT", "INCOMPLETE");
		} else {
			if (arg.length == 6) {
				return functionChecker.addEventChecker(arg[1], arg[2], arg[3], arg[4], arg[5]);
			} else {
				return functionChecker.addEventLessChecker(arg[1], arg[2], arg[3], arg[4]);
			}
		}
	}

	protected InputException addDeadline(String[] arg) {
		if (arg.length != 4 && arg.length != 3) {
			return new InputException("ADD DEADLINE", "INCOMPLETE");
		} else {
			if (arg.length == 4) {
				return functionChecker.addDeadlineChecker(arg[1], arg[2], arg[3]);
			} else {
				return functionChecker.addDeadlineLessChecker(arg[1], arg[2]);
			}
		}
	}

	protected InputException addRecurring(String[] arg) {
		switch (arg[1]) {
		case "event":
			return addRecurringEvent(arg);
		case "deadline":
			return addRecurringDeadline(arg);
		default:
			return new InputException("ADD RECURRING", "INCOMPLETE");
		}
	}

	protected InputException addRecurringEvent(String[] arg) {
		if (arg.length != 8 && arg.length != 7) {
			return new InputException("ADD RECURRING EVENT", "INCOMPLETE");
		} else {
			if (arg.length == 8) {
				return functionChecker.addRecurringEventChecker(arg[2], arg[3], arg[4], arg[5], arg[6], arg[7]);
			} else {
				return functionChecker.addRecurringEventLessChecker(arg[2], arg[3], arg[4], arg[5], arg[6]);
			}
		}
	}

	protected InputException addRecurringDeadline(String[] arg) {
		if (arg.length != 6 && arg.length != 5) {
			return new InputException("ADD RECURRING DEADLINE", "INCOMPLETE");
		} else {
			if (arg.length == 6) {
				return functionChecker.addRecurringDeadlineChecker(arg[2], arg[3], arg[4], arg[5]);
			} else {
				return functionChecker.addRecurringDeadlineLessChecker(arg[2], arg[3], arg[4]);
			}
		}
	}

	protected InputException edit(String[] arg) {
		if (arg.length != 3) {
			return new InputException("EDIT", "INCOMPLETE");

		} else {
			return functionChecker.indexChecker("EDIT", arg);
		}
	}

	protected InputException delete(String[] arg) {
		if (arg.length != 1) {
			return new InputException("DELETE", "INCOMPLETE");
		} else {
			return functionChecker.indexChecker("DELETE", arg);
		}
	}

	protected InputException search(String[] arg) {
		if (arg.length != 1) {
			return new InputException("SEARCH", "INCOMPLETE");
		} else {
			return functionChecker.searchChecker(arg);
		}
	}

	protected InputException filter(String[] arg) {
		if (arg.length != 1) {
			return new InputException("FILTER", "INCOMPLETE");
		} else {
			return functionChecker.filterChecker(arg);
		}
	}

	protected InputException sort(String[] arg) {
		if (arg.length != 2) {
			return new InputException("SORT", "INCOMPLETE");
		} else {
			return functionChecker.sortChecker(arg[0], arg[1]);
		}
	}

	protected InputException label(String[] arg) {
		if (arg.length != 2) {
			return new InputException("LABEL", "INCOMPLETE");
		} else {
			return functionChecker.indexChecker("LABEL", arg);
		}
	}

	protected InputException setRecurring(String[] arg) {
		if (arg.length != 2) {
			return new InputException("SET-RECURRING", "INCOMPLETE");
		} else {
			return functionChecker.indexChecker("SET-RECURRING", arg);
		}
	}

	protected InputException removeRecurring(String[] arg) {
		if (arg.length != 1) {
			return new InputException("REMOVE-RECURRING", "INCOMPLETE");
		} else {
			return functionChecker.indexChecker("REMOVE-RECURRING", arg);
		}
	}

	protected InputException removeRemind(String[] arg) {
		if (arg.length != 1) {
			return new InputException("REMOVE-REMIND", "INCOMPLETE");
		} else {
			return functionChecker.indexChecker("REMOVE-REMIND", arg);
		}
	}

	protected InputException postpone(String[] arg) {
		if (arg.length != 3) {
			return new InputException("POSTPONE", "INCOMPLETE");
		} else {
			return functionChecker.indexChecker("POSTPONE", arg);
		}
	}

	protected InputException forward(String[] arg) {
		if (arg.length != 3) {
			return new InputException("FORWARD", "INCOMPLETE");
		} else {
			return functionChecker.indexChecker("FORWARD", arg);
		}
	}

	protected InputException addRemind(String[] arg) {
		return functionChecker.addRemindChecker(arg);
	}

	protected InputException remind(String[] arg) {
		if (arg.length != 1) {
			return new InputException("REMIND", "INCOMPLETE");
		} else {
			return functionChecker.indexChecker("REMIND", arg);
		}
	}

	protected InputException addRemindBef(String[] arg) {
		String[] restOfArgs = new String[arg.length - 2];
		for (int i = 0; i < arg.length; i++) {
			restOfArgs[i] = arg[i + 2];
		}
		return functionChecker.addRemindBefChecker(arg[0], arg[1], restOfArgs);
	}

	protected InputException remindBef(String[] arg) {
		if (arg.length != 3) {
			return new InputException("REMIND-BEF", "INCOMPLETE");
		} else {
			return functionChecker.indexChecker("REMIND-BEF", arg);
		}
	}

	protected InputException done(String[] arg) {
		if (arg.length != 1) {
			return new InputException("DONE", "INCOMPLETE");
		} else {
			return functionChecker.indexChecker("DONE", arg);
		}
	}

	protected InputException undone(String[] arg) {
		if (arg.length != 1) {
			return new InputException("UNDONE", "INCOMPLETE");
		} else {
			return functionChecker.indexChecker("UNDONE", arg);

		}
	}

	protected InputException exit(String[] arg) {
		return functionChecker.exitChecker(arg);
	}

	protected InputException undo(String[] arg) {
		if (arg.length != 1) {
			return new InputException("UNDO", "INCOMPLETE");
		} else {
			return functionChecker.undoChecker(arg[0]);
		}
	}

	protected InputException redo(String[] arg) {
		if (arg.length != 1) {
			return new InputException("REDO", "INCOMPLETE");
		} else {
			return functionChecker.redoChecker(arg[0]);
		}
	}

	protected InputException reset(String[] arg) {
		if (arg.length != 0) {
			return new InputException("RESET", "INVALID ARGUMENT");
		}
		return functionChecker.resetChecker();
	}

	protected InputException tab(String[] arg) {
		if (arg.length != 1) {
			return new InputException("TAB", "INCOMPLETE");
		} else {
			return functionChecker.tabChecker(arg[0]);
		}
	}

	protected InputException open(String[] arg) {
		return functionChecker.openChecker(arg[0]);
	}

	protected InputException save(String[] arg) {
		return functionChecker.saveChecker(arg[0]);
	}

	protected InputException invalid(String[] arg) {
		return functionChecker.invalidChecker();
	}

	protected InputException help(String[] arg) {
		return new InputException();
	}

	protected InputException clean(String[] arg) {
		return new InputException();
	}
}
```
###### /todolist/logic/FunctionChecker.java
``` java
package todolist.logic;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import todolist.model.InputException;
import todolist.model.SearchCommand;
import todolist.model.Task;
import todolist.storage.DataBase;

public class FunctionChecker {
	private Logic logic;
	private DataBase dataBase;

	protected FunctionChecker(Logic logic, DataBase dataBase) {
		this.logic = logic;
		this.dataBase = dataBase;
	}

	protected InputException addTaskChecker(String title) {
		if (noRepeat(title)) {
			return new InputException();
		} else {
			return new InputException("ADD", "REPEAT TITLE");
		}
	}

	protected InputException addEventChecker(String title, String startDate, String startTime, String quantity,
			String timeUnit) {
		if (noRepeat(title)) {
			if (validFuzzyDate(startDate)) {
				if (validTime(startTime)) {
					if (validQuantity(quantity)) {
						if (validUnit(timeUnit)) {
							return new InputException();
						} else {
							return new InputException("ADD EVENT", "INVALID TIME UNIT");
						}
					} else {
						return new InputException("ADD EVENT", "INVALID QUANTITY");
					}
				} else {
					return new InputException("ADD EVENT", "INVALID START TIME");
				}
			} else {
				return new InputException("ADD EVENT", "INVALID START DATE");
			}
		} else {
			return new InputException("ADD", "REPEAT TITLE");
		}
	}

	protected InputException addEventLessChecker(String title, String fuzzyTime, String quantity, String timeUnit) {
		if (noRepeat(title)) {
			if (validFuzzyTime(fuzzyTime)) {
				if (validQuantity(quantity)) {
					if (validUnit(timeUnit)) {
						return new InputException();
					} else {
						return new InputException("ADD EVENT", "INVALID TIME UNIT");
					}
				} else {
					return new InputException("ADD EVENT", "INVALID QUANTITY");
				}
			} else {
				return new InputException("ADD EVENT", "INVALID START TIME");
			}
		} else {
			return new InputException("ADD EVENT", "INVLAID TIME");
		}
	}

	protected InputException addDeadlineChecker(String title, String endDate, String endTime) {
		if (noRepeat(title)) {
			if (validFuzzyDate(endDate)) {
				if (validTime(endTime)) {
					return new InputException();
				} else {
					return new InputException("ADD DEADLINE", "INVALID END TIME");
				}
			} else {
				return new InputException("ADD DEADLINE", "INVLAID END DATE");
			}
		} else {
			return new InputException("ADD", "REPEAT TITLE");
		}
	}

	protected InputException addDeadlineLessChecker(String title, String fuzzyTime) {
		if (noRepeat(title)) {
			if (validFuzzyTime(fuzzyTime)) {
				return new InputException();
			} else {
				return new InputException("ADD DEADLINE", "INVALID END TIME");
			}
		} else {
			return new InputException("ADD", "REPEAT TITLE");
		}
	}

	protected InputException addRecurringEventChecker(String interval, String title, String startDate, String startTime,
			String quantity, String timeUnit) {
		if (validInterval(interval)) {
			return addEventChecker(title, startDate, startTime, quantity, timeUnit);
		} else {
			return new InputException("ADD RECURRING EVENT", "INVALID INTERVAL");
		}
	}

	protected InputException addRecurringEventLessChecker(String interval, String title, String fuzzyTime,
			String quantity, String timeUnit) {
		if (validInterval(interval)) {
			return addEventLessChecker(title, fuzzyTime, quantity, timeUnit);
		} else {
			return new InputException("ADD RECURRING EVENT", "INVALID INTERVAL");
		}
	}

	protected InputException addRecurringDeadlineChecker(String interval, String title, String endDate,
			String endTime) {
		if (validInterval(interval)) {
			return addDeadlineChecker(title, endDate, endTime);
		} else {
			return new InputException("ADD RECURRING DEADLINE", "INVALID INTERVAL");
		}
	}

	protected InputException addRecurringDeadlineLessChecker(String interval, String title, String fuzzyTime) {
		if (validInterval(interval)) {
			return addDeadlineLessChecker(title, fuzzyTime);
		} else {
			return new InputException("ADD RECURRING DEADLINE", "INVALID INTERVAL");
		}
	}

	protected InputException remindBefChecker(String title, String quantity, String timeUnit) {
		if (!noRepeat(title)) {
			if (validQuantity(quantity)) {
				if (validUnit(timeUnit)) {
					if (isFloating(title)) {
						return new InputException("REMIND BEF", "FLOATING TASK");
					} else {
						return new InputException();
					}
				} else {
					return new InputException("REMIND BEF", "INVALID TIME UNIT");
				}
			} else {
				return new InputException("REMIND BEF", "INVALID QUANTITY");
			}
		} else {
			return new InputException("REMIND BEF", "TASK NOT EXIST");
		}
	}

	protected InputException addRemindBefChecker(String quantity, String timeUnit, String[] arg) {
		if (validQuantity(quantity)) {
			if (validUnit(timeUnit)) {
				String type = arg[0];
				switch (type) {
				case "event":
					return addEventChecker(arg[1], arg[2], arg[3], arg[4], arg[5]);
				case "deadline":
					return addDeadlineChecker(arg[1], arg[2], arg[3]);
				case "task":
					return addTaskChecker(arg[1]);
				default:
					return new InputException("ADD REMIND BEF", "INVALID TYPE");
				}
			} else {
				return new InputException("ADD REMIND BEF", "INVALID TIME UNIT");
			}
		} else {
			return new InputException("ADD REMIND BEF", "INVALID QUANTITY");
		}
	}

	protected InputException remindChecker(String title) {
		if (!noRepeat(title)) {
			if (isFloating(title)) {
				return new InputException("REMIND", "FLOATING TASK");
			} else {
				return new InputException();
			}
		} else {
			return new InputException("REMIND", "TASK NOT EXIST");
		}
	}

	protected InputException forwardChecker(String title, String quantity, String timeUnit) {
		if (!noRepeat(title)) {
			if (validQuantity(quantity)) {
				if (validUnit(timeUnit)) {
					if (isFloating(title)) {
						return new InputException("FORWARD", "FLOATING TASK");
					} else {
						return new InputException();
					}
				} else {
					return new InputException("FORWARD", "INVALID TIME UNIT");
				}
			} else {
				return new InputException("FORWARD", "INVALID QUANTITY");
			}
		} else {
			return new InputException("FORWARD", "NOT EXIST");
		}
	}

	protected InputException postponeChecker(String title, String quantity, String timeUnit) {
		if (!noRepeat(title)) {
			if (validQuantity(quantity)) {
				if (validUnit(timeUnit)) {
					if (isFloating(title)) {
						return new InputException("POSTPONE", "FLOATING TASK");
					} else {
						return new InputException();
					}
				} else {
					return new InputException("POSTPONE", "INVALID TIME UNIT");
				}
			} else {
				return new InputException("POSTPONE", "INVALID QUANTITY");
			}
		} else {
			return new InputException("POSTPONE", "NOT EXIST");
		}
	}

	protected InputException redoChecker(String redostep) {
		if (isInteger(redostep)) {
			if (Integer.parseInt(redostep) > 0) {
				if (logic.getSnapshot()[logic.checkStep() + Integer.parseInt(redostep)] == null) {
					return new InputException("REDO", "NO ACTION TO REDO");
				} else {
					return new InputException();
				}
			} else {
				return new InputException("REDO", "STEP NOT POSITIVE");
			}
		} else {
			return new InputException("REDO", "AUGUMENT NOT INTEGER");
		}
	}

	protected InputException undoChecker(String undostep) {
		if (isInteger(undostep)) {
			if (Integer.parseInt(undostep) > 0) {
				if (logic.checkStep() - Integer.parseInt(undostep) < 0) {
					return new InputException("UNDO", "NO ACTION TO UNDO");
				} else {
					return new InputException();
				}
			} else {
				return new InputException("UNDO", "STEP NOT POSITIVE");
			}
		} else {
			return new InputException("UNDO", "AUGUMENT NOT INTEGER");
		}
	}

	protected InputException undoneChecker(String title) {
		if (!noRepeat(title)) {
			return new InputException();
		} else {
			return new InputException("UNDONE", "NOT EXIST");
		}
	}

	protected InputException removeRemindChecker(String title) {
		if (!noRepeat(title)) {
			return new InputException();
		} else {
			return new InputException("REMOVE REMIND", "NOT EXIST");
		}
	}

	protected InputException doneChecker(String title) {
		if (!noRepeat(title)) {
			return new InputException();
		} else {
			return new InputException("DONE", "NOT EXIST");
		}
	}

	protected InputException openChecker(String path) {
		return new InputException();
	}

	protected InputException saveChecker(String path) {
		return new InputException();
	}

	protected InputException invalidChecker() {
		return new InputException("PARSER", "INVALID INPUT");
	}

	protected InputException tabChecker(String workplace) {
		switch (workplace) {
		case "all":
			return new InputException();
		case "expired":
			return new InputException();
		case "today":
			return new InputException();
		case "week":
			return new InputException();
		case "done":
			return new InputException();
		case "options":
			return new InputException();
		case "help":
			return new InputException();
		default:
			return new InputException("TAB", "WORDPLACE NOT EXIST");
		}
	}

	protected InputException setRecurringChecker(String title, Boolean status, String interval) {
		if (!noRepeat(title)) {
			if ((status && validInterval(interval)) || (!status)) {
				if (isFloating(title)) {
					return new InputException("SET RECURRING", "FLOATING TASK");
				} else {
					return new InputException();
				}
			} else {
				return new InputException("SET RECURRING", "INVALID INTERVAL");
			}
		} else {
			return new InputException("SET RECURRING", "TASK NOT EXIST");
		}
	}

	protected InputException labelChecker(String title, String category) {
		if (!noRepeat(title)) {
			return new InputException();
		} else {
			return new InputException("LABEL", "TASK NOT EXIST");
		}
	}

	protected InputException sortChecker(String fieldName, String order) {
		if (validOrder(order)) {
			switch (fieldName) {
			case "title":
				return new InputException();
			case "category":
				return new InputException();
			case "start":
				return new InputException();
			case "end":
				return new InputException();
			default:
				return new InputException("SORT", "INVALID FIELDNAME");
			}
		} else {
			return new InputException("SORT", "INVALID ORDER");
		}
	}

	protected InputException filterChecker(String[] arg) {
		return new InputException();
	}

	protected InputException searchChecker(String[] arg) {
		return new InputException();
	}

	protected InputException editChecker(String title, String fieldName, String newValue) {
		if (!noRepeat(title)) {
			switch (fieldName) {
			case "title":
				return new InputException();
			case "done":
				return new InputException();
			case "undone":
				return new InputException();
			case "start-time":
				return new InputException();
			case "end-time":
				return new InputException();
			default:
				return new InputException("EDIT", "FIELD NOT EXIST");
			}
		} else {
			return new InputException("EDIT", "TASK NOT EXIST");
		}
	}

	protected InputException deleteChecker(String title) {
		if (!noRepeat(title)) {
			return new InputException();
		} else {
			return new InputException("DELETE", "TASK NOT EXIST");
		}
	}

	protected InputException resetChecker() {
		return new InputException();
	}

	protected InputException exitChecker(String[] arg) {
		return new InputException();
	}

	protected InputException addRemindChecker(String[] arg) {
		String type = arg[0];
		switch (type) {
		case "event":
			return addEventChecker(arg[1], arg[2], arg[3], arg[4], arg[5]);
		case "deadline":
			return addDeadlineChecker(arg[1], arg[2], arg[3]);
		case "task":
			return addTaskChecker(arg[1]);
		default:
			return new InputException("ADD REMIND", "INVALID TYPE");
		}
	}

	protected InputException indexChecker(String type, String[] arg) {
		String temp[] = arg[0].split(",");
		int[] index = new int[temp.length];
		Boolean flag = true;

		for (int i = 0; i < temp.length; i++) {
			if (isInteger(temp[i])) {
				index[i] = Integer.parseInt(temp[i]);
			} else {
				flag = false;
			}
		}

		if (flag) {
			return checkInView(index, type, arg);
		} else {
			return typeCaseSwitcher(type, arg[0], arg);
		}
	}

	private InputException checkInView(int[] index, String type, String[] arg) {
		for (int i = 0; i < index.length; i++) {
			Task task = logic.getMainApp().getTaskAt(index[i]);
			if (task == null) {
				return new InputException(type, "TASK NOT EXIST");
			} else {
				String taskname = logic.getMainApp().getTaskAt(index.length).getName().getName();
				InputException tempException = typeCaseSwitcher(type, taskname, arg);
				if (!tempException.getCorrectness()) {
					return tempException;
				}
			}
		}
		return new InputException();
	}

	private InputException typeCaseSwitcher(String type, String taskname, String[] arg) {
		switch (type) {
		case "EDIT":
			return editChecker(taskname, arg[1], arg[2]);
		case "DELETE":
			return deleteChecker(taskname);
		case "LABEL":
			return labelChecker(taskname, arg[1]);
		case "SET-RECURRING":
			return setRecurringChecker(taskname, true, arg[1]);
		case "REMOVE-RECURRING":
			return setRecurringChecker(taskname, false, null);
		case "REMOVE-REMIND":
			return removeRemindChecker(taskname);
		case "POSTPONE":
			return postponeChecker(taskname, arg[1], arg[2]);
		case "FORWARD":
			return forwardChecker(taskname, arg[1], arg[2]);
		case "REMIND":
			return remindChecker(taskname);
		case "REMIND-BEF":
			return remindBefChecker(taskname, arg[1], arg[2]);
		case "DONE":
			return doneChecker(taskname);
		case "UNDONE":
			return undoneChecker(taskname);
		default:
			return new InputException("UNKNOWN", "UNKNOWN");
		}
	}

	private Boolean noRepeat(String title) {
		ArrayList<Task> tempTaskList = dataBase.retrieve(new SearchCommand("NAME", title));
		if (tempTaskList.size() > 0) {
			return false;
		} else {
			return true;
		}
	}

	private Boolean validFuzzyDate(String fuzzyDate) {
		int count = fuzzyDate.length() - fuzzyDate.replace("-", "").length();
		if (count == 1) {
			return validFuzzyDateTwo(fuzzyDate);
		} else {
			if (count == 2) {
				return validFuzzyDateThree(fuzzyDate);
			}
			return false;
		}
	}

	private Boolean validFuzzyDateThree(String fuzzyDate) {
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
		sdf.setLenient(false);
		try {
			@SuppressWarnings("unused")
			Date newFuzzyDate = sdf.parse(fuzzyDate);
		} catch (ParseException e) {
			e.printStackTrace();
			return false;
		}
		return true;
	}

	private Boolean validFuzzyDateTwo(String fuzzyDate) {
		SimpleDateFormat sdf = new SimpleDateFormat("MM-dd");
		sdf.setLenient(false);
		try {
			@SuppressWarnings("unused")
			Date newFuzzyDate = sdf.parse(fuzzyDate);
		} catch (ParseException e) {
			e.printStackTrace();
			return false;
		}
		return true;
	}

	private Boolean validFuzzyTime(String fuzzyTime) {
		if (fuzzyTime.contains("-")) {
			return validFuzzyTime(fuzzyTime);
		} else {
			if (fuzzyTime.contains(":")) {
				return validTime(fuzzyTime);
			} else {
				return false;
			}
		}
	}

	private Boolean validTime(String time) {
		SimpleDateFormat sdf = new SimpleDateFormat("HH:mm");
		sdf.setLenient(false);
		try {
			@SuppressWarnings("unused")
			Date newTime = sdf.parse(time);
		} catch (ParseException e) {
			e.printStackTrace();
			return false;
		}
		return true;
	}

	private Boolean validInterval(String interval) {
		String temp[] = interval.split("-");
		String length = temp[0];
		String unit = temp[1];
		if (isInteger(length) && Integer.parseInt(length) > 0) {
			return validUnit(unit);
		} else {
			return false;
		}
	}

	private boolean validUnit(String unit) {
		switch (unit) {
		case "day":
			return true;
		case "hour":
			return true;
		case "minute":
			return true;
		case "week":
			return true;
		case "month":
			return true;
		case "year":
			return true;
		default:
			return false;
		}
	}

	private Boolean validQuantity(String quantity) {
		if (isInteger(quantity) && Integer.parseInt(quantity) > 0) {
			return true;
		} else {
			return false;
		}
	}

	private boolean isInteger(String s) {
		try {
			@SuppressWarnings("unused")
			int i = Integer.parseInt(s);
			return true;
		} catch (NumberFormatException er) {
			return false;
		}
	}

	private boolean isFloating(String title) {
		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		if (tempTask.getEndTime() == null) {
			return true;
		} else {
			return false;
		}
	}

	private boolean validOrder(String order) {
		if (order.equalsIgnoreCase("ascending") || order.equalsIgnoreCase("descending")) {
			return true;
		} else {
			return false;
		}
	}
}
```
###### /todolist/logic/InputErrorChecker.java
``` java
package todolist.logic;

import todolist.model.InputException;
import todolist.model.TokenizedCommand;
import todolist.storage.DataBase;

public class InputErrorChecker {
	private Logic logic;
	private DataBase dataBase;
	private CommandChecker commandChecker;

	protected InputErrorChecker(Logic logic, DataBase dataBase) {
		this.logic = logic;
		this.dataBase = dataBase;
		commandChecker = new CommandChecker(this.logic, this.dataBase);
	}

	protected InputException validate(TokenizedCommand command) {
		String action = command.getAction();
		String arg[] = command.getArgs();

		switch (action) {
		case "add":
			return commandChecker.add(arg);
		case "edit":
			return commandChecker.edit(arg);
		case "delete":
			return commandChecker.delete(arg);
		case "search":
			return commandChecker.search(arg);
		case "filter":
			return commandChecker.filter(arg);
		case "sort":
			return commandChecker.sort(arg);
		case "label":
			return commandChecker.label(arg);
		case "set-recurring":
			return commandChecker.setRecurring(arg);
		case "remove-recurring":
			return commandChecker.removeRecurring(arg);
		case "postpone":
			return commandChecker.postpone(arg);
		case "forward":
			return commandChecker.forward(arg);
		case "add-remind":
			return commandChecker.addRemind(arg);
		case "remind":
			return commandChecker.remind(arg);
		case "add-remind-bef":
			return commandChecker.addRemindBef(arg);
		case "remind-bef":
			return commandChecker.remindBef(arg);
		case "remove-remind":
			return commandChecker.removeRemind(arg);
		case "done":
			return commandChecker.done(arg);
		case "undone":
			return commandChecker.undone(arg);
		case "exit":
			return commandChecker.exit(arg);
		case "undo":
			return commandChecker.undo(arg);
		case "redo":
			return commandChecker.redo(arg);
		case "reset":
			return commandChecker.reset(arg);
		case "save":
			return commandChecker.save(arg);
		case "open":
			return commandChecker.open(arg);
		case "tab":
			return commandChecker.tab(arg);
		case "invalid":
			return commandChecker.invalid(arg);
		case "help":
			return commandChecker.help(arg);
		case "clean":
			return commandChecker.clean(arg);
		default:
			return new InputException("UNKNOWN", "UNKNOWN");
		}
	}
}
```
###### /todolist/logic/Logic.java
``` java
package todolist.logic;

import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalUnit;
import java.util.ArrayList;
import java.util.Date;

import todolist.MainApp;
import todolist.common.UtilityLogger;
import todolist.common.UtilityLogger.Component;
import todolist.model.Category;
import todolist.model.Name;
import todolist.model.Reminder;
import todolist.model.SearchCommand;
import todolist.model.Task;
import todolist.model.TokenizedCommand;
import todolist.parser.MainParser;
import todolist.storage.DataBase;

public class Logic {

	private static final String TITLE_TRUNCATION = "...";
	private static final int TITLE_CAP_SIZE = 25;

	private MainApp mainApp;
	public DataBase dataBase;
	private UIHandler uiHandler;
	private MainParser mainParser;
	private CaseSwitcher caseSwitcher;
	private int steps;
	private UtilityLogger logger;
	ArrayList<Task>[] snapshot;

	protected static Component COMPONENT_LOGIC = UtilityLogger.Component.Logic;

	@SuppressWarnings("unchecked")
	public Logic(MainApp mainApp) {
		this.setMainApp(mainApp);
		this.dataBase = new DataBase();
		this.mainParser = new MainParser();
		this.uiHandler = new UIHandler(dataBase, mainApp, this);
		this.caseSwitcher = new CaseSwitcher(this, dataBase);
		this.steps = 0;
		snapshot = new ArrayList[1000];
		snapshot[0] = dataBase.retrieveAll();
		logger = new UtilityLogger();
	}

	/**
	 * This method takes in raw user input and process it by calling parser
	 *
	 * @param String
	 *            take in the user input string
	 * @return void
	 */
	public void process(String input) {
		TokenizedCommand tokenizedCommand = mainParser.parse(input);
		caseSwitcher.execute(tokenizedCommand);
	}

	/**
	 * This method adds a new floating task.
	 * 
	 * @param String
	 *            title of the task to add
	 * 
	 * @return Boolean return true if the task is successfully added
	 */
	public Boolean addTask(String title) {
		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_ADDING_FLOATING_TASK + title);

		Name name = new Name(title);
		Task newEvent = new Task(name, null, null, null, null, false, false, null);

		Boolean addResponse = dataBase.add(newEvent);

		// UI handling
		uiHandler.refresh();
		uiHandler.highLight(newEvent);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_ADD_TASK, truncateTitle(title)), true);

		return addResponse;
	}

	/**
	 * This method adds a new event with start date and duration
	 * 
	 * @param title
	 *            the title of the event
	 * @param startDate
	 *            start date of the event
	 * @param startTime
	 *            start time of the event
	 * @param quantity
	 *            quantity of the duration of the event
	 * @param timeUnit
	 *            unit of the duration of the event
	 * @return Boolean true if the event is successfully added
	 */
	public Boolean addEvent(String title, String startDate, String startTime, String quantity, String timeUnit) {
		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_ADDING_EVENT + title);

		Name name = new Name(title);
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
		LocalDateTime start = LocalDateTime.parse(fuzzyParseDate(startDate) + " " + startTime, formatter);
		LocalDateTime end = start.plus(Long.parseLong(quantity), generateTimeUnit(timeUnit));

		Task newEvent = new Task(name, start, end, null, null, false, false, null);

		Boolean addResponse = dataBase.add(newEvent);

		// UI handling
		uiHandler.refresh();
		uiHandler.highLight(newEvent);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_ADD_EVENT, truncateTitle(title)), true);

		return addResponse;
	}

	/**
	 * This method adds a new event with start date and duration(less argument
	 * and fuzzy time)
	 * 
	 * @param title
	 *            title of the event
	 * @param fuzzyTime
	 *            date or time of the event
	 * @param quantity
	 *            quantity of the duration of the event
	 * @param timeUnit
	 *            unit of the duration of the event
	 * @return boolean true if the event is successfully added
	 */
	public Boolean addEventLess(String title, String fuzzyTime, String quantity, String timeUnit) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_ADDING_EVENT + title);

		LocalDateTime start = fuzzyParseTime(fuzzyTime);
		LocalDateTime end = start.plus(Long.parseLong(quantity), generateTimeUnit(timeUnit));

		Name name = new Name(title);

		Task newEvent = new Task(name, start, end, null, null, false, false, null);

		Boolean addResponse = dataBase.add(newEvent);

		// UI handling
		uiHandler.refresh();
		uiHandler.highLight(newEvent);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_ADD_EVENT, truncateTitle(title)), true);

		return addResponse;
	}

	/**
	 * 
	 * @param title
	 *            title of the deadline to add
	 * @param endDate
	 *            end date of the deadline to add
	 * @param endTime
	 *            end time of the deadline to add
	 * @return Boolean true if the deadline is successfully added
	 */
	public Boolean addDeadline(String title, String endDate, String endTime) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_ADDING_DEADLINE + title);

		Name name = new Name(title);
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
		LocalDateTime end = LocalDateTime.parse(fuzzyParseDate(endDate) + " " + endTime, formatter);
		Task newEvent = new Task(name, null, end, null, null, false, false, null);

		Boolean addResponse = dataBase.add(newEvent);

		// UI handling
		uiHandler.refresh();
		uiHandler.highLight(newEvent);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_ADD_DEADLINE, truncateTitle(title)), true);

		return addResponse;
	}

	/**
	 * This method adds a new deadline.(less argument and fuzzy time)
	 * 
	 * @param title
	 *            title of the deadline to add
	 * @param fuzzyTime
	 *            date or time of the deadline to add
	 * @return Boolean true if the deadline is successfully added
	 */
	public Boolean addDeadlineLess(String title, String fuzzyTime) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_ADDING_DEADLINE + title);

		Name name = new Name(title);
		LocalDateTime end = fuzzyParseTime(fuzzyTime);
		Task newEvent = new Task(name, null, end, null, null, false, false, null);

		Boolean addResponse = dataBase.add(newEvent);

		// UI handling
		uiHandler.refresh();
		uiHandler.highLight(newEvent);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_ADD_DEADLINE, truncateTitle(title)), true);

		return addResponse;
	}

	/**
	 * This method adds an recurring event
	 * 
	 * @param interval
	 *            interval of the recurring event to add
	 * @param title
	 *            title of the event to add
	 * @param startDate
	 *            start date of the event to add
	 * @param startTime
	 *            start time of the event to add
	 * @param quantity
	 *            quantity of the duration of the event
	 * @param timeUnit
	 *            unit of the duration of the event
	 * @return Boolean true if the recurring event is successfully added
	 */
	public Boolean addRecurringEvent(String interval, String title, String startDate, String startTime, String quantity,
			String timeUnit) {
		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_ADDING_RECURRING_EVENT + title);

		Boolean addResponse = addEvent(title, startDate, startTime, quantity, timeUnit);
		Boolean setRecurringResponse = setRecurring(title, true, interval);
		return addResponse && setRecurringResponse;
	}

	/**
	 * This method adds an recurring event.(less argument and fuzzy time)
	 * 
	 * @param interval
	 *            interval of the recurring event to add
	 * @param title
	 *            title of the event to add
	 * @param fuzzyTime
	 *            start date or time of the event to add
	 * @param quantity
	 *            quantity of the duration of the event
	 * @param timeUnit
	 *            unit of the duration of the event
	 * @return Boolean true if the recurring event is successfully added
	 */
	public Boolean addRecurringEventLess(String interval, String title, String fuzzyTime, String quantity,
			String timeUnit) {
		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_ADDING_RECURRING_EVENT + title);

		Boolean addResponse = addEventLess(title, fuzzyTime, quantity, timeUnit);
		Boolean setRecurringResponse = setRecurring(title, true, interval);
		return addResponse && setRecurringResponse;
	}

	/**
	 * This method adds an recurring deadline
	 * 
	 * @param interval
	 *            interval of the recurring deadline to add
	 * @param title
	 *            title of the deadline to add
	 * @param endDate
	 *            end date of the deadline to add
	 * @param endTime
	 *            end time of the deadline to add
	 * @return Boolean true if the recurring deadline is successfully added
	 */
	public Boolean addRecurringDeadline(String interval, String title, String endDate, String endTime) {
		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_ADDING_RECURRING_DEADLINE + title);

		Boolean addResponse = addDeadline(title, endDate, endTime);
		Boolean setRecurringResponse = setRecurring(title, true, interval);
		return addResponse && setRecurringResponse;
	}

	/**
	 * This method adds an recurring deadline.(less argument and fuzzy time)
	 * 
	 * @param interval
	 *            interval of the recurring deadline to add
	 * @param title
	 *            title of the deadline to add
	 * @param fuzzyTime
	 *            end date or time of the deadline
	 * @return Boolean true if the recurring deadline is successfully added
	 */
	public Boolean addRecurringDeadlineLess(String interval, String title, String fuzzyTime) {
		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_ADDING_RECURRING_DEADLINE + title);

		Boolean addResponse = addDeadlineLess(title, fuzzyTime);
		Boolean setRecurringResponse = setRecurring(title, true, interval);
		return addResponse && setRecurringResponse;
	}

	/**
	 * This method edits a task.
	 * 
	 * @param title
	 *            title of the task to edit
	 * @param fieldName
	 *            the field to edit
	 * @param newValue
	 *            the new value to put
	 * @return Boolean true if the task is successfully edited
	 */
	public Boolean edit(String title, String fieldName, String newValue) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBase.delete(tempTask);

		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd-HH:mm");

		switch (fieldName) {
		case "title":
			tempTask.setName(new Name(newValue));
			break;
		case "done":
			tempTask.setDoneStatus(true);
			break;
		case "undone":
			tempTask.setDoneStatus(false);
			break;
		case "start-time":
			LocalDateTime start = null;
			if (newValue.equals("remove")) {
				start = null;
				tempTask.setStartTime(start);
			} else {
				start = LocalDateTime.parse(newValue, formatter);
				if (tempTask.getEndTime() == null) {
					tempTask.setStartTime(start);
					tempTask.setEndTime(start);
				} else {
					tempTask.setStartTime(start);
				}
			}
			break;
		case "end-time":
			LocalDateTime end = null;

			if (newValue.equals("remove")) {
				end = null;
				start = null;
				tempTask.setStartTime(start);
				tempTask.setEndTime(end);

			} else {
				end = LocalDateTime.parse(newValue, formatter);
				tempTask.setEndTime(end);
			}
			break;
		}

		Boolean addResponse = dataBase.add(tempTask);

		// UI handling
		uiHandler.refresh();
		uiHandler.highLight(tempTask);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_EDIT, truncateTitle(title)), true);

		return deleteResponse && addResponse;
	}

	/**
	 * This method takes in the title of a task and deletes it.
	 * 
	 * @param title
	 *            title of the task to delete
	 * @return Boolean return true if the task is successfully deleted
	 */
	public Boolean delete(String title) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_DELETING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBase.delete(tempTask);

		// UI handling
		uiHandler.refresh();
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_DELETE, truncateTitle(title)), true);

		return deleteResponse;
	}

	/**
	 * This method takes in the title of a task and displays it.
	 * 
	 * @param keyword
	 *            the keyword in title to search for
	 * @return Boolean return true if there is at one search result
	 */
	public Boolean search(String input) {
		
		String[] keyword = input.split(" ");

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_SEARCHING_TASK + input);

		ArrayList<Task> tempTaskList = dataBase.smartSearch(keyword);

		// UI handling
		uiHandler.display(tempTaskList);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_SEARCH, truncateTitle(keyword)), false);

		return true;
	}

	/**
	 * This method takes in the name of a category and displays tasks of that
	 * category.
	 * 
	 * @param category
	 *            the category of tasks to filter base on
	 * @return Boolean if there is at one task found under this category
	 */
	public Boolean filter(String category) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_SEARCHING_TASK + category);

		ArrayList<Task> tempTaskList = dataBase.retrieve(new SearchCommand("CATEGORY", category));

		// UI handling
		uiHandler.display(tempTaskList);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_FILTER, truncateTitle(category)), false);

		return true;
	}

	/**
	 * This method sorts all tasks in according to the field name and order.
	 * 
	 * @param fieldName
	 *            the field to sort based on
	 * @param order
	 *            the order to sort the list of task
	 * @return Boolean return true if the list of task is successfully sorted
	 */
	public Boolean sort(String fieldName, String order) {
		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_SORTING_TASK + fieldName);

		dataBase.sort(fieldName, order);

		// UI handling
		uiHandler.refresh();
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_SORT, truncateTitle(fieldName)), true);

		return true;
	}

	/**
	 * This method takes in the title of a task and labels it with a category.
	 * 
	 * @param title
	 *            title of the task to label
	 * @param category
	 *            category of the task to put under
	 * @return Boolean return true if the task is successfully labeled under the
	 *         category
	 */
	public Boolean label(String title, String category) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBase.delete(tempTask);

		tempTask.setCategory(new Category(category));
		Boolean addResponse = dataBase.add(tempTask);

		// UI handling
		uiHandler.refresh();
		uiHandler.highLight(tempTask);
		uiHandler.sendMessage(
				String.format(ResponseMessage.MESSAGE_SUCCESS_LABEL, truncateTitle(title), truncateTitle(category)),
				true);

		return deleteResponse && addResponse;
	}

	/**
	 * This method edits the recurring status of a task.
	 * 
	 * @param title
	 *            title of the task to set
	 * @param status
	 *            true if it is to set as recurring, false if it is to remove
	 *            the recurring
	 * @param interval
	 *            the interval to repeat the task
	 * @return Boolean true if the task is successfully set as recurring or
	 *         removed the recurring
	 */
	public Boolean setRecurring(String title, Boolean status, String interval) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBase.delete(tempTask);
		if (tempTask.getEndTime() == null) {
			throw new RuntimeException();
		}
		tempTask.setRecurring(status);
		tempTask.setInterval(interval);
		Boolean addResponse = dataBase.add(tempTask);

		// UI handling
		uiHandler.refresh();
		uiHandler.highLight(tempTask);
		if (status) {
			uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_RECURRING, truncateTitle(title)), true);
		} else {
			uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_NON_RECURRING, truncateTitle(title)),
					true);
		}

		return deleteResponse && addResponse;
	}

	/**
	 * This method postpones a task by a duration
	 * 
	 * @param title
	 *            title of the task to postpone
	 * @param quantity
	 *            quantity of the duration to postpone
	 * @param timeUnit
	 *            unit of the duration to postpone
	 * @return Boolean return true if the task is successfully postponed
	 */
	public Boolean postpone(String title, String quantity, String timeUnit) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBase.delete(tempTask);

		Boolean addResponse = false;

		if (tempTask.getReminder() != null && tempTask.getReminder().getStatus()) {
			LocalDateTime oldReminderTime = tempTask.getReminder().getTime();
			LocalDateTime newReminderTime = oldReminderTime.plus(Long.parseLong(quantity), generateTimeUnit(timeUnit));
			tempTask.setReminder(new Reminder(true, newReminderTime));
		}

		if (tempTask.getStartTime() == null) {
			LocalDateTime tempEndTime = tempTask.getEndTime();
			tempEndTime = tempEndTime.plus(Long.parseLong(quantity), generateTimeUnit(timeUnit));

			tempTask.setEndTime(tempEndTime);
		} else {
			LocalDateTime tempStartTime = tempTask.getStartTime();
			LocalDateTime tempEndTime = tempTask.getEndTime();
			tempStartTime = tempStartTime.plus(Long.parseLong(quantity), generateTimeUnit(timeUnit));
			tempEndTime = tempEndTime.plus(Long.parseLong(quantity), generateTimeUnit(timeUnit));

			tempTask.setStartTime(tempStartTime);
			tempTask.setEndTime(tempEndTime);
		}
		addResponse = dataBase.add(tempTask);

		// UI handling
		uiHandler.refresh();
		uiHandler.highLight(tempTask);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_POSTPONE, truncateTitle(title)), true);

		return deleteResponse && addResponse;
	}

	/**
	 * This method forwards a task by a duration.
	 * 
	 * @param title
	 *            title of the task to forward
	 * @param quantity
	 *            quantity of the duration to forward
	 * @param timeUnit
	 *            unit of the duration to forward
	 * @return Boolean return true if the task is successfully forward
	 */
	public Boolean forward(String title, String quantity, String timeUnit) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBase.delete(tempTask);

		Boolean addResponse = false;

		if (tempTask.getReminder() != null && tempTask.getReminder().getStatus()) {
			LocalDateTime oldReminderTime = tempTask.getReminder().getTime();
			LocalDateTime newReminderTime = oldReminderTime.minus(Long.parseLong(quantity), generateTimeUnit(timeUnit));
			tempTask.setReminder(new Reminder(true, newReminderTime));
		}

		if (tempTask.getStartTime() == null) {
			LocalDateTime tempEndTime = tempTask.getEndTime();
			tempEndTime = tempEndTime.minus(Long.parseLong(quantity), generateTimeUnit(timeUnit));
			tempTask.setEndTime(tempEndTime);
		} else {
			LocalDateTime tempStartTime = tempTask.getStartTime();
			LocalDateTime tempEndTime = tempTask.getEndTime();
			tempStartTime = tempStartTime.minus(Long.parseLong(quantity), generateTimeUnit(timeUnit));
			tempEndTime = tempEndTime.minus(Long.parseLong(quantity), generateTimeUnit(timeUnit));
			tempTask.setStartTime(tempStartTime);
			tempTask.setEndTime(tempEndTime);
		}

		addResponse = dataBase.add(tempTask);

		// UI handling
		uiHandler.refresh();
		uiHandler.highLight(tempTask);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_FORWARD, truncateTitle(title)), true);

		return deleteResponse && addResponse;
	}

	/**
	 * This method adds a task with remind and triggers the remind at the
	 * deadline.
	 * 
	 * @param arg
	 *            the information of the task to set reminder for
	 * @return Boolean return true if a reminder is successfully for this task
	 */
	public Boolean addRemind(String[] arg) {

		Boolean addResponse = false;

		String type = arg[0];
		switch (type) {
		case "event":
			addResponse = addEvent(arg[1], arg[2], arg[3], arg[4], arg[5]);
			break;
		case "deadline":
			addResponse = addDeadline(arg[1], arg[2], arg[3]);
			break;
		case "task":
			addResponse = addTask(arg[1]);
			break;
		}

		remind(arg[1]);

		return addResponse;
	}

	/**
	 * This method adds remind to an existing task and triggers the remind at
	 * the deadline.
	 * 
	 * @param title
	 *            title of the task to set reminder for
	 * @return Boolean return true if a reminder is successfully set for this
	 *         task
	 */
	public Boolean remind(String title) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_EDITING_TASK + title);

		return remindBef(title, "0", "minute");
	}

	/**
	 * This method adds remind to an existing task and triggers the remind a
	 * duration before the deadline.
	 * 
	 * @param title
	 *            title of the task to set reminder for
	 * @param quantity
	 *            quantity of the duration to remind before the end time of the
	 *            task
	 * @param timeUnit
	 *            unit of the duration to remind before the end time of the task
	 * @return Boolean return true if a reminder is successfully set for this
	 *         task
	 */
	public Boolean remindBef(String title, String quantity, String timeUnit) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		LocalDateTime reminderTime = null;

		if (quantity == null) {
			if (tempTask.getStartTime() == null) {
				reminderTime = tempTask.getStartTime();
			} else {
				reminderTime = tempTask.getEndTime();
			}
		} else {
			if (tempTask.getStartTime() != null) {
				reminderTime = tempTask.getStartTime().minus(Long.parseLong(quantity), generateTimeUnit(timeUnit));
			} else {
				reminderTime = tempTask.getEndTime().minus(Long.parseLong(quantity), generateTimeUnit(timeUnit));
			}
		}

		Boolean deleteResponse = dataBase.delete(tempTask);

		Reminder newReminder = new Reminder(true, reminderTime);

		tempTask.setReminder(newReminder);

		Boolean addResponse = dataBase.add(tempTask);

		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("d-MMM h:ma");

		String remindTimeString = reminderTime.format(formatter);

		// UI handling
		uiHandler.refresh();
		uiHandler.highLight(tempTask);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_REMIND, truncateTitle(title),
				truncateTitle(remindTimeString)), true);

		return deleteResponse && addResponse;
	}

	/**
	 * This method adds a task with remind and triggers the remind a duration
	 * before the deadline.
	 * 
	 * @param quantity
	 *            quantity of the duration to remind before the end time of the
	 *            task
	 * @param timeUnit
	 *            unit of the duration to remind before the end time of the task
	 * @param arg
	 *            the information of the task to set reminder for
	 * @return Boolean return true if a reminder is successfully set for this
	 *         task
	 */
	public Boolean addRemindBef(String quantity, String timeUnit, String[] arg) {

		String type = arg[0];

		Boolean addResponse = false;

		switch (type) {
		case "event":
			addResponse = addEvent(arg[1], arg[2], arg[3], arg[4], arg[5]);
			break;
		case "deadline":
			addResponse = addDeadline(arg[1], arg[2], arg[3]);
			break;
		case "task":
			addResponse = addTask(arg[1]);
			break;
		}

		remindBef(arg[1], quantity, timeUnit);

		return addResponse;
	}

	/**
	 * This method takes in the title of a task and removes its reminder.
	 * 
	 * @param title
	 *            title of the task to remove the reminder
	 * @return Boolean return true if the reminder is successfully removed
	 */
	public Boolean removeRemind(String title) {
		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);

		Boolean deleteResponse = dataBase.delete(tempTask);

		tempTask.setReminder(new Reminder(false, null));

		Boolean addResponse = dataBase.add(tempTask);

		uiHandler.refresh();
		uiHandler.highLight(tempTask);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_REMOVE_REMIND, truncateTitle(title)), true);

		return addResponse && deleteResponse;
	}

	/**
	 * This method takes in the title of a task and marks it as done.
	 * 
	 * @param title
	 *            title of the task to set the done status
	 * @return Boolean return true if the task is successfully set as done
	 */
	public Boolean done(String title) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBase.delete(tempTask);

		tempTask.setDoneStatus(true);
		String tempName = tempTask.getName().getName();

		if (tempTask.getRecurringStatus()) {
			tempTask.setName(new Name(tempName + " finished on " + getCurrentTimeStamp()));
		}

		Boolean addResponse = dataBase.add(tempTask);

		if (tempTask.getRecurringStatus()) {

			String interval = tempTask.getInterval();
			String temp[] = interval.split("-");
			String length = temp[0];
			String unit = temp[1];

			LocalDateTime oldEndTime = tempTask.getEndTime();
			LocalDateTime newEndTime = oldEndTime.plus(Long.parseLong(length), generateTimeUnit(unit));
			LocalDateTime newStartTime = null;
			if (tempTask.getStartTime() != null) {
				LocalDateTime oldStartTime = tempTask.getStartTime();
				newStartTime = oldStartTime.plus(Long.parseLong(length), generateTimeUnit(unit));
			}

			Task newTempTask = new Task(new Name(tempName), newStartTime, newEndTime, tempTask.getCategory(),
					tempTask.getReminder(), false, true, interval);
			addResponse = dataBase.add(newTempTask);

		}

		// UI handling
		uiHandler.refresh();
		uiHandler.highLight(tempTask);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_ARCHIVE, truncateTitle(title)), true);

		return deleteResponse && addResponse;
	}

	/**
	 * This method takes in the title of a task and marks it as undone.
	 * 
	 * @param title
	 *            title of the task to set the done status
	 * @return Boolean return true if the task is successfully set as undone
	 */
	public Boolean undone(String title) {

		logger.logAction(COMPONENT_LOGIC, ResponseMessage.MESSAGE_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBase.delete(tempTask);

		tempTask.setDoneStatus(false);
		Boolean addResponse = dataBase.add(tempTask);

		// UI handling
		uiHandler.refresh();
		uiHandler.highLight(tempTask);
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_UNARCHIVE, truncateTitle(title)), true);

		return deleteResponse && addResponse;
	}

	/**
	 * This method terminates the application.
	 *
	 * 
	 * @return void
	 */
	public void exit() {
		System.exit(0);
	}

	/**
	 * This method takes in an integer and undo that number of steps.
	 * 
	 * @param undostep
	 *            number of steps to undo
	 * @return Boolean return true if successfully go back to the number of
	 *         steps before
	 */
	public Boolean undo(int undostep) {
		Boolean undoResponse = false;
		steps = steps - undostep;
		undoResponse = dataBase.recover(snapshot[steps]);

		// UI handling
		uiHandler.refresh();
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_UNDO, undostep), true);

		return undoResponse;
	}

	/**
	 * This method takes in an integer and redo that number of steps.
	 * 
	 * @param undostep
	 *            number of steps to redo
	 * @return Boolean return true if successfully go back to the number of
	 *         steps later
	 */
	public Boolean redo(int redostep) {
		Boolean redoResponse = false;
		steps = steps + redostep;
		redoResponse = dataBase.recover(snapshot[steps]);

		// UI handling
		uiHandler.refresh();
		uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_REDO, redostep), true);

		return redoResponse;
	}

	/**
	 * This method resets the view
	 *
	 *
	 * @return Boolean
	 */
	public Boolean reset() {

		// UI handling
		uiHandler.refresh();
		uiHandler.sendMessage(ResponseMessage.MESSAGE_SUCCESS_REFRESH, true);

		return true;
	}

	/**
	 * This method save all the tasks to a new file path
	 * 
	 * @param path
	 *            new path to save the tasks
	 * @return Boolean return true if the path successfully set
	 */
	public boolean setNewFile(String path) {
		boolean success = dataBase.setNewFile(path);

		// UI handling
		if (success) {
			uiHandler.refresh();
			uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_MOVE_DIR, path), true);
		} else {
			uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_FAILURE_MOVE_DIR, path), true);
		}

		return success;
	}

	/**
	 * This method opens a file from a given new file path
	 * 
	 * @param path
	 *            new path to create a new file to store the task
	 * @return Boolean return true if the a new file is successfully created in
	 *         the new path
	 */
	public Boolean openNewFile(String path) {
		boolean success = dataBase.openNewFile(path);

		// UI handling
		if (success) {
			uiHandler.refresh();
			uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_SUCCESS_OPEN_DIR, path), true);
		} else {
			uiHandler.sendMessage(String.format(ResponseMessage.MESSAGE_FAILURE_OPEN_DIR, path), true);
		}

		return success;
	}

	/**
	 * This method call UIHandler to change tab
	 * 
	 * @param workplace
	 *            workplace in UI
	 */
	public void tab(String workplace) {
		switch (workplace) {
		case "all":
			uiHandler.tab(1);
			break;
		case "expired":
			uiHandler.tab(2);
			break;
		case "today":
			uiHandler.tab(3);
			break;
		case "week":
			uiHandler.tab(4);
			break;
		case "done":
			uiHandler.tab(5);
			break;
		case "options":
			uiHandler.tab(6);
			break;
		case "help":
			uiHandler.tab(7);
			break;
		}
	}

	/**
	 * This method call UIHandler to display a message when flexi command cannot
	 * be parsed
	 * 
	 * @param keyword
	 *            the key
	 * @return Boolean return true if the message is successfully sent
	 */
	public Boolean invalid(String keyword) {
		uiHandler.sendMessage("Sorry but I don't understand! I will scold my makers for you.", true);
		return true;
	}

	/**
	 * This method clears all the tasks
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean clean() {
		this.dataBase.clear();
		uiHandler.refresh();
		uiHandler.sendMessage("View cleaned!", true);
		return true;
	}

	/**
	 * This method returns the current UIHandler
	 *
	 * 
	 * @return Boolean
	 */
	public UIHandler getUIHandler() {
		return uiHandler;
	}

	/**
	 * This method returns the current main app
	 *
	 * 
	 * @return mainApp return the current mainApp
	 */
	public MainApp getMainApp() {
		return mainApp;
	}

	/**
	 * This method sets the main app
	 * 
	 * @param mainApp
	 *            the MainApp to set
	 */
	public void setMainApp(MainApp mainApp) {
		this.mainApp = mainApp;
	}

	/**
	 * This method increases the internal step counter and takes a snapshot
	 * 
	 * @return Boolean return true if the step is successfully incremented and
	 *         the snapshot is taken
	 */
	public Boolean stepForward() {
		this.steps++;
		snapshot[steps] = dataBase.retrieveAll();
		return true;
	}

	/**
	 * This method returns the current step number
	 *
	 * 
	 * @return steps the current step number
	 */
	public int checkStep() {
		return this.steps;
	}

	/**
	 * This method returns the snapshot array
	 * 
	 * @return snapshot the snapshot of all the steps
	 */
	public ArrayList<Task>[] getSnapshot() {
		return this.snapshot;
	}

	/**
	 * This method process a fuzzy date
	 * 
	 * @param fuzzyDate
	 *            date to be parsed
	 * @return myDate the date after parsing
	 */
	private String fuzzyParseDate(String fuzzyDate) {
		String myDate = null;
		int count = fuzzyDate.length() - fuzzyDate.replace("-", "").length();
		if (count == 1) {
			myDate = LocalDateTime.now().getYear() + "-" + fuzzyDate;
		} else {
			if (count == 2) {
				myDate = fuzzyDate;
			}
		}
		return myDate;
	}

	/**
	 * This method process a fuzzy time
	 * 
	 * @param fuzzyTime
	 *            time to be parsed
	 * @return myTime time after parsing
	 */
	private LocalDateTime fuzzyParseTime(String fuzzyTime) {
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
		String myTime = null;

		if (fuzzyTime.contains("-")) {
			myTime = fuzzyParseDate(fuzzyTime) + " " + "00:00";
		} else {
			if (fuzzyTime.contains(":")) {
				myTime = getCurrentDate() + " " + fuzzyTime;
			}
		}
		return LocalDateTime.parse(myTime, formatter);
	}

	private String getCurrentDate() {
		DecimalFormat decimalFormatter = new DecimalFormat("00");
		return LocalDateTime.now().getYear() + "-" + decimalFormatter.format(LocalDateTime.now().getMonthValue()) + "-"
				+ decimalFormatter.format(LocalDateTime.now().getDayOfMonth());
	}

	private String getCurrentTimeStamp() {
		SimpleDateFormat sdfDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");// dd/MM/yyyy
		Date now = new Date();
		String strDate = sdfDate.format(now);
		return strDate;
	}

	private TemporalUnit generateTimeUnit(String unit) {
		switch (unit) {
		case "day":
			return ChronoUnit.DAYS;
		case "hour":
			return ChronoUnit.HOURS;
		case "minute":
			return ChronoUnit.MINUTES;
		case "week":
			return ChronoUnit.WEEKS;
		case "month":
			return ChronoUnit.MONTHS;
		case "year":
			return ChronoUnit.YEARS;
		default:
			return null;
		}
	}

	/**
	 * This method truncates the tile of a task
	 * 
	 * @param title
	 *            tile to be truncated
	 * @return title title after truncation
	 */
	private String truncateTitle(String title) {
		if (title.length() > TITLE_CAP_SIZE) {
			title = TITLE_TRUNCATION + title.substring(title.length() - TITLE_CAP_SIZE);
		}

		return title;
	}

	/**
	 * This method is to truncate the title
	 * 
	 * @param title
	 *            array of string to be truncated
	 * @return title string of title after truncation
	 */
	private String truncateTitle(String[] title) {
		String titleString = "";
		for (String section : title) {
			titleString += section + " ";
		}

		titleString = titleString.trim();
		if (titleString.length() > TITLE_CAP_SIZE) {
			titleString = TITLE_TRUNCATION + titleString.substring(titleString.length() - TITLE_CAP_SIZE);
		}

		return titleString;
	}
}
```
###### /todolist/logic/MainAppStub.java
``` java
package todolist.logic;

import java.util.ArrayList;

import todolist.MainApp;
import todolist.model.Task;

public class MainAppStub extends MainApp {
	public MainAppStub() {
		super();
	}

	@Override
	public void setDisplayTasks(ArrayList<Task> listOfTasks) {

	}

	@Override
	public void notifyWithText(String message, boolean isAutohide) {

	}
}
```
###### /todolist/logic/ResponseMessage.java
``` java
package todolist.logic;

public final class ResponseMessage {
	protected static final String MESSAGE_FAILURE_OPEN_DIR = "I encountered a problem importing your new schedule. Sorry!";
	protected static final String MESSAGE_SUCCESS_OPEN_DIR = "A new schedule has been imported.";
	protected static final String MESSAGE_FAILURE_MOVE_DIR = "I encountered a problem migrating your schedule. Sorry!";
	protected static final String MESSAGE_SUCCESS_MOVE_DIR = "Schedule has been saved to %1$s";
	protected static final String MESSAGE_SUCCESS_REFRESH = "View refreshed. All searches and filters are cleared!";
	protected static final String MESSAGE_SUCCESS_REDO = "You have reverted the last %d called-back action(s).";
	protected static final String MESSAGE_SUCCESS_UNDO = "You have called back the last %d action(s).";
	protected static final String MESSAGE_SUCCESS_UNARCHIVE = "[%1$s] has been unarchived! (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_ARCHIVE = "[%1$s] has been archived! (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_REMIND = "[%1$s] is set to trigger a reminder on %2$s. (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_REMOVE_REMIND = "[%1$s]'s reminder is removed. (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_FORWARD = "[%1$s] has been brought forward! (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_POSTPONE = "[%1$s] has been postponed! (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_NON_RECURRING = "[%1$s] is now a one-time-off task. (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_RECURRING = "[%1$s] is now a recurring task. (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_LABEL = "You have tagged [%1$s] as '%2$s'! (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_SORT = "Your tasks are now sorted by '%1$s'. (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_FILTER = "Here are the related tasks under: '%1$s'. (to clear a filter, type 'reset')";
	protected static final String MESSAGE_SUCCESS_SEARCH = "Here are your search results for: '%1$s'. (to clear a search, type 'reset')";
	protected static final String MESSAGE_SUCCESS_DELETE = "[%1$s] has been deleted! (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_EDIT = "[%1$s] has been edited! (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_ADD_DEADLINE = "A new deadline [%1$s] has been created! (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_ADD_EVENT = "A new event [%1$s] has been created! (not what you want? try 'undo 1')";
	protected static final String MESSAGE_SUCCESS_ADD_TASK = "A new task [%1$s] has been created! (not what you want? try 'undo 1')";

	protected static String MESSAGE_ADDING_FLOATING_TASK = "tring to add floating task: ";
	protected static String MESSAGE_ADDING_EVENT = "tring to add event: ";
	protected static String MESSAGE_ADDING_DEADLINE = "tring to add deadline: ";
	protected static String MESSAGE_ADDING_RECURRING_EVENT = "tring to add recurring event: ";
	protected static String MESSAGE_ADDING_RECURRING_DEADLINE = "tring to add reucrring deadline: ";
	protected static String MESSAGE_EDITING_TASK = "tring to edit task: ";
	protected static String MESSAGE_SEARCHING_TASK = "tring to search task: ";
	protected static String MESSAGE_SORTING_TASK = "tring to sort task: ";
	protected static String MESSAGE_DELETING_TASK = "tring to delete task: ";
}
```
###### /todolist/logic/UIHandler.java
``` java
package todolist.logic;

import java.util.ArrayList;

import todolist.MainApp;
import todolist.model.Task;
import todolist.storage.DataBase;

public class UIHandler {

	private DataBase dataBase;
	private MainApp mainApp;
	private Logic logic;

	public UIHandler(DataBase dataBase, MainApp mainApp, Logic logic) {
		this.dataBase = dataBase;
		this.mainApp = mainApp;
		this.logic = logic;
	}

	public void process(String input) {
		logic.process(input);
	}

	public String getPath() {
		return dataBase.getPath();
	}

	public void refresh() {
		mainApp.setDisplayTasks(dataBase.retrieveAll());
	}
	
	public ArrayList<Task> getAllTask() {
		return dataBase.retrieveAll();
	}

	protected void sendMessage(String message, boolean autohide) {
		mainApp.notifyWithText(message, autohide);
	}

	protected void highLight(Task task) {
		mainApp.highlightItem(task);
	}

	protected void display(ArrayList<Task> taskList) {
		mainApp.setDisplayTasks(taskList);
	}

	protected void tab(int index) {
		mainApp.loadPage(index);
	}
}
```
###### /todolist/model/Category.java
``` java
package todolist.model;

public class Category implements Comparable<Category> {
	private String category;

	public Category(String category) {
		this.category = category;
	}

	@Override
	public int compareTo(Category o) {
		return this.category.compareToIgnoreCase(o.getCategory());
	}

	public String getCategory() {
		return category;
	}
}
```
###### /todolist/model/ErrorBase.java
``` java
package todolist.model;

import java.util.HashMap;
import java.util.Map;

public class ErrorBase {

	protected static Map<String, String> errorBase = new HashMap<String, String>();

	public ErrorBase() {
		errorBase.put(("ADD" + "INCOMPLETE"), "Your command to ADD was incomplete! Please specify a TASK TYPE.");
		errorBase.put(("ADD EVENT" + "INCOMPLETE"),
				"Your command to ADD EVENT was incomplete! Try FLEXICOMMAND or check HELP for formats.");
		errorBase.put(("ADD DEADLINE" + "INCOMPLETE"),
				"Your command to ADD DEADLINE was incomplete! Try FLEXICOMMAND or check HELP for formats.");
		errorBase.put(("ADD TASK" + "INCOMPLETE"),
				"Your command to ADD TASK was incomplete! Try FLEXICOMMAND or check HELP for formats.");
		errorBase.put(("ADD RECURRING EVENT" + "INCOMPLETE"),
				"Your command to ADD RECURRING EVENT was incomplete! Try FLEXICOMMAND or check HELP for formats.");
		errorBase.put(("ADD RECURRING DEADLINE" + "INCOMPLETE"),
				"Your command to ADD RECURRING DEADLINE was incomplete! Try FLEXICOMMAND or check HELP for formats.");
		errorBase.put(("EDIT" + "INCOMPLETE"),
				"Your command to EDIT TASK was incomplete! Please check HELP for formats.");
		errorBase.put(("FILTER" + "INCOMPLETE"),
				"Your command to FILTER (CATEGORY) was incomplete! Please check HELP for formats.");
		errorBase.put(("SEARCH" + "INCOMPLETE"),
				"Your command to SEARCH (KEYWORD) was incomplete! Please check HELP for formats.");
		errorBase.put(("SET-RECURRING" + "INCOMPLETE"),
				"Your command to SET RECURRENCE was incomplete! Please check HELP for formats.");
		errorBase.put(("LABEL" + "INCOMPLETE"),
				"Your command to LABEL CATEGORY was incomplete! Please check HELP for formats.");
		errorBase.put(("REMOVE-RECURRING" + "INCOMPLETE"),
				"Your command to REMOVE RECURRENCE was incomplete! Please check HELP for formats.");
		errorBase.put(("POSTPONE" + "INCOMPLETE"),
				"Your command to POSTPONE TASK was incomplete! Please check HELP for formats.");
		errorBase.put(("FORWARD" + "INCOMPLETE"),
				"Your command to FORWARD TASK was incomplete! Please check HELP for formats.");
		errorBase.put(("REMIND" + "INCOMPLETE"),
				"Your command to SET REMINDER was incomplete! Please check HELP for formats.");
		errorBase.put(("REMIND-BEF" + "INCOMPLETE"),
				"Your command to SET ADVANCE REMINDER was incomplete! Please check HELP for formats.");
		errorBase.put(("DONE" + "INCOMPLETE"),
				"Your command to ARCHIVE was incomplete! Please check HELP for formats.");
		errorBase.put(("UNDONE" + "INCOMPLETE"),
				"Your command to UN-ARCHIVE was incomplete! Please check HELP for formats.");
		errorBase.put(("UNDO" + "INCOMPLETE"),
				"Your command to UNDO ACTION was incomplete! Please check HELP for formats.");
		errorBase.put(("REDO" + "INCOMPLETE"),
				"Your command to REVERT ACTION was incomplete! Please check HELP for formats.");
		errorBase.put(("TAB" + "INCOMPLETE"),
				"Your command to CHANGE TAB was incomplete! Please check HELP for formats.");
		errorBase.put(("ADD" + "REPEAT TITLE"), "You might have added this task before! Try a different TASK TITLE.");
		errorBase.put(("SORT" + "INCOMPLETE"), "Your command to SORT was incomplete! Please check HELP for formats.");
		errorBase.put(("ADD EVENT" + "INVALID TIME UNIT"),
				"You have specified a TIME UNIT that I don't understand! Try {minute, hour, day, week, month, year}.");
		errorBase.put(("ADD EVENT" + "INVALID QUANTITY"),
				"You have specified a TIME QUANTITY that I don't understand! Try using whole numbers instead.");
		errorBase.put(("ADD EVENT" + "INVALID START TIME"),
				"You have specified a START TIME that I don't understand! Please check HELP for formats.");
		errorBase.put(("ADD EVENT" + "INVALID START DATE"),
				"You have specified a START DATE that I don't understand! Please check HELP for formats.");
		errorBase.put(("ADD DEADLINE" + "INVALID END TIME"),
				"You have specified an invalid END TIME! ToDoList does not support time-travelling yet ...");
		errorBase.put(("ADD DEADLINE" + "INVLAID END DATE"),
				"You have specified an invalid END DATE! ToDoList does not support time-travelling yet ...");
		errorBase.put(("ADD RECURRING EVENT" + "INVALID INTERVAL"),
				"You have specified an invalid EVENT RECURRENCE INTERVAL! Please check HELP for formats.");
		errorBase.put(("ADD RECURRING DEADLINE" + "INVALID INTERVAL"),
				"You have specified an invalid DEADLINE RECURRENCE INTERVAL! Please check HELP for formats.");
		errorBase.put(("REMIND BEF" + "INVALID TIME UNIT"),
				"You have specified a TIME UNIT that I don't understand! Try {minute, hour, day, week, month, year}.");
		errorBase.put(("REMIND BEF" + "INVALID QUANTITY"),
				"You have specified a TIME QUANTITY that I don't understand! Try using whole numbers instead.");
		errorBase.put(("REMIND BEF" + "TASK NOT EXIST"),
				"The task that you want to set ADVANCE REMINDER for does not exist! Try another?");
		errorBase.put(("ADD REMIND" + "INVALID TYPE"),
				"You may only SET REMINDER for an EVENT or DEADLINE! Try creating an EVENT or DEADLINE instead!");
		errorBase.put(("REMIND" + "TASK NOT EXIST"),
				"The task that you want to set REMINDER for does not exist! Try another?");
		errorBase.put(("FORWARD" + "INVALID TIME UNIT"),
				"You have specified a TIME UNIT that I don't understand! Try {minute, hour, day, week, month, year}.");
		errorBase.put(("FORWARD" + "INVALID QUANTITY"),
				"You have specified a TIME QUANTITY that I don't understand! Try using whole numbers instead.");
		errorBase.put(("FORWARD" + "NOT EXIST"), "The task that you want to set FORWARD does not exist! Try another?");
		errorBase.put(("POSTPONE" + "INVALID TIME UNIT"),
				"You have specified a TIME UNIT that I don't understand! Try {minute, hour, day, week, month, year}.");
		errorBase.put(("POSTPONE" + "INVALID QUANTITY"),
				"You have specified a TIME QUANTITY that I don't understand! Try using whole numbers instead.");
		errorBase.put(("POSTPONE" + "NOT EXIST"),
				"The task that you want to set POSTPONE for does not exist! Try another?");
		errorBase.put(("REDO" + "NO ACTION TO REDO"), "There are no actions to REVERT!");
		errorBase.put(("REDO" + "STEP NOT POSITIVE"),
				"Uh-oh! I encountered some problems reverting your action. I will scold my makers for you.");
		errorBase.put(("REDO" + "AUGUMENT NOT INTEGER"),
				"You may only specify a whole number following the REDO command! Please refer to HELP for formats.");
		errorBase.put(("UNDO" + "NO ACTION TO UNDO"), "There are no actions to UNDO!");
		errorBase.put(("UNDO" + "STEP NOT POSITIVE"),
				"Uh-oh! I encountered some problems undoing your action. I will scold my developers for you.");
		errorBase.put(("UNDO" + "AUGUMENT NOT INTEGER"),
				"You may only specify a whole number following the UNDO command! Please refer to HELP for formats.");
		errorBase.put(("UNDONE" + "NOT EXIST"), "The task that you want to UNARCHIVE does not exist! Try another?");
		errorBase.put(("DONE" + "NOT EXIST"), "The task that you want to ARCHIVE does not exist! Try another?");
		errorBase.put(("TAB" + "WORDPLACE NOT EXIST"), "The TAB you are looking for does not exist! Try another?");
		errorBase.put(("SET RECURRING" + "INVALID INTERVAL"),
				"You have specified a TIME INTERVAL that I don't understand! Try [WHOLE NUMBER]-[TIME UNIT]. ");
		errorBase.put(("SET RECURRING" + "TASK NOT EXIST"),
				"The task that you want to SET RECURRENCE for does not exist! Try another?");
		errorBase.put(("REMOVE RECURRING" + "INVALID INTERVAL"),
				"You have specified a TIME INTERVAL that I don't understand! Try [WHOLE NUMBER]-[TIME UNIT]. ");
		errorBase.put(("REMOVE RECURRING" + "TASK NOT EXIST"),
				"The task that you want to REMOVE RECURRENCE from does not exist! Try another?");
		errorBase.put(("LABEL" + "TASK NOT EXIST"),
				"The task that you want to LABEL CATEGORY does not exist! Try another?");
		errorBase.put(("EDIT" + "FIELD NOT EXIST"),
				"The FIELD that you want to EDIT for this task does not exist! Please refer to HELP for formats.");
		errorBase.put(("EDIT" + "TASK NOT EXIST"), "The TASK that you want to EDIT does not exist! Try another?");
		errorBase.put(("DELETE" + "TASK NOT EXIST"), "The TASK that you want to DELETE does not exist! Try another?");
		errorBase.put(("ADD REMIND" + "INVALID TYPE"),
				"You may only SET REMINDER for an EVENT or DEADLINE! Try creating an EVENT or DEADLINE instead!");
		errorBase.put(("ADD REMIND BEF" + "INVALID TYPE"),
				"You may only SET ADVANCE REMINDER for an EVENT or DEADLINE! Try creating an EVENT or DEADLINE instead!");
		errorBase.put(("ADD REMIND BEF" + "INVALID TIME UNIT"),
				"You have specified a TIME UNIT that I don't understand! Try {minute, hour, day, week, month, year}.");
		errorBase.put(("ADD REMIND BEF" + "INVALID QUANTITY"),
				"You have specified a TIME QUANTITY that I don't understand! Try using whole numbers instead.");
		errorBase.put(("REMIND" + "FLOATING TASK"),
				"You may only SET REMINDER for an EVENT or DEADLINE! Try picking an EVENT or DEADLINE instead!");
		errorBase.put(("REMOVE REMIND" + "NOT EXIST"),
				"The task that you want to remove reminder does not exist! Try another?");
		errorBase.put(("FORWARD" + "FLOATING TASK"),
				"You may only FORWARD an EVENT or DEADLINE! Try picking an EVENT or DEADLINE instead!");
		errorBase.put(("POSTPONE" + "FLOATING TASK"),
				"You may only POSTPONE an EVENT or DEADLINE! Try picking an EVENT or DEADLINE instead!");
		errorBase.put(("REMIND BEF" + "FLOATING TASK"),
				"You may only SET REMINDER for an EVENT or DEADLINE! Try picking an EVENT or DEADLINE instead!");
		errorBase.put(("SET RECURRING" + "FLOATING TASK"),
				"You may only SET RECURRENCE for an EVENT or DEADLINE! Try picking an EVENT or DEADLINE instead!");
		errorBase.put(("PARSER" + "INVALID INPUT"),
				"Sorry! I don't understand this command! Please refer to HELP for formats.");
	}

	protected String getErrorMessage(String commandType, String errorType) {
		return errorBase.get((commandType + errorType));
	}
}
```
###### /todolist/model/InputException.java
``` java
package todolist.model;

public class InputException {
	String commandType = null;
	String errorType = null;
	Boolean error = true;
	
	public InputException() {
		this.error = true;
	}
	
	public InputException(String commandType, String errorType) {
		this.commandType = commandType;
		this.errorType = errorType;
		this.error = false;
	}
	
	public String getCommandType() {
		return commandType;
	}
	
	public String getErrorType() {
		return errorType;
	}
	
	public String getErrorMessage() {
		return new ErrorBase().getErrorMessage(commandType, errorType);
	}
	
	public Boolean getCorrectness() {
		return this.error;
	}
}
```
###### /todolist/model/Name.java
``` java
package todolist.model;

public class Name implements Comparable<Name> {

	private String name;

	public Name(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public int compareTo(Name o) {
		return this.name.compareToIgnoreCase(o.getName());
	}
}
```
###### /todolist/model/Reminder.java
``` java
package todolist.model;

import java.time.LocalDateTime;

public class Reminder {
    
    private Boolean switcher = null;
    private LocalDateTime time = null;
    
    public Reminder(Boolean switcher, LocalDateTime time) {
        this.switcher = switcher;
        this.time = time;
    }
        
    public Boolean getStatus() {
        return switcher;
    }
    
    public LocalDateTime getTime() {
        return time;
    }
}
```
###### /todolist/model/SearchCommand.java
``` java
package todolist.model;

public class SearchCommand {
	private String type = null;
	private String content = null;
	
	public SearchCommand(String type, String content) {
		this.type = type;
		this.content = content;
	}

    public String getType() {
    	return type;
    }
    
    public String getContent() {
    	return content;
    }

}
```
###### /todolist/model/Task.java
``` java
package todolist.model;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalUnit;

public class Task {
	private Name name = null;
	private LocalDateTime startTime = null;
	private LocalDateTime endTime = null;
	private Category category = null;
	private Reminder reminder = null;
	private Boolean isDone = null;
	private Boolean isRecurring = null;
	private String interval = null;

	public Task(Name name, LocalDateTime startTime, LocalDateTime endTime, Category category, Reminder reminder,
			Boolean isDone, Boolean recurring, String interval) {
		this.name = name;
		this.startTime = startTime;
		this.endTime = endTime;
		this.category = category;
		this.reminder = reminder;
		this.isDone = isDone;
		this.isRecurring = recurring;
		this.interval = interval;
	}

	public void setName(Name name) {
		this.name = name;
	}

	public void setStartTime(LocalDateTime startTime) {
		this.startTime = startTime;
	}

	public void setEndTime(LocalDateTime endTime) {
		this.endTime = endTime;
	}

	public void setCategory(Category category) {
		this.category = category;
	}

	public void setReminder(Reminder reminder) {
		this.reminder = reminder;
	}

	public void setDoneStatus(Boolean isDone) {
		this.isDone = isDone;
	}

	public void setRecurring(Boolean isRecurring) {
		this.isRecurring = isRecurring;
	}

	public void setInterval(String interval) {
		this.interval = interval;
	}

	public Name getName() {
		return name;
	}

	public LocalDateTime getStartTime() {
		return startTime;
	}

	public LocalDateTime getEndTime() {
		return endTime;
	}

	public Category getCategory() {
		return category;
	}

	public Reminder getReminder() {
		return reminder;
	}

	public Boolean getDoneStatus() {
		return isDone;
	}

	public Boolean getRecurringStatus() {
		return isRecurring;
	}

	public String getInterval() {
		return interval;
	}

	@SuppressWarnings("unused")
	private TemporalUnit generateTimeUnit(String unit) {
		switch (unit) {
		case "day":
			return ChronoUnit.DAYS;
		case "hour":
			return ChronoUnit.HOURS;
		case "minute":
			return ChronoUnit.MINUTES;
		case "week":
			return ChronoUnit.WEEKS;
		case "month":
			return ChronoUnit.MONTHS;
		case "year":
			return ChronoUnit.YEARS;
		default:
			return null;
		}
	}
}
```
###### /todolist/model/TokenizedCommand.java
``` java
package todolist.model;

public class TokenizedCommand {

	private String action = null;
	private String args[];

	public TokenizedCommand(String action, String[] args) {
		this.action = action;
		this.args = args;
	}

	public String getAction() {
		return action;
	}

	public String[] getArgs() {
		return args;
	}
}
```
###### /todolist/parser/FlexiCommandParser.java
``` java
package todolist.parser;

import java.text.DecimalFormat;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.List;
import java.util.TimeZone;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

import todolist.model.TokenizedCommand;

public class FlexiCommandParser {

	public FlexiCommandParser() {

	}

	/**
	 * This method takes in flexible input and parse it then translates it into
	 * tokenized command
	 *
	 * @param input
	 *            raw user input
	 * @return tokenized add command
	 */
	public TokenizedCommand parse(String input) {

		input = input.replaceAll("\"", "");
		input = input.trim();
		String temp[] = input.split(" ");

		if (input.equals("")) {
			return new TokenizedCommand("invalid", temp);
		}

		Parser parser = new Parser(TimeZone.getTimeZone(ZoneOffset.systemDefault()));
		List<DateGroup> groups = parser.parse(input);
		List<Date> dates = null;

		int[] column = new int[] { 0, 0 };
		int[] length = new int[] { 0, 0 };
		int counter = 0;

		for (DateGroup group : groups) {
			dates = group.getDates();
			column[counter] = group.getPosition();
			length[counter] = group.getText().length();
			counter++;
		}

		String result = null;

		if (dates == null || dates.size() == 0) {
			return addTask(input);
		} else {

			result = removeTimeInfo(input, column, length);

			if (dates.size() == 1) {
				return addDeadline(input, result, dates);
			} else if (dates.size() == 2){
				return addEvent(result, dates);
			} else {
				return addTask(input);
			}
		}
	}

	private TokenizedCommand addTask(String input) {
		if (input.equals("")) {
			return new TokenizedCommand("invalid", null);
		}
		return new TokenizedCommand("add", new String[] { "task", input });
	}

	private TokenizedCommand addDeadline(String original, String input, List<Date> dates) {
		String result = input;

		Date deadline = dates.get(0);

		Instant instant = Instant.ofEpochMilli(deadline.getTime());
		LocalDateTime end = LocalDateTime.ofInstant(instant, ZoneOffset.systemDefault());

		DecimalFormat decimalFormatter = new DecimalFormat("00");
		String deadlineDate = end.getYear() + "-" + decimalFormatter.format(end.getMonthValue()) + "-"
				+ decimalFormatter.format(end.getDayOfMonth());

		String deadlineTime = decimalFormatter.format(end.getHour()) + ":" + decimalFormatter.format(end.getMinute());

		deadlineTime = searchKeywordToday(original, end, deadlineTime);

		result = keywordFilter(result);

		deadlineTime = searchKeywordTime(result, deadlineTime);

		if (result.equals("")) {
			return new TokenizedCommand("invalid", null);
		}

		return new TokenizedCommand("add", new String[] { "deadline", result, deadlineDate, deadlineTime });
	}

	private TokenizedCommand addEvent(String input, List<Date> dates) {
		String result = input;

		DecimalFormat decimalFormatter = new DecimalFormat("00");

		Date startTimeOriginal = dates.get(0);
		Date endTimeOriginal = dates.get(1);

		Instant startInstant = Instant.ofEpochMilli(startTimeOriginal.getTime());
		LocalDateTime start = LocalDateTime.ofInstant(startInstant, ZoneId.systemDefault());

		String startDate = start.getYear() + "-" + decimalFormatter.format(start.getMonthValue()) + "-"
				+ decimalFormatter.format(start.getDayOfMonth());

		String startTime = decimalFormatter.format(start.getHour()) + ":" + decimalFormatter.format(start.getMinute());

		int interval = (int) getDateDiff(startTimeOriginal, endTimeOriginal) / 1000 / 60;

		result = keywordFilter(result);

		if (result.equals("")) {
			return new TokenizedCommand("invalid", null);
		}

		return new TokenizedCommand("add",
				new String[] { "event", result, startDate, startTime, Integer.toString(interval), "minute" });
	}

	private String removeTimeInfo(String input, int[] column, int[] length) {
		String result = input;
		if (column[1] == 0) {
			result = input.substring(0, column[0] - 1) + input.substring(column[0] + length[0] - 1);
		} else {
			result = input.substring(0, column[0] - 1) + input.substring(column[0] + length[0], column[1] - 1)
					+ input.substring(column[1] + length[1] - 1);
		}
		return result;
	}

	private String searchKeywordToday(String input, LocalDateTime end, String originalDeadline) {
		String deadlineTime = originalDeadline;
		if (end.isBefore(LocalDateTime.now().plus(10, ChronoUnit.SECONDS))
				&& end.plus(10, ChronoUnit.SECONDS).isAfter(LocalDateTime.now())
				&& input.toLowerCase().contains("today")) {
			deadlineTime = "23:59";
		}
		return deadlineTime;
	}

	private String searchKeywordTime(String input, String originalDeadline) {
		String deadlineTime = originalDeadline;

		if (input.toLowerCase().contains("breakfast")) {
			deadlineTime = "09:00";
		}

		if (input.toLowerCase().contains("lunch")) {
			deadlineTime = "13:00";
		}

		if (input.toLowerCase().contains("dinner")) {
			deadlineTime = "19:00";
		}
		if (input.toLowerCase().contains("supper")) {
			deadlineTime = "23:00";
		}

		return deadlineTime;
	}

	private String keywordFilter(String input) {
		String result = input;
		if (result.endsWith(" by ")) {
			result = result.substring(0, result.length() - 3);
		}

		if (result.endsWith(" from ")) {
			result = result.substring(0, result.length() - 5);
		}

		if (result.startsWith("From ") || result.startsWith("from ")) {
			result = result.substring(6);
		}

		return result.trim();
	}

	private long getDateDiff(Date date1, Date date2) {
		long diffInMillies = date2.getTime() - date1.getTime();
		return diffInMillies;
	}
}
```
###### /todolist/parser/MainParser.java
``` java
package todolist.parser;

import todolist.model.TokenizedCommand;

public class MainParser {

	private FlexiCommandParser flexiCommandParser;
	private NormalCommandParser normalCommandParser;

	public MainParser() {
		this.flexiCommandParser = new FlexiCommandParser();
		this.normalCommandParser = new NormalCommandParser();
	}

	/**
	 * This method takes in a string and parse it.
	 *
	 * @param input
	 *            raw user input
	 * 
	 * @return tokenized command
	 */
	public TokenizedCommand parse(String input) {
		if (checkType(input)) {
			return normalCommandParser.parse(input);
		} else {
			return flexiCommandParser.parse(input);
		}
	}

	/**
	 * This method takes in a string and check whether it is a flexible command.
	 *
	 * @param input
	 *            raw user input
	 * 
	 * @return Boolean
	 */
	private Boolean checkType(String input) {
		String temp[] = input.split(" ");
		String head = temp[0];
		Boolean type = head.equals("add") || head.equals("edit") || head.equals("delete") || head.equals("search")
				|| head.equals("filter") || head.equals("sort") || head.equals("label") || head.equals("postpone")
				|| head.equals("forward") || head.equals("add-remind") || head.equals("remind")
				|| head.equals("add-remind-bef") || head.equals("remind-bef") || head.equals("remove-remind")
				|| head.equals("done") || head.equals("undone") || head.equals("exit") || head.equals("undo")
				|| head.equals("redo") || head.equals("reset") || head.equals("tab") || head.equals("set-recurring")
				|| head.equals("remove-recurring") || head.equals("create") || head.equals("schedule")
				|| head.equals("cancel") || head.equals("remove") || head.equals("modify") || head.equals("change")
				|| head.equals("replace") || head.equals("archive") || head.equals("complete") || head.equals("finish")
				|| head.equals("shelf") || head.equals("unarchive") || head.equals("incomplete")
				|| head.equals("unfinish") || head.equals("unshelf") || head.equals("delay") || head.equals("advance")
				|| head.equals("categorize") || head.equals("tag") || head.equals("load") || head.equals("open")
				|| head.equals("save") || head.equals("help") || head.equals("clean");
		return type;
	}
}
```
###### /todolist/parser/NormalCommandParser.java
``` java
package todolist.parser;

import java.util.ArrayList;

import todolist.model.TokenizedCommand;

public class NormalCommandParser {

	public NormalCommandParser() {

	}

	/**
	 * This method takes in normal input and parse it into tokenized command
	 *
	 * @param input
	 *            raw user input
	 * @return tokenized command
	 */
	public TokenizedCommand parse(String input) {

		String temp[] = input.split(" ");
		String action = temp[0];

		ArrayList<String> myList = new ArrayList<String>();

		String name = null;
		Boolean generateName = false;
		for (int i = 0; i < temp.length - 1; i++) {

			if (generateName == true) {
				if (temp[i + 1].contains("\"")) {
					name = name + " " + temp[i + 1].replace("\"", "");
					generateName = false;
					myList.add(name);
					name = null;

				} else {
					name = name + " " + temp[i + 1];
				}
			} else {
				if (temp[i + 1].contains("\"")) {
					name = temp[i + 1].replace("\"", "");
					generateName = true;
					int count = temp[i + 1].length() - temp[i + 1].replace("\"", "").length();
					if (count == 2) {
						generateName = false;
						myList.add(name);
						name = null;
					}
				} else {
					myList.add(temp[i + 1]);
				}
			}
		}

		String[] args = myList.toArray(new String[0]);

		return new TokenizedCommand(convert(action), args);
	}

	private String convert(String input) {
		if (input.equals("add") || input.equals("schedule") || input.equals("create")) {
			return "add";
		}
		if (input.equals("delete") || input.equals("cancel") || input.equals("remove")) {
			return "delete";
		}
		if (input.equals("edit") || input.equals("modify") || input.equals("change") || input.equals("replace")) {
			return "edit";
		}
		if (input.equals("archive") || input.equals("done") || input.equals("complete") || input.equals("shelf")
				|| input.equals("finish")) {
			return "done";
		}
		if (input.equals("unarchive") || input.equals("undone") || input.equals("incomplete") || input.equals("unshelf")
				|| input.equals("unfinish")) {
			return "undone";
		}
		if (input.equals("postpone") || input.equals("delay")) {
			return "postpone";
		}
		if (input.equals("forward") || input.equals("advance")) {
			return "forward";
		}
		if (input.equals("label") || input.equals("categorize") || input.equals("tag")) {
			return "label";
		}
		if (input.equals("open") || input.equals("load")) {
			return "open";
		}
		return input;
	}
}
```
###### /todolist/ui/controllers/MainViewController.java
``` java
    // Temporary attributes for testing
    public String path = "demo.txt";
    public int demoCounter = 0;

```
###### /todolist/ui/controllers/MainViewController.java
``` java
    /*** Temporary Functions for Testing ***/

    /**
     * demoFileHandler is used in demo to manipulate demo data and files.
     * 
     * @param path
     * @return ArrayList<String>
     */
    public ArrayList<String> demoFileHandler(String path) {
        ArrayList<String> myList = new ArrayList<String>();
        try {

            File file = new File(path);
            Scanner scr = new Scanner(file);
            while (scr.hasNextLine()) {
                String temp = scr.nextLine();
                myList.add(temp);
                System.out.println(temp);
            }
            scr.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return myList;
    }

    Boolean isDemoing = false;

    /**
     * setCommandLineCallbackDemo sets the command callback for demonstration.
     * 
     * @param commandField
     */
    public void setCommandLineCallbackDemo(TextField commandField) {
        // Set Callback for TextField

        EventHandler<ActionEvent> commandHandler = new EventHandler<ActionEvent>() {

            @Override
            public void handle(ActionEvent event) {
                if (!isDemoing) {
                    String commandString = commandField.getText();
                    // Command command = new Command(commandString);
                    // System.out.println(command.getCommand());

                    // Pass command line input for processing
                    try {

                        commandField.clear();
                        logger.logAction(Component.UI, MESSAGE_CLEAR_TEXTFIELD);
                        if (commandString.equals("Start demo")) {
                            isDemoing = true;
                        } else {
                            getUiHandler().process(commandString);
                            logger.logComponentCall(Component.UI, MESSAGE_CALL_LOGIC_COMPONENT);
                        }
                    } catch (Exception exception) {
                        logger.logError(Component.UI, ERROR_PROCESSING_USER_INPUT);
                        exception.printStackTrace();
                    }
                } else {
                    synchronized (this) {
                        ArrayList<String> demoList = demoFileHandler(path);
                        String commandString = demoList.get(demoCounter);
                        demoCounter++;
                        if (commandString.equals("exit")) {
                            isDemoing = false;
                        } else {
                            // System.out.println(event.getEventType());

                            // Pass command line input for processing
                            commandField.clear();

                            final Animation animation = new Transition() {
                                {
                                    setCycleDuration(new Duration(commandString.length() * 50));
                                }

                                protected void interpolate(double frac) {
                                    final int length = commandString.length();
                                    final int n = Math.round(length * (float) frac);
                                    commandField.setText(commandString.substring(0, n));
                                }

                            };

                            animation.setOnFinished(new EventHandler<ActionEvent>() {
                                @Override
                                public void handle(ActionEvent event) {
                                    getUiHandler().process(commandString);
                                }
                            });

                            animation.play();
                        }
                    }
                }
            }
        };

        commandField.setOnAction(commandHandler);
    }

```
