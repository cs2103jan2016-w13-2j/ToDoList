# A0123994W
###### /todolist/common/tests/UIHandlerTest.java
``` java

public class UIHandlerTest {

}
```
###### /todolist/common/UtilityLogger.java
``` java

/*
 * UtilityLogger is a common logger to log all ToDoList activities at runtime.
 * 
 * @author Huang Lie Jun (A0123994W)
 */
public class UtilityLogger {

    // Logger constants
    private static final int MAX_LOG_SIZE = 1048576;
    private static final int NUMBER_OF_LOGS = 1;
    private static final boolean IS_APPEND = false;

    // Log variants
    private static final String ACTION = "ACTION >> ";
    private static final String ERROR = "ERROR >> ";
    private static final String EXCEPTION = "EXCEPTION >> ";
    private static final String COMPONENTCALL = "COMPONENT CALL >> ";

    // Log components
    private static final String UI = "UI";
    private static final String LOGIC = "LOGIC";
    private static final String PARSER = "PARSER";
    private static final String STORAGE = "STORAGE";
    private static final String UNKNOWN = "UNKNOWN";
    private static final String LOGGER_NAME = "ToDoList-Logger";
    private static final String ERROR_CREATE_LOG = "Error accessing log file.";
    private static final String ERROR_GET_DEFAULT_PATH = "Error obtaining default application directory for file path.";

    // Log file handler
    private static File logDirectory = null;
    private Logger logger = null;
    private static FileHandler fileHandler = null;

    // Component types
    public static enum Component {
        UI, Logic, Parser, Storage
    };

    /*** Constructors ***/

    /*
     * Constructor with filepath. This constructor takes in a file path, checks
     * its validity and sets the path as the destination path for the log file.
     * 
     * @param String logDir The directory at which the log file will be read or
     * written to.
     */
    public UtilityLogger(String logDir) {
        // Instantiate a singleton logger if not already created
        logger = Logger.getLogger(LOGGER_NAME);

        try {

            // Check validity of directory and set directory accordingly
            if (isValidPath(logDir)) {
                logDirectory = new File(logDir);
            } else {
                logDirectory = getDefaultPath();
            }

            fileHandler = new FileHandler(logDirectory.getPath(), MAX_LOG_SIZE, NUMBER_OF_LOGS, IS_APPEND);
            logger.addHandler(fileHandler);
            SimpleFormatter formatter = new SimpleFormatter();
            fileHandler.setFormatter(formatter);
        } catch (SecurityException | IOException exception) {
            handleConstructionError(exception);
        }
    }

    /*
     * Constructor without filepath. This constructor uses the application
     * default root directory as the destination path for the log file.
     */
    public UtilityLogger() {
        // Instantiate a singleton logger if not already created
        logger = Logger.getLogger(LOGGER_NAME);

        // Set default directory as destination path for log file
        logDirectory = getDefaultPath();

        try {
            if (fileHandler == null) {
                fileHandler = new FileHandler(logDirectory.getPath(), MAX_LOG_SIZE, NUMBER_OF_LOGS, IS_APPEND);
            }
            logger.addHandler(fileHandler);
            SimpleFormatter formatter = new SimpleFormatter();
            fileHandler.setFormatter(formatter);
        } catch (SecurityException | IOException exception) {
            handleConstructionError(exception);
        }
    }

    /*** Utility Functions ***/

    /*
     * getDefaultPath checks and returns the file path that the application is
     * currently running from.
     * 
     * @return String defaultPath
     */
    private File getDefaultPath() {
        File file = null;
        CodeSource codeSource = null;
        File applicationFile = null;

        try {
            codeSource = UtilityLogger.class.getProtectionDomain().getCodeSource();
            applicationFile = new File(codeSource.getLocation().toURI().getPath());
            file = new File(applicationFile.getParent() + ".log");
        } catch (URISyntaxException exception) {
            handleDefaultPathError(exception);
        }

        // System.out.println(applicationFile.getParent());

        return file;
    }

    /*
     * isValidPath checks for validity of the file path in accordance to OS
     * rules.
     * 
     * @param String logDir is the candidate directory for the log file to be
     * read from or written to.
     */
    private boolean isValidPath(String logDir) {
        File file = new File(logDir);
        try {
            file.getCanonicalPath();
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    /*** Access Functions ***/

    /*
     * getLogDirectory returns the current file path of the log file.
     * 
     * @return String logFilePath
     */
    public static String getLogDirectory() {
        return logDirectory.getPath();
    }

    /*
     * setLogDirectory sets the current file path of the log file.
     * 
     * @param String logDirectory is the candidate file path of the log file.
     */
    public static void setLogDirectory(String logDirectory) {
        UtilityLogger.logDirectory = new File(logDirectory);
    }

    /*
     * getLogger returns the current common utility loggger used in this
     * application.
     * 
     * @return Logger logger
     */
    public Logger getLogger() {
        return logger;
    }

    /*
     * setLogger sets the current common utility logger used in this
     * application.
     * 
     * @param Logger logger is the candidate logger to substitute the current
     * utility logger
     */
    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    /*** Error Handling Functions ***/

    /*
     * handleConstructionError handles failure to construct this utility logger
     * by displaying error message and trace.
     * 
     * @param Exception exception is the exception caught
     */
    private void handleConstructionError(Exception exception) {
        System.err.println(ERROR_CREATE_LOG);
        exception.printStackTrace();
    }

    /*
     * handleDefaultPathError handles failure to obtain the file path of the
     * application by displaying error message and trace.
     * 
     * @param URISyntaxException exception is the exception caught
     */
    private void handleDefaultPathError(URISyntaxException exception) {
        System.err.println(ERROR_GET_DEFAULT_PATH);
        exception.printStackTrace();
    }

    /*** Logging API ***/

    /*
     * logAction logs an action performed by a function or by the user.
     * 
     * @param Component {UI, Logic, Parser, Storage}, String message
     * 
     */
    public void logAction(Component level, String message) {
        switch (level) {
        case UI:
            logInfo(UI + "-" + ACTION + message);
            break;
        case Logic:
            logInfo(LOGIC + "-" + ACTION + message);
            break;
        case Parser:
            logInfo(PARSER + "-" + ACTION + message);
            break;
        case Storage:
            logInfo(STORAGE + "-" + ACTION + message);
            break;
        default:
            logInfo(UNKNOWN + "-" + ACTION + message);
        }
    }

    /*
     * logError logs an error encountered by a function.
     * 
     * @param Component {UI, Logic, Parser, Storage}, String message
     * 
     */
    public void logError(Component level, String message) {
        switch (level) {
        case UI:
            logInfo(UI + "-" + ERROR + message);
            break;
        case Logic:
            logInfo(LOGIC + "-" + ERROR + message);
            break;
        case Parser:
            logInfo(PARSER + "-" + ERROR + message);
            break;
        case Storage:
            logInfo(STORAGE + "-" + ERROR + message);
            break;
        default:
            logInfo(UNKNOWN + "-" + ERROR + message);
        }
    }

    /*
     * logException logs an exception caught by a function.
     * 
     * @param Component {UI, Logic, Parser, Storage}, String message
     * 
     */
    public void logException(Component level, String message) {
        switch (level) {
        case UI:
            logInfo(UI + "-" + EXCEPTION + message);
            break;
        case Logic:
            logInfo(LOGIC + "-" + EXCEPTION + message);
            break;
        case Parser:
            logInfo(PARSER + "-" + EXCEPTION + message);
            break;
        case Storage:
            logInfo(STORAGE + "-" + EXCEPTION + message);
            break;
        default:
            logInfo(UNKNOWN + "-" + EXCEPTION + message);
        }
    }

    /*
     * logComponentCall logs an inter-component function call.
     * 
     * @param Component {UI, Logic, Parser, Storage}, String message
     * 
     */
    public void logComponentCall(Component level, String message) {
        switch (level) {
        case UI:
            logInfo(UI + "-" + COMPONENTCALL + message);
            break;
        case Logic:
            logInfo(LOGIC + "-" + COMPONENTCALL + message);
            break;
        case Parser:
            logInfo(PARSER + "-" + COMPONENTCALL + message);
            break;
        case Storage:
            logInfo(STORAGE + "-" + COMPONENTCALL + message);
            break;
        default:
            logInfo(UNKNOWN + "-" + COMPONENTCALL + message);
        }
    }

    /*
     * logInfo logs a message (pre-formatted) into the log file.
     * 
     * @param String message
     * 
     */
    private void logInfo(String message) {
        logger.info(message);
    }

    // public static void main(String[] args) {
    // UtilityLogger logger = new UtilityLogger();
    // logger.logAction(Component.UI, "HELLO WORLD");
    //
    // UtilityLogger logger2 = new UtilityLogger();
    // logger2.logAction(Component.UI, "HELLO WORLD");
    //
    // UtilityLogger logger3 = new UtilityLogger();
    // logger3.logAction(Component.UI, "HELLO WORLD");
    // }
}
```
###### /todolist/MainApp.java
``` java

/*
 * MainApp is the main running class for the application.
 * It provides the user with the graphical user interface to control the application.
 * 
 * @author Huang Lie Jun (A0123994W)
 * 
 */
public class MainApp extends Application {

    private static final String PLACEHOLDER_SETTINGS = "ui/views/SettingsPlaceHolder.fxml";
    private static final String PLACEHOLDER_ARCHIVE = "ui/views/ArchivePlaceHolder.fxml";
    private static final String PLACEHOLDER_WEEK = "ui/views/WeekPlaceHolder.fxml";
    private static final String PLACEHOLDER_TODAY = "ui/views/TodayPlaceHolder.fxml";
    private static final String PLACEHOLDER_OVERDUE = "ui/views/OverduePlaceHolder.fxml";
    private static final String PLACEHOLDER_MAIN = "ui/views/MainViewPlaceHolder.fxml";
    // Window constants
    private static final double MIN_HEIGHT = 600;
    private static final double MIN_WIDTH = 400;
    private static final double DEFAULT_HEIGHT = 600;
    private static final double DEFAULT_WIDTH = 800;
    private static final String WINDOW_TITLE = "ToDoList by [w13-2j]";

    // Error messages for loading views
    private static final String MESSAGE_ERROR_LOAD_ROOT = "Error loading root view. Exiting now ...";
    private static final String MESSAGE_ERROR_LOAD_MAIN = "Error loading main view. Exiting now ...";
    private static final String MESSAGE_ERROR_LOAD_TITLEBAR = "Error loading title bar view. Exiting now ...";
    private static final String MESSAGE_ERROR_LOAD_SIDEBAR = "Error loading side bar view. Exiting now ...";
    private static final String MESSAGE_ERROR_LOAD_OVERDUE = "Error loading overdue view.";
    private static final String MESSAGE_ERROR_LOAD_TODAY = "Error loading today view.";
    private static final String MESSAGE_ERROR_LOAD_WEEK = "Error loading week view.";
    private static final String MESSAGE_ERROR_LOAD_ARCHIVE = "Error loading archive view.";
    private static final String MESSAGE_ERROR_LOAD_SETTINGS = "Error loading settings view.";
    private static final String MESSAGE_ERROR_PAGE_INDEX = "Page index is out of bounds @ #";
    private static final String MESSAGE_ERROR_LOAD_HELP = "Error loading help view.";

    // Action messages
    private static final String ACTION_NOTIFICATION_TRIGGERED = "Notification triggered";
    protected static final String FOCUS_COMMAND = "Command field is toggled into focus";
    protected static final String FOCUS_LIST = "Current list is toggled into focus";
    private static final String MESSAGE_CHANGED_PAGE = "Switched tab to %1$s";

    // Notification messages and delay constant
    private static final String NOTIFICATION_WELCOME = "Welcome to ToDoList! Let's get started...";
    private static final int DELAY_PERIOD = 5;

    // Root view directories
    private static final String DIRECTORY_ROOT = "ui/views/RootLayout.fxml";
    private static final String DIRECTORY_TITLEBAR = "ui/views/TitleBarView.fxml";
    private static final String DIRECTORY_SIDEBAR = "ui/views/SideBarView.fxml";
    public static final String DIRECTORY_TASKITEM = "ui/views/TaskNode.fxml";

    // Tab view directories
    private static final String DIRECTORY_MAIN = "ui/views/MainView.fxml";
    private static final String DIRECTORY_OVERDUE = "ui/views/OverdueView.fxml";
    private static final String DIRECTORY_TODAY = "ui/views/TodayView.fxml";
    private static final String DIRECTORY_WEEK = "ui/views/WeekView.fxml";
    private static final String DIRECTORY_ARCHIVE = "ui/views/ArchiveView.fxml";
    private static final String DIRECTORY_SETTINGS = "ui/views/SettingsView.fxml";
    private static final String DIRECTORY_HELP = "ui/views/HelpView.fxml";

    // Sound file directories
    private static final String DIRECTORY_NOTIFICATION_SOUND = "ui/views/assets/notification-sound-flyff.wav";
    private static final String DIRECTORY_WELCOME_SOUND = "ui/views/assets/notification-sound-twitch.mp3";

    // Logo directory
    private static final String APPLICATION_ICON = "ui/views/assets/icon.png";

    // Stylesheets
    private static final String UI_VIEWS_DEFAULT_THEME_CSS = "ui/views/styles/DefaultTheme.css";
    private static final String UI_VIEWS_DARK_THEME_CSS = "ui/views/styles/DarkTheme.css";

    // Styles
    private String nightModeTheme = null;
    private String dayModeTheme = null;
    private static final String STYLE_CLASS_ROOT = "root-layout";
    private static final String STYLE_CLASS_TITLEBAR = "title-bar";
    private static final String STYLE_CLASS_SIDEBAR = "side-bar";
    private static final String STYLE_NOTIFICATION_DAY = "-fx-font-size: 1.0em; -fx-font-family:"
            + "\"System Font\"; -fx-text-fill: #454553;";

    // Views: Display and UI components
    private Stage primaryStage;
    private BorderPane rootView;
    private BorderPane mainView;
    private Node mainViewDisplay;
    private TextField commandField;
    private HBox titleBarView;
    private VBox sideBarView;
    private BorderPane overdueView;
    private BorderPane todayView;
    private BorderPane weekView;
    private BorderPane archiveView;
    private BorderPane settingsView;
    private BorderPane helpView;

    // Page view index
    private static final int ALL_TAB = 1;
    private static final int EXPIRED_TAB = 2;
    private static final int TODAY_TAB = 3;
    private static final int WEEK_TAB = 4;
    private static final int DONE_TAB = 5;
    private static final int OPTIONS_TAB = 6;
    private static final int HELP_TAB = 7;
    private static final int DEFAULT_TAB = 3;
    private static final int SMALLEST_PAGE_INDEX = 1;
    private static final int LARGEST_PAGE_INDEX = 7;

    // Controllers
    private MainViewController mainController;
    private SideBarController sidebarController;
    private OverdueController overdueController;
    private TodayController todayController;
    private WeekController weekController;
    private ArchiveController archiveController;
    private SettingsController settingsController;
    private HelpModalController helpModal;

    // Other components
    private Logic logicUnit = null;
    private UIHandler uiHandlerUnit = null;

    // Notification system
    private static final int NOTIFICATION_PADDING = 50;
    private NotificationPane rootWithNotification = null;
    private PauseTransition delay = null;
    private boolean isFirstNotif = true;

    // Logger
    private UtilityLogger logger = null;

    // Command history
    private Stack<String> commandHistoryBackward = null;
    private Stack<String> commandHistoryForward = null;
    int commandHistoryPointer = -1;

    // Autocomplete dictionary
    private static final String[] suggestions = { "add", "edit", "delete", "search", "filter", "sort", "label",
            "postpone", "forward", "add-remind", "remind", "add-remind-bef", "remind-bef", "remove-remind", "done",
            "undone", "exit", "undo", "redo", "reset", "tab", "tab all", "tab today", "tab expired", "tab week",
            "tab done", "tab options", "tab help", "set-recurring", "remove-recurring", "create", "schedule", "cancel",
            "remove", "modify", "change", "replace", "archive", "complete", "finish", "shelf", "unarchive",
            "incomplete", "unfinish", "unshelf", "delay", "advance", "categorize", "tag", "load", "open", "save",
            "help" };

    // Mute property
    private BooleanProperty IS_MUTE = new SimpleBooleanProperty(false);

    // Dictionary
    ObservableList<String> keywords = null;

    /*** CORE FUNCTIONS ***/

    /*
     * Starts the application with launch() command.
     */
    public static void main(String[] args) {
        launch(args);
    }

    /*
     * (non-Javadoc)
     * 
     * @see javafx.application.Application#start(javafx.stage.Stage)
     */
    @Override
    public void start(Stage primaryStage) {

        // Setting application icon
        com.apple.eawt.Application application = com.apple.eawt.Application.getApplication();
        java.awt.Image image = Toolkit.getDefaultToolkit().getImage(MainApp.class.getResource(getApplicationIcon()));
        application.setDockIconImage(image);

        // Initializing utilities
        logger = new UtilityLogger();
        commandHistoryBackward = new Stack<String>();
        commandHistoryForward = new Stack<String>();

        // Reference and link with Logic component
        logicUnit = new Logic(this);
        uiHandlerUnit = logicUnit.getUIHandler();

        // Load views
        loadRootView(primaryStage);
        loadMainView();
        loadTitleBar();
        loadSideBar();

        // Prepare for user input
        commandField.requestFocus();
    }

    /*
     * loadNotifBubbles updates the sidebar notification bubbles with the latest
     * respective task count
     */
    private void loadNotifBubbles() {
        MainViewController[] controllers = { mainController, overdueController, todayController, weekController,
                archiveController };

        sidebarController.linkBubbles(controllers);
    }

    /*
     * initializeTabs load and initialize the controllers for each tab or page
     */
    private void initializeTabs() {
        for (int i = EXPIRED_TAB; i <= OPTIONS_TAB; ++i) {
            loadPage(i);
        }

        loadPage(getDefaultTab());
        rootView.setCenter(mainView);
        uiHandlerUnit.refresh();
    }

    /*
     * addShortcuts sets key listeners for the pre-defined keyboard shortcuts
     * 
     * @param Scene scene
     * 
     */
    private void addShortcuts(Scene scene) {
        KeyCodeCombination focusOnCommand = new KeyCodeCombination(KeyCode.K, KeyCombination.CONTROL_DOWN);
        KeyCodeCombination focusOnList = new KeyCodeCombination(KeyCode.L, KeyCombination.CONTROL_DOWN);
        KeyCodeCombination toggleMute = new KeyCodeCombination(KeyCode.M, KeyCombination.CONTROL_DOWN);

        IS_MUTE.addListener(new ChangeListener<Boolean>() {

            @Override
            public void changed(ObservableValue<? extends Boolean> observable, Boolean oldValue, Boolean newValue) {
                if (newValue) {
                    settingsController.setSoundStatus("Sound OFF");
                } else {
                    settingsController.setSoundStatus("Sound ON");

                }
            }
        });

        scene.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent event) {
                if (focusOnCommand.match(event)) {
                    commandField.requestFocus();
                    logger.logAction(UtilityLogger.Component.UI, FOCUS_COMMAND);
                }
            }
        });
        scene.addEventHandler(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent event) {
                if (focusOnList.match(event)) {
                    int page = sidebarController.getIndex();
                    switch (page) {
                    case ALL_TAB:
                        mainController.getTaskListView().requestFocus();
                        logger.logAction(UtilityLogger.Component.UI, FOCUS_LIST);
                        break;
                    case EXPIRED_TAB:
                        overdueController.getTaskListView().requestFocus();
                        logger.logAction(UtilityLogger.Component.UI, FOCUS_LIST);
                        break;
                    case TODAY_TAB:
                        todayController.getTaskListView().requestFocus();
                        logger.logAction(UtilityLogger.Component.UI, FOCUS_LIST);
                        break;
                    case WEEK_TAB:
                        weekController.getTaskListView().requestFocus();
                        logger.logAction(UtilityLogger.Component.UI, FOCUS_LIST);
                        break;
                    case DONE_TAB:
                        archiveController.getTaskListView().requestFocus();
                        logger.logAction(UtilityLogger.Component.UI, FOCUS_LIST);
                        break;
                    default:
                        commandField.requestFocus();
                        logger.logAction(UtilityLogger.Component.UI, FOCUS_COMMAND);
                    }
                }
            }
        });

        scene.addEventHandler(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent event) {
                if (toggleMute.match(event)) {
                    IS_MUTE.set(!IS_MUTE.get());
                }
            }
        });
    }

    /*
     * setWindowDimensions initializes the window properties for application
     * display.
     * 
     * @param Stage primaryStage
     * 
     */
    private void setWindowDimensions(Stage primaryStage) {
        primaryStage.setTitle(WINDOW_TITLE);
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }

    /*** VIEW LOADERS ***/

    /*
     * loadRootView wraps root view with notification pane and displays it
     * within a preset window.
     * 
     * @param Stage primaryStage is the display window for mounting the root
     * view
     */
    private void loadRootView(Stage primaryStage) {
        try {

            this.setPrimaryStage(primaryStage);

            // Acquire FXML and CSS component for root layout
            rootView = (BorderPane) FXMLLoader.load(MainApp.class.getResource(DIRECTORY_ROOT));
            rootView.getStyleClass().add(STYLE_CLASS_ROOT);

            // Setup notification system
            setupNotificationPane();
            setWindowDimensions(primaryStage);

            // Display wrapper notification scene
            Scene scene = new Scene(rootWithNotification, DEFAULT_WIDTH, DEFAULT_HEIGHT);

            // Stylesheet Handling
            nightModeTheme = MainApp.class.getResource(UI_VIEWS_DARK_THEME_CSS).toExternalForm();
            dayModeTheme = MainApp.class.getResource(UI_VIEWS_DEFAULT_THEME_CSS).toExternalForm();
            Application.setUserAgentStylesheet(null);
            StyleManager.getInstance().addUserAgentStylesheet(dayModeTheme);
            scene.getStylesheets().add(dayModeTheme);

            // Shortcuts Handling
            addShortcuts(scene);

            // Display
            primaryStage.setScene(scene);
            primaryStage.show();

            // Show Welcome Text
            notifyWithText(NOTIFICATION_WELCOME, true);

        } catch (IOException ioException) {
            logger.logError(UtilityLogger.Component.UI, MESSAGE_ERROR_LOAD_ROOT);
            ioException.printStackTrace();
            System.exit(1);
        }
    }

    /*
     * loadCommandLine embeds the command line in place in the root view and
     * sets the callback function for text input.
     * 
     */
    private void loadCommandLine() {

        if (keywords == null) {
            keywords = FXCollections.observableArrayList();

            for (String str : suggestions) {
                keywords.add(str);
            }
        }

        if (commandField == null) {
            commandField = (TextField) mainView.getBottom();

            TextFields.bindAutoCompletion(commandField, suggestions);

            mainController.setCommandLineCallback(commandField, dayModeTheme, nightModeTheme);

            // Cycle through history of commands
            KeyCodeCombination scrollHistoryUp = new KeyCodeCombination(KeyCode.UP, KeyCombination.ALT_DOWN);
            KeyCodeCombination scrollHistoryDown = new KeyCodeCombination(KeyCode.DOWN, KeyCombination.ALT_DOWN);

            ContextMenu menu = new ContextMenu();
            commandField.setContextMenu(menu);

            commandField.addEventHandler(KeyEvent.KEY_RELEASED, new EventHandler<KeyEvent>() {
                @Override
                public void handle(KeyEvent event) {

                    if (scrollHistoryUp.match(event) && !commandHistoryBackward.isEmpty()) {

                        // Browse history backward
                        String history = commandHistoryBackward.pop();
                        commandField.setText(history);
                        commandHistoryForward.push(history);
                        commandField.selectAll();

                    } else if (scrollHistoryDown.match(event) && !commandHistoryForward.isEmpty()) {

                        // Browse history forward
                        String history = commandHistoryForward.pop();
                        commandField.setText(history);
                        commandHistoryBackward.push(history);
                        commandField.selectAll();

                    } else if (scrollHistoryUp.match(event) || scrollHistoryDown.match(event)) {
                        // do nothing ...

                    } else {

                        // Reset on other input
                        while (!commandHistoryForward.isEmpty()) {
                            commandHistoryBackward.push(commandHistoryForward.pop());
                        }
                    }

                }

            });
        }

    }

    /*
     * loadTitleBar embeds the title bar in place in the root view
     */
    private void loadTitleBar() {
        try {

            // Acquire FXML and CSS component for title bar
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainApp.class.getResource(DIRECTORY_TITLEBAR));
            titleBarView = (HBox) loader.load();
            titleBarView.getStyleClass().add(STYLE_CLASS_TITLEBAR);

            rootView.setTop(titleBarView);

        } catch (IOException ioException) {
            logger.logError(UtilityLogger.Component.UI, MESSAGE_ERROR_LOAD_TITLEBAR);
            ioException.printStackTrace();
            System.exit(1);
        }
    }

    /*
     * loadSideBar embeds the side bar in place in the root view and initializes
     * the controller (logic) for the side bar
     */
    private void loadSideBar() {
        try {

            // Acquire FXML and CSS component for side bar
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(MainApp.class.getResource(DIRECTORY_SIDEBAR));
            sideBarView = (VBox) loader.load();
            sideBarView.getStyleClass().add(STYLE_CLASS_SIDEBAR);

            rootView.setLeft(sideBarView);

            // Set up display logic for side bar
            sidebarController = loader.getController();
            sidebarController.setMainApp(this);
            initializeTabs();
            loadNotifBubbles();

        } catch (IOException ioException) {
            logger.logError(UtilityLogger.Component.UI, MESSAGE_ERROR_LOAD_SIDEBAR);
            ioException.printStackTrace();
            System.exit(1);
        }
    }

    /*
     * getView takes in a FXML loader and a FXML directory, loads and returns
     * the JavaFX component object from the FXML file.
     * 
     * @param FXMLLoader loader, String directory
     * 
     * @return Node abstractView is the view initialized from the FXML file
     */
    private Node getView(FXMLLoader loader, String directory) throws IOException {
        loader.setLocation(MainApp.class.getResource(directory));
        Node abstractView = loader.load();
        rootView.setCenter(abstractView);
        return abstractView;
    }

    /*
     * loadMainView loads the main page into the main display area
     */
    private void loadMainView() {
        try {

            // Acquire FXML and CSS component for main view
            FXMLLoader loader = new FXMLLoader();
            if (mainView == null) {
                mainView = (BorderPane) getView(loader, DIRECTORY_MAIN);
                mainViewDisplay = mainView.getCenter();
            }

            if (mainController == null) {
                // Set up display logic for main view
                mainController = loader.getController();
                mainController.setMainApp(this, uiHandlerUnit);
                mainController.setPageIndex(ALL_TAB);
                mainController.setPlaceHolder(PLACEHOLDER_MAIN);
            }

            rootView.setCenter(mainView);
            mainView.setCenter(mainViewDisplay);
            if (commandField == null) {
                loadCommandLine();
            }
            // uiHandlerUnit.refresh();

        } catch (IOException ioException) {
            logger.logError(UtilityLogger.Component.UI, MESSAGE_ERROR_LOAD_MAIN);
            ioException.printStackTrace();
            System.exit(1);
        }
    }

    /*
     * loadOverdueView loads the overdue page into the main display area
     */
    private void loadOverdueView() {

        // Acquire FXML and CSS component for main view
        FXMLLoader loader = new FXMLLoader();
        try {

            if (overdueView == null) {
                overdueView = (BorderPane) getView(loader, DIRECTORY_OVERDUE);
            }

            // loadMainView();
            mainView.setCenter(overdueView);

            if (overdueController == null) {
                // Set up display logic for main view
                overdueController = loader.getController();
                overdueController.setMainApp(this, uiHandlerUnit);
                overdueController.setPageIndex(EXPIRED_TAB);
                overdueController.setPlaceHolder(PLACEHOLDER_OVERDUE);
            }

            // uiHandlerUnit.refresh();

        } catch (IOException ioException) {
            logger.logError(UtilityLogger.Component.UI, MESSAGE_ERROR_LOAD_OVERDUE);
            ioException.printStackTrace();
        }
    }

    /*
     * loadTodayView loads the today page into the main display area
     */
    private void loadTodayView() {
        // Acquire FXML and CSS component for main view
        FXMLLoader loader = new FXMLLoader();
        try {
            if (todayView == null) {
                todayView = (BorderPane) getView(loader, DIRECTORY_TODAY);
            }

            // loadMainView();
            mainView.setCenter(todayView);

            if (todayController == null) {
                // Set up display logic for main view
                todayController = loader.getController();
                todayController.setMainApp(this, uiHandlerUnit);
                todayController.setPageIndex(TODAY_TAB);
                todayController.setPlaceHolder(PLACEHOLDER_TODAY);
            }

            // uiHandlerUnit.refresh();

        } catch (IOException ioException) {
            logger.logError(UtilityLogger.Component.UI, MESSAGE_ERROR_LOAD_TODAY);
            ioException.printStackTrace();
        }
    }

    /*
     * loadWeekView loads the week page into the main display area
     */
    private void loadWeekView() {
        // Acquire FXML and CSS component for main view
        FXMLLoader loader = new FXMLLoader();
        try {

            if (weekView == null) {
                weekView = (BorderPane) getView(loader, DIRECTORY_WEEK);
            }

            // loadMainView();
            mainView.setCenter(weekView);

            if (weekController == null) {
                // Set up display logic for main view
                weekController = loader.getController();
                weekController.setMainApp(this, uiHandlerUnit);
                weekController.setPageIndex(WEEK_TAB);
                weekController.setPlaceHolder(PLACEHOLDER_WEEK);

            }

            // uiHandlerUnit.refresh();

        } catch (IOException ioException) {
            logger.logError(UtilityLogger.Component.UI, MESSAGE_ERROR_LOAD_WEEK);
            ioException.printStackTrace();
        }
    }

    /*
     * loadArchiveView loads the archive page into the main display area
     */
    private void loadArchiveView() {
        // Acquire FXML and CSS component for main view
        FXMLLoader loader = new FXMLLoader();
        try {
            if (archiveView == null) {
                archiveView = (BorderPane) getView(loader, DIRECTORY_ARCHIVE);
            }

            // loadMainView();
            mainView.setCenter(archiveView);

            if (archiveController == null) {
                // Set up display logic for main view
                archiveController = loader.getController();
                archiveController.setMainApp(this, uiHandlerUnit);
                archiveController.setPageIndex(DONE_TAB);
                archiveController.setPlaceHolder(PLACEHOLDER_ARCHIVE);

            }

            // uiHandlerUnit.refresh();
        } catch (IOException ioException) {
            logger.logError(UtilityLogger.Component.UI, MESSAGE_ERROR_LOAD_ARCHIVE);
            ioException.printStackTrace();
        }
    }

    /*
     * loadSettingsView loads the settings page into the main display area
     */
    private void loadSettingsView() {
        // Acquire FXML and CSS component for main view
        FXMLLoader loader = new FXMLLoader();
        try {
            if (settingsView == null) {
                settingsView = (BorderPane) getView(loader, DIRECTORY_SETTINGS);
            }

            // loadMainView();
            if (settingsController == null) {
                // Set up display logic for main view
                settingsController = loader.getController();
                settingsController.setMainApp(this, uiHandlerUnit);
                settingsController.setPageIndex(OPTIONS_TAB);
                settingsController.setPlaceHolder(PLACEHOLDER_SETTINGS);

            }

            mainView.setCenter(settingsView);

            // uiHandlerUnit.refresh();
        } catch (IOException ioException) {
            logger.logError(UtilityLogger.Component.UI, MESSAGE_ERROR_LOAD_SETTINGS);
            ioException.printStackTrace();
        }
    }

    /*
     * loadPage sets the current page index to the given index
     * 
     * @param index is the given candidate index to navigate to
     * 
     */
    public void loadPage(int index) {
        if (index >= SMALLEST_PAGE_INDEX && index <= LARGEST_PAGE_INDEX) {
            int oldIndex = sidebarController.getIndex();
            sidebarController.setIndex(index);
            setPageView(index, oldIndex);

            commandField.requestFocus();
        } else {
            logger.logError(UtilityLogger.Component.UI, MESSAGE_ERROR_PAGE_INDEX + index);
        }

    }

    /*
     * setPageView loads the corresponding page into the main display area
     * 
     * @param index is the page number to load
     * 
     */
    public void setPageView(int index, int oldIndex) {

        int page = index;

        switch (page) {
        case ALL_TAB:
            if (index != oldIndex) {
                loadMainView();
            }
            break;
        case EXPIRED_TAB:
            if (index != oldIndex) {
                loadOverdueView();
            }
            break;
        case TODAY_TAB:
            if (index != oldIndex) {
                loadTodayView();
            }
            break;
        case WEEK_TAB:
            if (index != oldIndex) {
                loadWeekView();
            }
            break;
        case DONE_TAB:
            if (index != oldIndex) {
                loadArchiveView();
            }
            break;
        case OPTIONS_TAB:
            if (index != oldIndex) {
                loadSettingsView();
            }
            break;
        case HELP_TAB:
            loadHelpPopup();
            break;
        default:
            break;
        }

        logger.logAction(Component.UI, String.format(MESSAGE_CHANGED_PAGE, sidebarController.getTabName(index)));

    }

    /*
     * loadHelpPopup displays a help table popover for easy reference.
     */
    private void loadHelpPopup() {

        // Acquire FXML and CSS component for main view
        FXMLLoader loader = new FXMLLoader();

        try {
            if (helpView == null) {
                helpView = (BorderPane) getView(loader, DIRECTORY_HELP);
            }

            if (helpModal == null) {
                helpModal = loader.getController();
                helpModal.setMainApp(this, helpView);
            }
        } catch (IOException ioException) {
            logger.logError(UtilityLogger.Component.UI, MESSAGE_ERROR_LOAD_HELP);
            ioException.printStackTrace();
        }

        if (helpModal.getModalPopup() == null) {
            helpModal.initializeHelpModal();
        }
        if (!helpModal.getModalPopup().isShowing()) {
            helpModal.displayPopup(sidebarController.help);
        }
        rootView.setCenter(mainView);
    }

    /*
     * getPage returns the current page index.
     * 
     * @return int page
     * 
     */
    public int getPage() {
        if (sidebarController != null) {
            return sidebarController.getIndex();
        } else {
            return 1;
        }
    }

    /*** NOTIFICATION FUNCTIONS ***/

    /*
     * setupNotificationPane intializes the notification system and wraps it
     * around the root display view
     */
    private void setupNotificationPane() {
        Label label = new Label();
        label.setPadding(new Insets(NOTIFICATION_PADDING));

        BorderPane borderPane = new BorderPane(label);
        rootWithNotification = new NotificationPane(borderPane);

        rootWithNotification.setStyle(STYLE_NOTIFICATION_DAY);
        rootWithNotification.setShowFromTop(true);
        rootWithNotification.setContent(rootView);
    }

    /*
     * notifyWithText triggers a notification with or without autohide.
     * 
     * @param String text is the notification text, boolean isAutohide is the
     * switch for autohiding notification after fixed delay.
     */
    public void notifyWithText(String text, boolean isAutohide) {

        // Trigger and display notification
        rootWithNotification.setText(text);
        rootWithNotification.show();
        logger.logAction(Component.UI, ACTION_NOTIFICATION_TRIGGERED + " = " + text);

        // Play notification sound(s) accordingly
        if (!isFirstNotif) {
            AudioClip notificationSound = new AudioClip(
                    this.getClass().getResource(DIRECTORY_NOTIFICATION_SOUND).toExternalForm());
            if (!IS_MUTE.get()) {
                notificationSound.play();
            }
        } else {
            AudioClip notificationSound = new AudioClip(
                    this.getClass().getResource(DIRECTORY_WELCOME_SOUND).toExternalForm());
            if (!IS_MUTE.get()) {
                notificationSound.play();
            }
            isFirstNotif = !isFirstNotif;
        }

        // Set autohide with delay factor
        if (isAutohide) {
            delay = new PauseTransition(Duration.seconds(DELAY_PERIOD));
            delay.setOnFinished(e -> rootWithNotification.hide());
            delay.play();
        }
    }

    /*** ACCESS FUNCTIONS FOR MODELS ***/

    /*
     * setDisplayTasks replaces and overwrites the current list of tasks to
     * display
     * 
     * @param ArrayList<Task> listOfTasks is the candidate list of tasks
     */
    public void setDisplayTasks(ArrayList<Task> listOfTasks) {

        MainViewController[] controllers = { mainController, overdueController, todayController, weekController,
                archiveController };

        // Update all controllers on new list to display
        if (mainController != null) {
            mainController.setTasks(listOfTasks);
        }
        if (overdueController != null) {
            overdueController.setTasks(listOfTasks);
        }
        if (todayController != null) {
            todayController.setTasks(listOfTasks);
        }
        if (weekController != null) {
            weekController.setTasks(listOfTasks);
        }
        if (archiveController != null) {
            archiveController.setTasks(listOfTasks);
        }

        if (sidebarController != null) {
            sidebarController.linkBubbles(controllers);
        }

        mainController.refreshReminders();
        settingsController.setupPage(mainController.getTaskListView().getItems());
    }

    /*
     * getDisplayTask returns the current displayed list of wrapped task
     * 
     * @return ObservableList<TaskWrapper> listOfDisplayedTasks
     */
    public ObservableList<TaskWrapper> getDisplayTasks() {
        switch (getPage()) {
        case 1:
            return mainController.getTasks();
        case 2:
            return overdueController.getTasks();
        case 3:
            return todayController.getTasks();
        case 4:
            return weekController.getTasks();
        case 5:
            return archiveController.getTasks();
        default:
            return mainController.getTasks();
        }
    }

    /*** HIGHLIGHTER ***/

    /*
     * highlightItem sets the corresponding task item on focus.
     * 
     * @param Task task is the task to be highlighted
     * 
     */
    public void highlightItem(Task task) {
        switch (getPage()) {
        case 1:
            if (mainController != null) {
                mainController.highlight(task);
            }
            break;
        case 2:
            if (overdueController != null) {
                overdueController.highlight(task);
            }
            break;
        case 3:
            if (todayController != null) {
                todayController.highlight(task);
            }
            break;
        case 4:
            if (weekController != null) {
                weekController.highlight(task);
            }
            break;
        case 5:
            if (archiveController != null) {
                archiveController.highlight(task);
            }
            break;
        default:
            if (mainController != null) {
                mainController.highlight(task);
            }
            break;
        }

    }

    /*** GETTERS AND SETTERS ***/

    /*
     * getTaskAt returns a task given its position in the current displayed
     * list, or a null if such as task does not exist.
     * 
     * @param int position
     * 
     * @return Task referredTask
     */
    public Task getTaskAt(int pos) {
        switch (getPage()) {
        case 1:
            if (mainController != null) {
                return mainController.getTaskAt(pos);
            }
            // Fallthrough
        case 2:
            if (overdueController != null) {
                return overdueController.getTaskAt(pos);
            }
            // Fallthrough
        case 3:
            if (todayController != null) {
                return todayController.getTaskAt(pos);
            }
            // Fallthrough
        case 4:
            if (weekController != null) {
                return weekController.getTaskAt(pos);
            }
            // Fallthrough
        case 5:
            if (archiveController != null) {
                return archiveController.getTaskAt(pos);
            }
            // Fallthrough
        default:
            return null;
        }
    }

    /*
     * getPrimaryStage returns the current stage that is hosting the display.
     * 
     * @return Stage primaryStage
     * 
     */
    public Stage getPrimaryStage() {
        return primaryStage;
    }

    /*
     * setPrimaryStage sets the current primaryStage as the given stage.
     * 
     * @param Stage primaryStage
     */
    public void setPrimaryStage(Stage primaryStage) {
        this.primaryStage = primaryStage;
    }

    /*
     * getHelpModal returns a HelpModalController that controls the logic for
     * help display.
     * 
     * @return HelpModalController helpModalController
     * 
     */
    public HelpModalController getHelpModal() {
        return helpModal;
    }

    /*
     * setHelpModal sets the given helpModalController as the
     * helpModalController for the help table.
     * 
     * @param HelpModalController helpModalController
     * 
     */
    public void setHelpModal(HelpModalController helpModal) {
        this.helpModal = helpModal;
    }

    /*
     * getSideBarController returns the current sideBarController that controls
     * the logic of the sidebar.
     * 
     * @return SideBarController sidebarController
     * 
     */
    public SideBarController getSideBarController() {
        return sidebarController;
    }

    /*
     * getCommandHistoryBackward returns the stack of command history saved
     * before the current visited entry.
     * 
     * @return Stack<String> commandHistoryBackward
     */
    public Stack<String> getCommandHistoryBackward() {
        return commandHistoryBackward;
    }

    /*
     * getCommandHistoryForward returns the stack of command history saved after
     * the current visited entry.
     * 
     * @return Stack<String> commandHistoryForward
     */
    public Stack<String> getCommandHistoryForward() {
        return commandHistoryForward;
    }

    /*
     * getHelpTab returns the tab number that refers to the help tab.
     * 
     * return int HELP_TAB
     */
    public static int getHelpTab() {
        return HELP_TAB;
    }

    /*
     * getSuggestions returns the array of suggestions that displays for
     * autocomplete.
     * 
     * @return String[] suggestions
     */
    public static String[] getSuggestions() {
        return suggestions;
    }

    /*
     * getDefaultTab returns the index referring to the default tab.
     * 
     * @return int defaultTabIndex
     * 
     */
    public static int getDefaultTab() {
        return DEFAULT_TAB;
    }

    /*
     * getApplicationIcon returns the path for the application icon.
     * 
     * @return String applicationIconPath
     * 
     */
    public static String getApplicationIcon() {
        return APPLICATION_ICON;
    }

    /*
     * isMute returns the status of the sound settings.
     * 
     * @return boolean isMute
     * 
     */
    public boolean isMute() {
        return IS_MUTE.get();
    }
}
```
###### /todolist/ui/controllers/ArchiveController.java
``` java

/* 
 * ArchiveController controls and manipulates data for display on the main display area, for the archive tab.
 * 
 * @author Huang Lie Jun (A0123994W)
 */
public class ArchiveController extends MainViewController {

    // Logger messages
    private static final String MESSAGE_UPDATED_ARCHIVED_TASKLIST = "Updated display task list [DONE].";

    /*
     * Constructor overrides super constructor and intializes the display task
     * list and list view.
     * 
     */
    public ArchiveController() {
        // Initialise models
        tasksToDisplay = FXCollections.observableArrayList();
        listView = new ListView<TaskWrapper>();
    }

    /*
     * (non-Javadoc)
     * @see todolist.ui.controllers.MainViewController#initialize()
     */
    @FXML
    public void initialize() {
        initTaskListView();
    }

    /*
     * (non-Javadoc)
     * @see todolist.ui.controllers.MainViewController#setTasks(java.util.ArrayList)
     */
    @Override
    public void setTasks(ArrayList<Task> tasks) {

        // List provided by logic must be valid
        assert (tasks != null);

        ArrayList<TaskWrapper> arrayOfWrappers = new ArrayList<TaskWrapper>();
        listView.getItems().clear();

        // Convert Task to TaskWrapper for display handling
        for (int i = 0; i < tasks.size(); ++i) {
            Task task = tasks.get(i);
            if (task.getDoneStatus()) {
                TaskWrapper wrappedTask = new TaskWrapper(task);
                arrayOfWrappers.add(wrappedTask);
            }
        }

        listView.getItems().addAll(arrayOfWrappers);
        logger.logAction(Component.UI, MESSAGE_UPDATED_ARCHIVED_TASKLIST);
    }
}
```
###### /todolist/ui/controllers/HelpModalController.java
``` java
public class HelpModalController {

    /*
     * EntryComparator compares 2 help table entries and sorts them accordingly.
     */
    public class EntryComparator implements Comparator<CommandPair> {
        public int compare(CommandPair pair1, CommandPair pair2) {
            if (pair1.getCommand() == pair2.getCommand()) {
                return 0;
            }
            return pair1.getCommand().compareTo(pair2.getCommand());
        }
    }

    /*
     * CommandPair wraps a help table entry.
     */
    private class CommandPair {
        private SimpleStringProperty command = null;
        private SimpleStringProperty format = null;

        public CommandPair(String command, String format) {
            this.command = new SimpleStringProperty(command);
            this.format = new SimpleStringProperty(format);
        }

        public String getCommand() {
            return command.get();
        }

        @SuppressWarnings("unused")
        public void setCommand(String command) {
            this.command.set(command);
        }

        public StringProperty getCommandProperty() {
            return command;
        }

        @SuppressWarnings("unused")
        public String getFormat() {
            return format.get();
        }

        @SuppressWarnings("unused")
        public void setFormat(String format) {
            this.format.set(format);
        }

        public StringProperty getFormatProperty() {
            return format;
        }
    }

    // Messages and Defaults
    private static final String TITLE_POPUP_HELP = "Help";
    protected static final String MESSAGE_HIDE_MODAL = "Help modal popover hidden.";
    protected static final String MESSAGE_DISPLAY_MODAL = "Help modal popover displayed.";

    // Window properties
    private static final double OPACITY = 0.90;
    private static final int BORDER_RADIUS = 10;

    // Elements
    private BorderPane helpView = null;
    private UtilityLogger logger = null;
    private static PopOver modalPopup = null;
    
    // Initialised status
    private boolean initialized = false;

    // Action Format HELP table
    private HashMap<String, String> actionFormatTable = null;

    // HELP table elements
    @FXML
    private TableView<CommandPair> helpTable = null;
    @FXML
    private TableColumn<CommandPair, String> commandColumn = null;
    @FXML
    private TableColumn<CommandPair, String> formatColumn = null;

    @SuppressWarnings("unused")
    private MainApp mainApp;

    ObservableList<CommandPair> entries = null;

    /*
     * Constructor sets up various elements such as logger and help table entries.
     */
    public HelpModalController() {
        logger = new UtilityLogger();
        actionFormatTable = new HashMap<String, String>();
        entries = FXCollections.observableArrayList();
    }

    /*
     * initializeHelpModal initialises the PopOver for displaying the help table.
     * 
     * @return boolean isInitialized
     */
    public boolean initializeHelpModal() {

        // Sets up modal
        modalPopup = new PopOver();
        modalPopup.setContentNode(helpView);
        modalPopup.setCornerRadius(BORDER_RADIUS);
        modalPopup.setArrowLocation(ArrowLocation.LEFT_BOTTOM);
        modalPopup.hideOnEscapeProperty().setValue(true);
        modalPopup.setTitle(TITLE_POPUP_HELP);
        modalPopup.setOpacity(OPACITY);
        modalPopup.setArrowSize(0);

        // Allow ESC to close popup
        for (Node component : helpView.getChildren()) {
            component.addEventHandler(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {

                @Override
                public void handle(KeyEvent key) {
                    if (key.getCode() == KeyCode.ESCAPE) {
                        modalPopup.hide();
                        logger.logAction(UtilityLogger.Component.UI, MESSAGE_HIDE_MODAL);
                    }
                }
            });
        }

        // Sets initialised flag after PopOver is created
        initialized = true;
        return initialized;

    }

    /*
     * displayPopup shows the help table, given a source node to display as the table.
     * 
     * @param Node pointSource
     * 
     */
    public void displayPopup(Node pointSource) {
        if (initialized) {
            populateCheatsheet();
            if (!modalPopup.isShowing()) {
                modalPopup.show(pointSource);
                modalPopup.getContentNode().requestFocus();
                logger.logAction(UtilityLogger.Component.UI, MESSAGE_DISPLAY_MODAL);
            }
        }
    }

    /*
     * initialize sets up the table values and factory settings for displaying every entry.
     * 
     */
    @FXML
    private void initialize() {
        // Initialize the person table with the two columns.
        commandColumn.setCellValueFactory(cellData -> cellData.getValue().getCommandProperty());
        formatColumn.setCellValueFactory(cellData -> cellData.getValue().getFormatProperty());
    }

    /**
     * Is called by the main application to give a reference back to itself.
     * 
     * @param mainApp
     */
    public void setMainApp(MainApp mainApp, BorderPane helpView) {
        this.mainApp = mainApp;
        this.helpView = helpView;

        // Add observable list data to the table
        helpTable.setItems(entries);
    }

    private void populateCheatsheet() {

        actionFormatTable.put("create a new task", "[add|create|schedule] <your-input>");
        actionFormatTable.put("deleting an existing task", "[delete|cancel|remove] <title|number>");
        actionFormatTable.put("editing a field of an existing task",
                "[edit|modify|change|replace] [title|start-time|end-time] <title|number> <new-value|date-time>");
        actionFormatTable.put("marking an existing task as completed",
                "[archive|done|complete|finish|shelf] <title|number>");
        actionFormatTable.put("marking an existing task as incomplete",
                "[unarchive|undone|incomplete|unfinish|unshelf] <title|number>");
        actionFormatTable.put("postponing an existing event or deadline", "[postpone|delay] <title|number> <duration>");
        actionFormatTable.put("advancing an existing event or deadline", "[forward|advance] <title|number> <duration>");
        actionFormatTable.put("search by keyword or letter", "[search] <your-input>");
        actionFormatTable.put("filter by category or date-time range", "[filter] <category-name|date-time>");
        actionFormatTable.put("sort the list in a certain order",
                "[sort] [title|start-time|end-time] [ascend|descend]");
        actionFormatTable.put("set the category of an existing task",
                "[categorise|label|tag] <title|number> <category-name>");
        actionFormatTable.put("set new file source", "[open|load] <file-source|relative-file-source>");
        actionFormatTable.put("create a new task with reminder", "[remind me to] <your-input>");
        actionFormatTable.put("set reminder for existing task", "[remind me for|remind] <title|number>");
        actionFormatTable.put("set a task as recurring",
                "[set-recurring] <title|number> <quantity> <minute|hour|day|week|month|year>");
        actionFormatTable.put("undo your previous step", "[undo]");
        actionFormatTable.put("redo your previously reverted step", "[redo]");
        actionFormatTable.put("set your default tab", "[set-home] <name-of-page>");
        actionFormatTable.put("set alarm ringtone", "[set-ringtone] <file-path>");
        actionFormatTable.put("mute or unmute", "[toggle-sound] [on|off]");
        actionFormatTable.put("reload a page", "[refresh|reload]");
        actionFormatTable.put("clear existing search and filters", "[reset|clear|clean]");
        actionFormatTable.put("navigate between pages", "[page-name]");
        actionFormatTable.put("day and night mode theming", "[day-mode|night-mode]");
        actionFormatTable.put("exiting the program", "[exit | quit | close | terminate]");
        actionFormatTable.put("[keyboard shortcut] browsing the task list", "[UP-ARROW | DOWN-ARROW]");
        actionFormatTable.put("[keyboard shortcut] browsing command history", "[SHIFT + UP | SHIFT + DOWN]");
        actionFormatTable.put("[keyboard shortcut] closing popups for help and reminders", "[ESC]");
        actionFormatTable.put("[keyboard shortcut] browsing tabs or pages", "[TAB] | [F1 | F2 | ... | F7]");
        actionFormatTable.put("[keyboard shortcut] change context between command field and task list",
                "[SHIFT + K] for command and [SHIFT + L] for list");

        for (Entry<String, String> entry : actionFormatTable.entrySet()) {
            entries.add(new CommandPair(entry.getKey(), entry.getValue()));
        }

        entries.sort(new EntryComparator());
    }

    /*
     * getModalPopup returns a PopOver to access the help table popup.
     * 
     * @return PopOver helpTable
     */
    public PopOver getModalPopup() {
        return modalPopup;
    }

}
```
###### /todolist/ui/controllers/MainViewController.java
``` java

/* 
 * MainViewController controls and manipulates data for display on the main display area, for the main tab.
 * 
 * @author Huang Lie Jun (A0123994W)
 */
public class MainViewController {

    // Logger Messages
    private static final String MESSAGE_CALL_LOGIC_COMPONENT = "User input detected at UI component --calling--> Logic component for processing.";
    private static final String MESSAGE_CLEAR_TEXTFIELD = "Text field cleared for next input.";
    private static final String ERROR_PROCESSING_USER_INPUT = "Error processing user input.";
    private static final String MESSAGE_UPDATED_MAIN_TASKLIST = "Updated display task list [ALL].";
    private static final String MESSAGE_HIGHLIGHT_ITEM = "Item #%1$s in display task list highlighted.";
    private static final String MESSAGE_HIGHLIGHT_ITEM_NOT_FOUND = "Item to be highlighted cannot be found in display task list.";
    private static final String NIGHT_MODE = "night-mode";
    private static final String DAY_MODE = "day-mode";

    // Reminders
    protected static final String REMINDER_EVENT = "Remember to attend your event [%1$s] ! All the best!";
    protected static final String REMINDER_DEADLINE = "[%1$s] will be due soon! You can do it!";
    protected static final String REMINDER_OTHER = "Please be reminded to [%1$s] !";
    protected static final String REMINDER_HEADER = "ToDoList Reminder: ";
    private static final String DIRECTORY_REMINDER_SOUND = "ui/views/assets/notification-sound-ting.mp3";
    private static ArrayList<Timeline> reminders = null;

    // Model data
    protected ObservableList<TaskWrapper> tasksToDisplay = null;

    // Main application linkback
    protected MainApp mainApplication = null;
    private UIHandler uiHandler = null;

    /*** Views ***/
    @FXML
    protected ListView<TaskWrapper> listView = null;

    // Logger
    UtilityLogger logger = null;

    protected int index = 0;

```
###### /todolist/ui/controllers/MainViewController.java
``` java
    /*** Controller Functions ***/

    /*
     * Constructor initializes to contain the display data structure.
     *
     */
    public MainViewController() {
        // Initialise models
        tasksToDisplay = FXCollections.observableArrayList();
        listView = new ListView<TaskWrapper>();
        logger = new UtilityLogger();
        reminders = new ArrayList<Timeline>();
    }

    /*
     * setMainApp takes a MainApp reference and stores it locally as the
     * mainApplication reference.
     * 
     * @param MainApp mainApp is the reference provided to the calling function
     * 
     */
    public void setMainApp(MainApp mainApp, UIHandler uiHandlerUnit) {
        setMainApplication(mainApp);
        setUiHandler(uiHandlerUnit);
    }

    /*
     * initialize prepares the task list.
     * 
     */
    @FXML
    public void initialize() {
        initTaskListView();
    }

    /*
     * initTaskListView initializes the task list by setting the list properties
     * and default format.
     * 
     */
    public void initTaskListView() {
        listView.setCellFactory(new Callback<ListView<TaskWrapper>, javafx.scene.control.ListCell<TaskWrapper>>() {
            @Override
            public ListCell<TaskWrapper> call(ListView<TaskWrapper> listView) {
                return new TaskListCell();
            }
        });

        VBox.setVgrow(listView, Priority.ALWAYS);
        HBox.setHgrow(listView, Priority.ALWAYS);

    }

    /*
     * setCommandLineCallback takes in a textfield and sets a function as the
     * action callback function.
     * 
     * @param TextField commandField is the command line that reads the user
     * input
     * 
     */
    public void setCommandLineCallback(TextField commandField, String dayMode, String nightMode) {
        // Set Callback for TextField
        EventHandler<ActionEvent> commandHandler = new EventHandler<ActionEvent>() {

            @Override
            public void handle(ActionEvent event) {
                String commandString = commandField.getText();

                // Pass command line input for processing
                try {

                    // Clear field
                    commandField.clear();
                    logger.logAction(Component.UI, MESSAGE_CLEAR_TEXTFIELD);

                    // Save field to history
                    getMainApplication().getCommandHistoryBackward().push(commandString);

                    // Day and night mode theming
                    if (commandString.equals(NIGHT_MODE)) {
                        Scene scene = getMainApplication().getPrimaryStage().getScene();
                        scene.getStylesheets().remove(dayMode);
                        scene.getStylesheets().add(nightMode);
                        getMainApplication().getPrimaryStage().setScene(scene);
                        getMainApplication().getPrimaryStage().show();

                    } else if (commandString.equals(DAY_MODE)) {
                        Scene scene = getMainApplication().getPrimaryStage().getScene();
                        scene.getStylesheets().remove(nightMode);
                        scene.getStylesheets().add(dayMode);
                        getMainApplication().getPrimaryStage().setScene(scene);
                        getMainApplication().getPrimaryStage().show();

                    // Call logic component for processing
                    } else {
                        getUiHandler().process(commandString);
                        logger.logComponentCall(Component.UI, MESSAGE_CALL_LOGIC_COMPONENT);
                    }

                } catch (Exception exception) {
                    logger.logError(Component.UI, ERROR_PROCESSING_USER_INPUT);
                    exception.printStackTrace();
                }
            }
        };

        commandField.setOnAction(commandHandler);
    }

```
###### /todolist/ui/controllers/MainViewController.java
``` java
    /*** View Access Functions ***/

    /*
     * getTaskListView returns the current list view of tasks.
     * 
     * @return ListView<TaskWrapper> listView
     * 
     */
    public ListView<TaskWrapper> getTaskListView() {
        return listView;
    }

    /*** Model Access Functions ***/

    /*
     * getTasks returns the list of tasks stored.
     * 
     * @return ObservableList<TaskWrapper> tasks
     * 
     */
    public ObservableList<TaskWrapper> getTasks() {
        return tasksToDisplay;
    }

    /*
     * setTasks takes a list of tasks and sets it as the list of tasks to
     * display by associating with the list view. This overrides all the tasks
     * in the current list of display tasks.
     * 
     * @param ArrayList<Task> tasks is the list of tasks to replace the current
     * display list
     * 
     */
    public void setTasks(ArrayList<Task> tasks) {

        // List provided by logic must be valid
        assert (tasks != null);

        ArrayList<TaskWrapper> arrayOfWrappers = new ArrayList<TaskWrapper>();
        listView.getItems().clear();

        // Convert Task to TaskWrapper for display handling
        for (int i = 0; i < tasks.size(); ++i) {
            if (!tasks.get(i).getDoneStatus()) {
                TaskWrapper wrappedTask = new TaskWrapper(tasks.get(i));
                arrayOfWrappers.add(wrappedTask);
            }
        }

        listView.getItems().addAll(arrayOfWrappers);

        logger.logAction(Component.UI, MESSAGE_UPDATED_MAIN_TASKLIST);
    }

    /*** Utility Functions ***/

    /*
     * highlight gets the index of the task to highlight and put that index item
     * on focus.
     * 
     * @param Task task is the task to be highlighted.
     */
    public void highlight(Task task) {
        int index = searchInList(task);

        // Only highlights if the task is within range and can be found in the
        // list
        if (index != -1) {
            listView.getSelectionModel().select(index);
            listView.getFocusModel().focus(index);
            listView.scrollTo(index);
            logger.logAction(Component.UI, String.format(MESSAGE_HIGHLIGHT_ITEM, Integer.toString(index)));
        }
    }

    /*
     * searchInList takes a task and searches for its position in the current
     * display list.
     * 
     * @param Task task is the task to locate
     * 
     * @return int searchIndex is the position of the task in the list of tasks
     * 
     */
    private int searchInList(Task task) {

        // Return the index if the task can be found
        for (int i = 0; i < listView.getItems().size(); ++i) {
            if (listView.getItems().get(i).getTaskObject().equals(task)) {
                return i;
            }
        }

        // Otherwise, denote as cannot be found by -1
        logger.logAction(Component.UI, MESSAGE_HIGHLIGHT_ITEM_NOT_FOUND);
        return -1;
    }

    /*
     * isCompleted checks if a given task has already been completed.
     * 
     * @param Task task is the given task to check for completion
     * 
     * @return boolean isCompleted
     * 
     */
    protected Boolean isCompleted(Task task) {
        return task.getDoneStatus();
    }

    /*
     * getTaskAt returns the task at the position specified in the list view, or
     * null if it is not found.
     * 
     * @param int pos
     * 
     * @return Task task
     * 
     */
    public Task getTaskAt(int pos) {
        ObservableList<TaskWrapper> itemList = listView.getItems();
        if (pos >= 1 && pos <= itemList.size()) {
            return itemList.get(pos - 1).getTaskObject();
        } else {
            return null;
        }
    }

    /*
     * refreshReminders updates all the reminders to be triggered
     */
    public void refreshReminders() {
        // Identify tasks with reminders switched on
        FilteredList<TaskWrapper> tasksToRemind = new FilteredList<TaskWrapper>(getTaskListView().getItems(),
                task -> task.getReminder() != null && !task.getIsCompleted() && task.getReminder().getStatus());

        // Stop all current reminders
        for (Timeline reminder : reminders) {
            reminder.stop();
        }

        // Clear current reminders
        reminders.clear();

        // Set current reminders
        for (TaskWrapper task : tasksToRemind) {
            Reminder taskReminder = task.getReminder();
            LocalDateTime remindTime = taskReminder.getTime();

            // Event without pre-defined reminder time
            if (remindTime == null) {
                remindTime = task.getStartTime();
            }
            // Deadline without pre-defined reminder time
            if (remindTime == null) {
                remindTime = task.getEndTime();
            }

            // Schedule reminder
            scheduleReminder(task, remindTime);
        }
    }

    /*
     * scheduleReminder sets the task reminder to trigger at the given timing.
     * 
     * @param TaskWrapper task, LocalDateTime remindTime
     *
     */
    static public void scheduleReminder(TaskWrapper task, LocalDateTime remindTime) {
        if (remindTime != null && remindTime.isAfter(LocalDateTime.now())) {
            long difference = LocalDateTime.now().until(remindTime, ChronoUnit.SECONDS);
            Timeline timer = new Timeline(new KeyFrame(Duration.seconds(difference), new EventHandler<ActionEvent>() {

                @Override
                public void handle(ActionEvent event) {
                    setReminderNotifPop(task);
                }

                private void setReminderNotifPop(TaskWrapper task) {

                    String output = null;
                    Notifications notification = Notifications.create();

                    // FORMAT HERE //
                    notification.title(REMINDER_HEADER + task.getTaskTitle());
                    if (task.getTaskType() == TaskType.EVENT) {
                        output = String.format(REMINDER_EVENT, task.getTaskTitle());
                    } else if (task.getTaskType() == TaskType.DEADLINE) {
                        output = String.format(REMINDER_DEADLINE, task.getTaskTitle());
                    } else {
                        output = String.format(REMINDER_OTHER, task.getTaskTitle());
                    }
                    notification.text(output);
                    notification.hideAfter(Duration.minutes(5));

                    AudioClip notificationSound = new AudioClip(
                            MainApp.class.getResource(DIRECTORY_REMINDER_SOUND).toExternalForm());
                    notificationSound.play();
                    notification.show();
                }
            }));
            timer.setCycleCount(1);
            timer.play();
            reminders.add(timer);
        }
    }

    /*
     * getCompletedCount returns the number of completed tasks in the current display list
     * 
     * @return int completedCount
     * 
     */
    public int getCompletedCount() {
        int count = 0;
        for (TaskWrapper task : listView.getItems()) {
            if (task.getIsCompleted()) {
                count += 1;
            }
        }

        return count;
    }

    /*
     * setPageIndex takes in the tab index and sets the page with the index as the current page
     * 
     * @param int tab
     * 
     */
    public void setPageIndex(int tab) {
        index = tab;
    }

    /*
     * getPageIndex retrieves the page index of the current page.
     * 
     * @return 
     */
    public int getPageIndex() {
        return index;
    }

    /*
     * setPlaceHolder takes in a glyphSource directory and sets the glyph as the placeholder for empty list view(s).
     * 
     * @param String glyphSource
     * 
     */
    public void setPlaceHolder(String glyphSource) {

        VBox box = null;
        try {
            box = (VBox) FXMLLoader.load(MainApp.class.getResource(glyphSource));

        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        box.visibleProperty().bind(Bindings.isEmpty(listView.getItems()));
        listView.setPlaceholder(box);

    }

    /*
     * getMainApplication returns the link-back to the MainApp
     * 
     * @return MainApp mainApplication
     * 
     */
    public MainApp getMainApplication() {
        return mainApplication;
    }

    /*
     * setMainApplication takes in the a link to the main application.
     * 
     * @param MainApp mainApplication
     * 
     */
    public void setMainApplication(MainApp mainApplication) {
        this.mainApplication = mainApplication;
    }

    /*
     * getUiHandler returns a UIHandler reference.
     * 
     * @return UIHandler uiHandler
     * 
     */
    public UIHandler getUiHandler() {
        return uiHandler;
    }

    /*
     * setUiHandler takes in the link to a UI handler.
     * 
     * @param UIHandler uiHandler
     * 
     */
    public void setUiHandler(UIHandler uiHandler) {
        this.uiHandler = uiHandler;
    }
}
```
###### /todolist/ui/controllers/OverdueController.java
``` java

/* 
 * OverdueController controls and manipulates data for display on the main display area, for the overdue tab.
 * 
 * @author Huang Lie Jun (A0123994W)
 */
public class OverdueController extends MainViewController {

    // Logger messages
    private static final String MESSAGE_UPDATED_OVERDUE_TASKLIST = "Updated display task list [OVERDUE].";

    /*
     * Constructor overrides super constructor and intializes the display task
     * list and list view.
     * 
     */
    public OverdueController() {
        // Initialise models
        tasksToDisplay = FXCollections.observableArrayList();
        listView = new ListView<TaskWrapper>();
    }

    /*
     * (non-Javadoc)
     * 
     * @see todolist.ui.controllers.MainViewController#initialize()
     */
    @FXML
    public void initialize() {
        initTaskListView();
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * todolist.ui.controllers.MainViewController#setTasks(java.util.ArrayList)
     */
    @Override
    public void setTasks(ArrayList<Task> tasks) {

        // List provided by logic must be valid
        assert (tasks != null);

        ArrayList<TaskWrapper> arrayOfWrappers = new ArrayList<TaskWrapper>();
        listView.getItems().clear();

        // Convert Task to TaskWrapper for display handling
        for (int i = 0; i < tasks.size(); ++i) {
            Task task = tasks.get(i);
            // Only display overdue tasks that are not yet completed
            if (isOverdue(task) && !isCompleted(task)) {
                TaskWrapper wrappedTask = new TaskWrapper(tasks.get(i));
                arrayOfWrappers.add(wrappedTask);
            }
        }

        listView.getItems().addAll(arrayOfWrappers);
        logger.logAction(Component.UI, MESSAGE_UPDATED_OVERDUE_TASKLIST);
    }

    /*
     * isOverdue is a utility function that checks if a given task is expired by
     * checking that the end date-time is not past yet.
     * 
     * @param Task task is the task to check for expiry
     * 
     * @return boolean isOverdue is overdue flag
     * 
     */
    private boolean isOverdue(Task task) {
        return task.getEndTime() != null && task.getEndTime().isBefore(LocalDateTime.now());
    }
}
```
###### /todolist/ui/controllers/SettingsController.java
``` java

/* 
 * SettingsController controls and manipulates data for display on the main display area.
 * 
 * @author Huang Lie Jun (A0123994W)
 */
public class SettingsController extends MainViewController {

    private static final int POSITION_CHART_IN_VBOX = 1;
    private static String monday = "%1$s";
    private static String tuesday = "%1$s";
    private static String wednesday = "%1$s";
    private static String thursday = "%1$s";
    private static String friday = "%1$s";
    private static String saturday = "%1$s";
    private static String sunday = "%1$s";
    private static String undated = "Any";

    @FXML
    private StackedBarChart<Number, String> timeTable = null;

    @FXML
    private VBox box = null;

    @FXML
    private Text directoryDisplay = null;
    
    @FXML
    private Text soundStatus = null;

    // Logger messages
    private static final String MESSAGE_UPDATED_SETTINGS = "Updated display [OPTIONS].";

    /*
     * Constructor overrides super constructor and intializes the display task
     * list and list view.
     * 
     */
    public SettingsController() {
        // Initialise models
        tasksToDisplay = FXCollections.observableArrayList();
        listView = new ListView<TaskWrapper>();
    }

    /*
     * setMainApp takes a MainApp reference and stores it locally as the
     * mainApplication reference.
     * 
     * @param MainApp mainApp is the reference provided to the calling function
     * 
     */
    public void setMainApp(MainApp mainApp, UIHandler uiHandlerUnit) {
        setMainApplication(mainApp);
        setUiHandler(uiHandlerUnit);
    }

    /*
     * (non-Javadoc)
     * 
     * @see todolist.ui.controllers.MainViewController#initialize()
     */
    @FXML
    public void initialize() {
    }

    /*
     * getMessageUpdatedSettings returns the standard output message for display when the settings view gets updated.
     * 
     * @return String MESSAGE_UPDATED_SETTINGS
     * 
     */
    public static String getMessageUpdatedSettings() {
        return MESSAGE_UPDATED_SETTINGS;
    }
    
    /*
     * Deprecated. We drop the use of CalendarFX due to the requirement for license.
     */
    public void loadCalendar(ObservableList<TaskWrapper> observableList) {

    }

    /*
     * setupPage takes in an observable list of tasks (wrapped) and filters for a neat weekly summary. 
     * The options area will also be dynamically linked to the relevant listeners for changes and updates.
     * 
     * @param ObservableList<TaskWrapper> observableList
     * 
     */
    public void setupPage(ObservableList<TaskWrapper> observableList) {
        
        // Update directory
        updateDirectory();
        
        // Create chart
        StackedBarChart<Number, String> timeTable = buildChart(observableList);
        timeTable.backgroundProperty().set(Background.EMPTY);
        box.getChildren().set(POSITION_CHART_IN_VBOX, timeTable);
    }

    private StackedBarChart<Number, String> buildChart(ObservableList<TaskWrapper> observableList) {
        NumberAxis xAxis = new NumberAxis();
        CategoryAxis yAxis = new CategoryAxis();
        StackedBarChart<Number, String> timeTable = new StackedBarChart<Number, String>(xAxis, yAxis);
        org.joda.time.format.DateTimeFormatter format = DateTimeFormat.forPattern("d-MMM");

        formatChartLabelsWithDate(format);

        yAxis.setCategories(FXCollections.observableArrayList(sunday, saturday, friday, thursday, wednesday, tuesday,
                monday, undated));
        HashMap<String, int[]> reference = new HashMap<String, int[]>();

        // ... filter list if necessary
        LocalDateTime startOfWeek = LocalDateTime.now().withDayOfWeek(1).withTime(0, 0, 0, 0);
        LocalDateTime endOfWeek = LocalDateTime.now().withDayOfWeek(7).withTime(23, 59, 59, 0);                
        
        for (TaskWrapper task : observableList) {
            
            // Skip deadlines and events that are out of the week zone
            if (isOutOfWeekRange(startOfWeek, endOfWeek, task)) {
                continue;
            }
            
            // Get category name
            String catName = "uncategorised";
            if (task.getCategory() != null) {
                catName = task.getCategory().getCategory();
            }
            
            int[] sameCatTasks = reference.get(catName);

            // New category encountered
            if (sameCatTasks == null) {
                sameCatTasks = new int[8];
            }

            // Keep count for types of tasks under category
            if (task.getStartTime() == null && task.getEndTime() == null) {
                sameCatTasks[0] += 1;
            } else if (task.getStartTime() == null && task.getEndTime() != null) {
                sameCatTasks[task.getEndTime().getDayOfWeek().getValue()] += 1;
            } else if (task.getStartTime() != null && task.getEndTime() != null) {
                sameCatTasks[task.getStartTime().getDayOfWeek().getValue()] += 1;
            }

            // Update reference hashtable
            reference.put(catName, sameCatTasks);

        }

        // Create series for each category
        for (java.util.Map.Entry<String, int[]> entry : reference.entrySet()) {
            int[] sameCatTasks = entry.getValue();
            XYChart.Series<Number, String> series = new XYChart.Series<Number, String>();
            setEntryInSeries(entry, sameCatTasks, series);
            timeTable.getData().add(series);
        }
        return timeTable;
    }

    private void updateDirectory() {
        String path = getUiHandler().getPath();
        directoryDisplay.setText(path);
    }

    private void setEntryInSeries(java.util.Map.Entry<String, int[]> entry, int[] sameCatTasks,
            XYChart.Series<Number, String> series) {
        series.setName(entry.getKey());
        series.getData().add(new XYChart.Data<Number, String>(sameCatTasks[0], undated));
        series.getData().add(new XYChart.Data<Number, String>(sameCatTasks[1], monday));
        series.getData().add(new XYChart.Data<Number, String>(sameCatTasks[2], tuesday));
        series.getData().add(new XYChart.Data<Number, String>(sameCatTasks[3], wednesday));
        series.getData().add(new XYChart.Data<Number, String>(sameCatTasks[4], thursday));
        series.getData().add(new XYChart.Data<Number, String>(sameCatTasks[5], friday));
        series.getData().add(new XYChart.Data<Number, String>(sameCatTasks[6], saturday));
        series.getData().add(new XYChart.Data<Number, String>(sameCatTasks[7], sunday));
    }

    private boolean isOutOfWeekRange(LocalDateTime startOfWeek, LocalDateTime endOfWeek, TaskWrapper task) {
        return task.getEndTime() != null && !isWithinWeek(startOfWeek, endOfWeek, task.getEndTime());
    }

    private boolean isWithinWeek(LocalDateTime startOfWeek, LocalDateTime endOfWeek, java.time.LocalDateTime endTime) {

        int millis = 0;
        int seconds = endTime.getSecond();
        int minutes = endTime.getMinute();
        int hours = endTime.getHour();
        int day = endTime.getDayOfMonth();
        int month = endTime.getMonthValue();
        int year = endTime.getYear();
        
        LocalDateTime endTimeFormatted = new LocalDateTime();
        endTimeFormatted = endTimeFormatted.withDate(year, month, day);
        endTimeFormatted = endTimeFormatted.withTime(hours, minutes, seconds, millis);
        
        return endTimeFormatted.isAfter(startOfWeek) && endTimeFormatted.isBefore(endOfWeek);    
    }

    private void formatChartLabelsWithDate(org.joda.time.format.DateTimeFormatter format) {
        monday = String.format(monday, LocalDateTime.now().withDayOfWeek(1).toString(format));
        tuesday = String.format(tuesday, LocalDateTime.now().withDayOfWeek(2).toString(format));
        wednesday = String.format(wednesday, LocalDateTime.now().withDayOfWeek(3).toString(format));
        thursday = String.format(thursday, LocalDateTime.now().withDayOfWeek(4).toString(format));
        friday = String.format(friday, LocalDateTime.now().withDayOfWeek(5).toString(format));
        saturday = String.format(saturday, LocalDateTime.now().withDayOfWeek(6).toString(format));
        sunday = String.format(sunday, LocalDateTime.now().withDayOfWeek(7).toString(format));
    }
    
    /*
     * setSoundStatus takes in a status string descriptor and sets the sound status display text accordingly.
     * 
     * @param String status
     * 
     */
    public void setSoundStatus(String status) {
        soundStatus.setText(status); 
    }
}
```
###### /todolist/ui/controllers/SideBarController.java
``` java

/*
 * SideBarController controls the interface for the sidebar or tabs
 * 
 * @author Huang Lie Jun (A0123994W)
 */
public class SideBarController {

    private static final String BUBBLE_COUNT = "%d";
    /*** TAB STYLES ***/
    private static final String STYLE_TAB_NORMAL = "-fx-background-color: transparent;";
    private static final String STYLE_TAB_FOCUSED = "-fx-background-color: #069A8E;";

    /*** VIEWS ***/

    // ALL TAB
    @FXML
    private Button all = null;
    @FXML
    private ImageView allIcon = null;
    @FXML
    private Label allBubble = null;

    // EXPIRED TAB
    @FXML
    private Button expired = null;
    @FXML
    private ImageView expiredIcon = null;
    @FXML
    private Label expiredBubble = null;

    // TODAY TAB
    @FXML
    private StackPane todayStack = null;
    @FXML
    private Label todayLabel = null;
    @FXML
    private Button today = null;
    @FXML
    private ImageView todayIcon = null;
    private int todayDate = 0;
    @FXML
    private Label todayBubble = null;

    // WEEK TAB
    @FXML
    private Button week = null;
    @FXML
    private ImageView weekIcon = null;
    @FXML
    private Label weekBubble = null;

    // DONE TAB
    @FXML
    private Button done = null;
    @FXML
    private ImageView doneIcon = null;
    @FXML
    private Label doneBubble = null;

    // OPTIONS TAB
    @FXML
    private Button options = null;
    @FXML
    private ImageView optionsIcon = null;

    // HELP TAB
    @FXML
    public Button help = null;
    @FXML
    private ImageView helpIcon = null;

    /*** SIDEBAR AND PAGE PROPERTIES ***/

    private int index = -1;
    private static int NUMBER_BUTTONS = 7;
    private Button[] buttonArray = null;
    private HashMap<Button, Integer> buttonHash = null;

    // Main Application reference
    private MainApp mainApplication = null;

    // Logger and Logger messages
    UtilityLogger logger = null;

    /*** CORE FUNCTIONS ***/

    /*
     * setMainApp sets the reference to link back to main application.
     * 
     * @param MainApp mainApp
     * 
     */
    public void setMainApp(MainApp mainApp) {
        mainApplication = mainApp;
    }

    /*
     * initialize initialises the controller with neccessary assets 
     */
    @FXML
    public void initialize() {
        index = MainApp.getDefaultTab();
        logger = new UtilityLogger();
        setButtonArray();
        setButtonHash();
        setClickTabLogic();
        setTodayDate();
        colourTab();
    }

    /*
     * setButtonArray initializes the array of buttons
     */
    private void setButtonArray() {
        buttonArray = new Button[NUMBER_BUTTONS];
        buttonArray[0] = all;
        buttonArray[1] = expired;
        buttonArray[2] = today;
        buttonArray[3] = week;
        buttonArray[4] = done;
        buttonArray[5] = options;
        buttonArray[6] = help;
    }

    /*
     * setClickTabLogic sets the on-click event for tabs
     */
    private void setClickTabLogic() {
        for (int i = 0; i < buttonArray.length; ++i) {
            Button button = buttonArray[i];
            setTabButtonCallback(button);
        }
        setTodayLabelCallback();
    }

    private void setTodayLabelCallback() {
        todayLabel.setOnMouseClicked(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent event) {
                int index = getButtonIndex(today);
                mainApplication.loadPage(index);
            }
        });
    }

    private void setTabButtonCallback(Button button) {
        button.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent event) {
                int index = getButtonIndex(button);
                mainApplication.loadPage(index);
            }
        });
    }

    /*
     * setButtonHash maps each button to its index or sequence on the sidebar
     */
    private void setButtonHash() {
        buttonHash = new HashMap<Button, Integer>();
        buttonHash.put(all, 1);
        buttonHash.put(expired, 2);
        buttonHash.put(today, 3);
        buttonHash.put(week, 4);
        buttonHash.put(done, 5);
        buttonHash.put(options, 6);
        buttonHash.put(help, 7);
    }

    /*
     * setTodayDate sets the date display label on the Today tab button
     */
    private void setTodayDate() {
        todayDate = LocalDateTime.now().getDayOfMonth();
        todayLabel.setText(Integer.toString(todayDate));
    }

    /*
     * setIndex takes in a page / tab number and navigates to it if valid.
     * 
     * @param int index
     * 
     */
    public void setIndex(int index) {
        
        if (index != MainApp.getHelpTab()) {
            this.index = index;
            colourTab();
        }

    }

    /*
     * colourTab sets the highlight logic for the tab buttons, based on the
     * current tab in focus
     */
    private void colourTab() {
        for (int i = 0; i < NUMBER_BUTTONS; ++i) {
            Button currentButton = buttonArray[i];
            currentButton.setStyle(STYLE_TAB_NORMAL);

            // Highlight if focused
            if (i == index - 1) {
                currentButton.setStyle(STYLE_TAB_FOCUSED);
            }
        }
    }

    /*
     * getMainApplication is an access function for the reference to main
     * application
     */
    public MainApp getMainApplication() {
        return mainApplication;
    }

    /*
     * getIndex returns the current tab number
     * 
     * @return int tabNumber
     * 
     */
    public int getIndex() {
        return index;
    }

    /*
     * getButtonIndex takes in a button and returns its position / page /
     * sequence number in the sidebar.
     * 
     * @param Button button
     * 
     * @return int index
     * 
     */
    private int getButtonIndex(Button button) {
        if (buttonHash.get(button) != null) {
            return buttonHash.get(button);
        } else {
            return -1;
        }
    }

    /*
     * getTabName returns the tab name given its sequence or index number
     * 
     * @param int indexNumber
     * 
     * @return String tabName
     * 
     */
    public String getTabName(int indexNumber) {
        switch (indexNumber) {
        case 1:
            return "ALL";
        case 2:
            return "EXPIRED";
        case 3:
            return "TODAY";
        case 4:
            return "WEEK";
        case 5:
            return "DONE";
        case 6:
            return "OPTIONS";
        case 7:
            return "HELP";
        default:
            return "UNKNOWN";
        }
    }

    /* 
     * linkBubbles takes in a few controllers, counts and displays the number of ongoing tasks for the tab under each controller's control.
     * 
     * @param MainViewController[] controllers
     * 
     */
    public void linkBubbles(MainViewController[] controllers) {
        // Bubble Array
        Label[] bubbles = { allBubble, expiredBubble, todayBubble, weekBubble, doneBubble };

        // Visit the display list of every controller
        for (int i = 0; i < controllers.length; ++i) {
            
            // Get current controller
            MainViewController controller = controllers[i];

            // Only obtain filtered list if the controller is initialised
            if (controller != null) {
                ObservableList<TaskWrapper> taskList = controller.getTaskListView().getItems();
                FilteredList<TaskWrapper> incompleteTaskList = new FilteredList<TaskWrapper>(
                        taskList, task -> !task.getIsCompleted());
                StringProperty bubbleIndex = bubbles[i].textProperty();
                bubbleIndex.bind(Bindings.format(BUBBLE_COUNT, Bindings.size(incompleteTaskList)));
                
            }
            
            // Hide if the count is zero
            if (Integer.parseInt(bubbles[i].getText()) == 0) {
                bubbles[i].setVisible(false);
            } else {
                bubbles[i].setVisible(true);
            }
        }
    }
}
```
###### /todolist/ui/controllers/TaskNodeController.java
``` java

/*
 * TaskNodeController controls and manipulates data for display in task view(s).
 * 
 * @author Huang Lie Jun (A0123994W)
 * 
 */
public class TaskNodeController {

    // Defaults and Tags
    private static final int HOURS_PER_DAY = 24;
    private static final Font FONT_RELATIVE_DESCRIPTOR = Font.font("Calibri", FontPosture.ITALIC, 14);
    private static final String TAG_DEADLINE_DUE = "deadline due ";
    private static final String TAG_REPLACE_FROM_NOW = "from now";
    private static final String TAG_ENDED = "ended ";
    private static final String TAG_ENDS = "ends in %1$s";
    private static final String TAG_STARTED = "event started ";
    private static final String TAG_LONG = "%1$slong";
    private static final String TAG_EVENT_STARTS = "event starts ";
    private static final String TAG_EMPTY = "";
    private static final String TAG_AD_HOC = "ad-hoc task";
    private static final String TAG_ANYTIME = "Anytime";
    private static final String TAG_NOT_AVAILABLE = "Not Available";
    
    /*** STATIC MESSAGES ***/

    // ERRORS
    private static final String ERROR_DISPLAY_ITEM_INDEX = "Task Display: Index number out of bounds.";
    private static final String ERROR_DISPLAY_ITEM_TITLE = "Task Display: Task title invalid.";

    // DEFAULTS
    private static final String NULL_DISPLAY_ITEM_CATEGORY = "uncategorised";
    private static final String DISPLAY_ITEM_UNARCHIVED = "ONGOING";
    private static final String DISPLAY_ITEM_ARCHIVED = "DONE";
    private static final String DISPLAY_ITEM_OVERDUE = "OVERDUE";
    private static final String DISPLAY_ITEM_HEADER_CATEGORY = TAG_EMPTY;
    private static final String COMPLETED_RELATIVE = "completed!";

    /*** STYLES ***/

    // MONTHS
    private static final String[] months = { TAG_EMPTY, "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct",
            "Nov", "Dec" };

    // COLORS
    private static final String[] colorsHex = { "#27E1CE", "#D6EC78", "#FF98DA", "#FA7E0A", "#7A8CF0", "#A45FE6",
            "#F4722B", "#B3A78C", "#AA3763", "#6078EA", "#FA5555", "#F7FB76", "#F98B60", "#FFC057", "#B64926",
            "#468966", "#7BC74D", "#A97555", "#6639A6", "#F6C90E", "#BEEB9F", "#FCC29A", "#C83B3B", "#537780",
            "#88304E", "#7AA5D2", "#A75265", "#57385C", "#F66095", "#D6C8FF", "#C79ECF", "#7E6BC4", "#ABD4C1",
            "#7E858B" };

    // TASK TYPE STYLE
    private static final String COLOR_FLOATING = "#3BB873";
    private static final String COLOR_DEADLINE = "#FF6464";
    private static final String COLOR_EVENT = "#F3825F";

    // TASK OVERDUE STYLE
    private static final String COLOR_OVERDUE = "#FF6464";
    private static final String COLOR_TODAY = "#FAAC64";
    private static final String COLOR_SPARE = "#A4D792";

    // TASK COMPLETION STYLE
    private static final String COLOR_COMPLETE = "#5BE7A9";
    private static final String COLOR_INCOMPLETE = "#FAAC64";

    // UNKNOWN STYLE
    private static final String COLOR_UNKNOWN = "#748B9C";

    // Logger and Logger messages
    UtilityLogger logger = null;

    /*** TASK ITEM COMPONENTS ***/

    // Task model
    private TaskWrapper task = null;

    // Task index number
    private int index = -1;

    // Task types
    private static enum TASK_TYPE {
        FLOAT, DEADLINE, EVENT, OTHER
    };

    // Base
    @FXML
    private HBox root = null;

    // Priority
    @FXML
    private Rectangle priorityLabel = null;

    // Index
    @FXML
    private StackPane numberLabel = null;
    @FXML
    private Circle numLabelBase = null;
    @FXML
    private Label number = null;

    // Content
    @FXML
    private VBox details = null;

    // Content-TITLE+REMINDER
    @FXML
    private HBox titleBox = null;
    @FXML
    private Text title = null;
    @FXML
    private TextFlow titleFlow = null;

    // Content-RELATIVE TIME
    @FXML
    private HBox relativeRangeBox = null;
    @FXML
    private Label relativeRange = null;

    // Content-DATE(S)
    @FXML
    private HBox dateRangeBox = null;
    @FXML
    private Circle dateRangeSprite = null;
    @FXML
    private Label dateRange = null;

    // Content-CATEGORY
    @FXML
    private HBox categoryBox = null;
    @FXML
    private Circle categorySprite = null;
    @FXML
    private Label category = null;

    // Content-ARCHIVE
    @FXML
    private StackPane completeStatus = null;
    @FXML
    private Rectangle statusBacking = null;
    @FXML
    private Label status = null;

    // Indicators
    @FXML
    private VBox indicatorsHolder = null;
    @FXML
    private ImageView recurringIndicator = null;
    @FXML
    private ImageView reminderIndicator = null;
    @FXML
    private Label recurInterval = null;

    // Date-Time Field Live Update Interval (in seconds)
    private static final int UPDATE_INTERVAL = 5;

    // Time Zone Offset (from UTC)
    private static final int ZONE_OFFSET = 8;

    /*
     * Constructor intializes task and index of task.
     */
    public TaskNodeController(TaskWrapper task, int index) throws IllegalArgumentException {
        logger = new UtilityLogger();
        FXMLLoader fxmlLoader = new FXMLLoader(MainApp.class.getResource(MainApp.DIRECTORY_TASKITEM));
        fxmlLoader.setController(this);

        this.task = task;
        this.index = index;

        try {
            fxmlLoader.load();
        } catch (IOException ioException) {
            throw new RuntimeException(ioException);
        }

        // Assignment TaskWrapper to HBox Layout
        try {
            validateAndFormatItem();
        } catch (IllegalArgumentException iae) {
            throw iae;
        }

    }

    /*
     * validateAndFormatItem checks the validity of the display content and
     * formats it for display.
     * 
     */
    public void validateAndFormatItem() throws IllegalArgumentException {
        int indexNumber = index + 1;

        String taskTitle = task.getTaskTitle();
        Category category = task.getCategory();
        Reminder reminder = task.getReminder();
        LocalDateTime startDateTime = task.getStartTime();
        LocalDateTime endDateTime = task.getEndTime();

        /** Preparation **/

        // Prepare to scale label height relative to text wrapping
        bindPriorityLabelHeight();

        /** Validate and theme **/

        // Ensure integrity of task object
        assert (task != null);

        // Index Number
        validateAndFormatIndexNumber(indexNumber);

        // Title
        validateAndFormatTitle(taskTitle);

        // Category
        validateAndFormatCategory(category);

        // Actively update date-time related fields and colors
        try {

            // Set up callback for date-time field updates
            KeyFrame updateFrame = new KeyFrame(javafx.util.Duration.ZERO, new EventHandler<ActionEvent>() {
                @Override
                public void handle(ActionEvent event) {
                    formatDateField(task, startDateTime, endDateTime);
                    // Archive Status
                    if (task.getIsCompleted()) {
                        setTaskStatusCompleted();
                    } else if (task.getIsExpired()) {
                        setTaskStatusExpired();
                    } else {
                        setTaskStatusOngoing();
                    }
                }

                private void setTaskStatusOngoing() {
                    statusBacking.setFill(Color.web(COLOR_INCOMPLETE));
                    status.setText(DISPLAY_ITEM_UNARCHIVED);
                }

                private void setTaskStatusExpired() {
                    statusBacking.setFill(Color.web(COLOR_OVERDUE));
                    status.setText(DISPLAY_ITEM_OVERDUE);
                }

                private void setTaskStatusCompleted() {
                    statusBacking.setFill(Color.web(COLOR_COMPLETE));
                    status.setText(DISPLAY_ITEM_ARCHIVED);
                }
            });

            // Set up pause interval
            KeyFrame intervalFrame = new KeyFrame(javafx.util.Duration.seconds(UPDATE_INTERVAL));

            // Run update on separate thread(s)
            updateDateTimeThreaded(updateFrame, intervalFrame);

        } catch (IllegalArgumentException iae) {
            throw iae;
        }

        // Recurring Status
        setRecurringStatus();

        // Reminder Status
        setReminderStatus(reminder);
    }

    /*
     * updateDateTimeThreaded is a busy update function that will animate the two given frames infinitely.
     * The first frame contains a callback function that will update the date-time related fields accordingly.
     * (Not the most efficient)
     * 
     * @param KeyFrame updateFrame, KeyFrame intervalFrame
     * 
     */
    private void updateDateTimeThreaded(KeyFrame updateFrame, KeyFrame intervalFrame) {
        Timeline timeline = new Timeline(updateFrame, intervalFrame);
        timeline.setCycleCount(Animation.INDEFINITE);
        timeline.play();
    }

    /*
     * ValidateAndFormatCategory will take in a category and format the category field accordingly.
     * 
     * @param Category category
     * 
     */
    private void validateAndFormatCategory(Category category) {
        String categoryName;
        if (category == null) {
            categoryName = new String(NULL_DISPLAY_ITEM_CATEGORY);
            categorySprite.setFill(Color.web(COLOR_UNKNOWN));
        } else {
            categoryName = DISPLAY_ITEM_HEADER_CATEGORY + category.getCategory();
            Color categoryHexColor = getColorForCategory(categoryName);
            categorySprite.setFill(categoryHexColor);
        }
        this.category.setText(categoryName);
    }

    /*
     * validateAndFormatTitle will take in a title and format the title field accordingly.
     * 
     * @param String taskTitle
     * 
     */
    private void validateAndFormatTitle(String taskTitle) {
        
        // Synchronize title color with index number color
        title.fillProperty().bind(number.textFillProperty());
        
        if (taskTitle == null) {
            logger.logError(UtilityLogger.Component.UI, ERROR_DISPLAY_ITEM_TITLE);
            throw new IllegalArgumentException(ERROR_DISPLAY_ITEM_TITLE);
        } else {
            title.setText(taskTitle);
        }
    }

    /*
     * validateAndFormatIndexNumber will take in an index and format the index field accordingly.
     * 
     * @param int indexNumber
     * 
     */
    private void validateAndFormatIndexNumber(int indexNumber) {
        if (indexNumber <= 0) {
            logger.logError(UtilityLogger.Component.UI, ERROR_DISPLAY_ITEM_INDEX);
            throw new IllegalArgumentException(ERROR_DISPLAY_ITEM_INDEX);
        } else {
            number.setText(Integer.toString(indexNumber));
        }
    }

    /*
     * setReminderStatus will take in a reminder and format the reminder flag indicator accordingly.
     * 
     * @param Reminder reminder
     * 
     */
    private void setReminderStatus(Reminder reminder) {
        if (reminder == null) {
            reminderIndicator.setVisible(false);
        } else {
            reminderIndicator.setVisible(reminder.getStatus());
        }
    }

    /*
     * setRecurringStatus will check if a task is recurring and toggle the recurrence flag indicator accordingly.
     * 
     */
    private void setRecurringStatus() {
        recurringIndicator.setVisible(task.getIsRecurring());
        recurInterval.setText(task.getInterval());
    }

    /*
     * getColorForCategory will calculate a color index and return a color that expresses the category name.
     * 
     * @param String categoryName
     * 
     * @return Color categoryColor
     * 
     */
    private Color getColorForCategory(String categoryName) {
        int hashModColorIndex = Math.abs(categoryName.hashCode()) % colorsHex.length;
        String colorDescriptor = colorsHex[hashModColorIndex];
        Color categoryHexColor = Color.web(colorDescriptor);
        return categoryHexColor;
    }

    /*
     * bindPriorityLabelHeight binds the priority label to the node height loosely. (Still experimental)
     * 
     */
    private void bindPriorityLabelHeight() {
        DoubleBinding categoryWithOffsetHeight = categoryBox.heightProperty().add(16);
        DoubleBinding categoryAndDateWithOffsetHeight = dateRangeBox.heightProperty().add(categoryWithOffsetHeight);
        ObservableNumberValue categoryAndDateAndTitleWithOffset = relativeRangeBox.heightProperty()
                .add(categoryAndDateWithOffsetHeight);
        DoubleBinding totalInfoFieldHeight = titleFlow.heightProperty().add(categoryAndDateAndTitleWithOffset);

        // Binding
        priorityLabel.heightProperty().bind(totalInfoFieldHeight);
    }

    /*
     * getNode returns the formatted task view for display.
     * 
     * @return HBox getNode
     */
    public HBox getNode() {
        return root;
    }

    /*
     * formatDateField takes in a task, start date-time, end date-time to format
     * date range field for display.
     * 
     * @param TaskWrapper task, LocalDateTime startDateTime, LocalDateTime
     * endDateTime
     * 
     * @return String dateTimeField
     */
    public void formatDateField(TaskWrapper task, LocalDateTime startDateTime, LocalDateTime endDateTime) {
        TASK_TYPE taskType = checkTaskType(startDateTime, endDateTime);
        String outputDate = TAG_EMPTY;
        String relativeText = TAG_AD_HOC;

        switch (taskType) {

        case FLOAT:
            outputDate = TAG_ANYTIME;
            break;
        case DEADLINE:
            // Formatting of deadline date
            outputDate = formatDeadlineRange(endDateTime);            
            //  Set relative descriptor
            relativeText = formatDeadlineRelativeText(endDateTime);
            break;
        case EVENT:            
            // Smart formatting of range for same-day events
            if (isSameDay(startDateTime, endDateTime)) {
                outputDate = formatEventRangeSameDay(startDateTime, endDateTime);
            // Normal formatting of range for multi-day events
            } else {
                outputDate = formatEventRangeDiffDay(startDateTime, endDateTime);
            }            
            // Set relative descriptor
            relativeText = formatEventRelativeText(startDateTime, endDateTime);
            
            break;
        default:
            // Formatting of date-time range for unknown types
            outputDate = TAG_NOT_AVAILABLE;
        }

        // Set styles
        setDateTimeRelStyle(startDateTime, endDateTime, task.getIsCompleted());

        if (task.getIsCompleted()) {
            relativeText = COMPLETED_RELATIVE;
        }
        setDateTimeRelativeFields(outputDate, relativeText);
    }

    /*
     * setDateTimeRelativeFields takes in an outputDate and relative text and sets the flag accordingly
     * 
     * @param String outputDate, String relativeText
     * 
     */
    private void setDateTimeRelativeFields(String outputDate, String relativeText) {
        this.relativeRange.setText(relativeText);
        dateRange.setText(outputDate);
        this.relativeRange.setFont(FONT_RELATIVE_DESCRIPTOR);
    }

    /*
     * isSameDay takes in a start and end date-time and checks if the start and end date-time falls on the same day 
     * 
     * @param LocalDateTime startDateTime, LocalDateTime endDateTime
     * 
     */
    private boolean isSameDay(LocalDateTime startDateTime, LocalDateTime endDateTime) {
        return startDateTime.getDayOfYear() == endDateTime.getDayOfYear()
                && startDateTime.getYear() == endDateTime.getYear();
    }

    /*
     * checkTaskType takes in the start date-time and end date-time to determine
     * the task type.
     * 
     * @param LocalDateTime startDateTime, LocalDateTime endDateTime
     * 
     * @return TASK_TYPE
     * 
     */
    private TASK_TYPE checkTaskType(LocalDateTime startDateTime, LocalDateTime endDateTime) {
        TASK_TYPE taskType;
        if (startDateTime != null && endDateTime != null) {
            taskType = TASK_TYPE.EVENT;
        } else if (startDateTime == null && endDateTime != null) {
            taskType = TASK_TYPE.DEADLINE;
        } else if (startDateTime == null && endDateTime == null) {
            taskType = TASK_TYPE.FLOAT;
        } else {
            taskType = TASK_TYPE.OTHER;
        }

        return taskType;
    }

    /** FORMATTING FUNCTIONS **/

    /*
     * formatEventRange
     * 
     * @param LocalDateTime startDateTime, LocalDateTime endDateTime
     * 
     * @return String eventRange
     */
    private String formatEventRelativeText(LocalDateTime startDateTime, LocalDateTime endDateTime) {

        // Output will consists of two parts: [start time reference] and
        // remaining time left
        String startOutput = null;
        String durationOutput = null;

        ZoneId defaultZoneId = ZoneId.of(ZoneOffset.systemDefault().getId());
        ZonedDateTime zoneDateTime = LocalDateTime.now().atZone(defaultZoneId);
        ZoneOffset zoneOffset = zoneDateTime.getOffset();

        // Type conversions for handling
        PrettyTime prettyParser = new PrettyTime();
        Instant startInstant = startDateTime.toInstant(zoneOffset);
        Date start = Date.from(startInstant);
        Instant endInstant = endDateTime.toInstant(zoneOffset);
        Date end = Date.from(endInstant);
        Instant nowInstant = LocalDateTime.now().toInstant(zoneOffset);
        Date now = Date.from(nowInstant);

        // Set output for the start of event
        startOutput = prettyParser.format(start);

        // String formatting
        String relativeStart = TAG_EVENT_STARTS;
        String relativeEnd = TAG_LONG;

        // Start reference date varies, depending if event has already begun
        if (hasStarted(startDateTime)) {
            prettyParser.setReference(now);
            relativeStart = TAG_STARTED;
            relativeEnd = TAG_ENDS;
        // Change point of reference if event has yet to start
        } else {
            prettyParser.setReference(start);
        }

        // End modifiers
        if (endDateTime.isBefore(LocalDateTime.now())) {
            relativeEnd = TAG_ENDED + prettyParser.format(end);
        }

        // Format PrettyTime output for display
        durationOutput = prettyParser.format(end).replace(TAG_REPLACE_FROM_NOW, TAG_EMPTY);

        // Format and display relative descriptor
        return relativeStart + startOutput + ", " + String.format(relativeEnd, durationOutput);
    }

    /*
     * formatDeadlineRange
     * 
     * @param LocalDateTime endDateTime
     * 
     * @return String deadlineRange
     */
    private String formatDeadlineRelativeText(LocalDateTime endDateTime) {

        PrettyTime prettyParser = new PrettyTime();

        Instant endInstant = endDateTime.toInstant(ZoneOffset.ofHours(ZONE_OFFSET));
        Date end = Date.from(endInstant);

        return TAG_DEADLINE_DUE + prettyParser.format(end);
    }

    /*
     * hasStarted checks if an event has already begun.
     * 
     * @param LocalDateTime startDateTime
     * 
     * @return boolean hasStarted
     */
    private boolean hasStarted(LocalDateTime startDateTime) {
        return LocalDateTime.now().isAfter(startDateTime);
    }

    /*
     * formatEventRangeDiffDay formats the date-time range for events with start
     * and end date-times on different days
     * 
     * @param LocalDateTime startDateTime, LocalDateTime endDateTime
     * 
     * @return String dateTimeRange
     */
    private String formatEventRangeDiffDay(LocalDateTime startDateTime, LocalDateTime endDateTime) {
        return startDateTime.getDayOfMonth() 
                + "-" 
                + months[startDateTime.getMonthValue()] 
                + "-"
                + startDateTime.getYear() 
                + ", "
                + startDateTime.format(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT)) 
                + " to "
                + endDateTime.getDayOfMonth() 
                + "-" 
                + months[endDateTime.getMonthValue()] 
                + "-" 
                + endDateTime.getYear()
                + ", " 
                + endDateTime.format(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT));
    }

    /*
     * formatEventRangeSameDay formats the date-time range for events with start
     * and end date-times on the same day
     * 
     * @param LocalDateTime startDateTime, LocalDateTime endDateTime
     * 
     * @return String dateTimeRange
     */
    private String formatEventRangeSameDay(LocalDateTime startDateTime, LocalDateTime endDateTime) {
        return startDateTime.getDayOfMonth() 
                + "-" 
                + months[startDateTime.getMonthValue()] 
                + "-"
                + startDateTime.getYear() 
                + ", "
                + startDateTime.format(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT)) 
                + " to "
                + endDateTime.format(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT));
    }

    /*
     * formatDeadlineRange formats the date-time range for deadlines
     * 
     * @param LocalDateTime endDateTime
     * 
     * @return String dateTimeRange
     */
    private String formatDeadlineRange(LocalDateTime endDateTime) {
        return endDateTime.getDayOfMonth() 
                + "-" 
                + months[endDateTime.getMonthValue()] 
                + "-" 
                + endDateTime.getYear()
                + ", " 
                + endDateTime.format(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT));
    }

    /** STYLING FUNCTIONS **/

    /*
     * Apply styles on unknown task type
     * 
     */
    @SuppressWarnings("unused")
    private void styleUnknown() {
        numLabelBase.setFill(Color.web(COLOR_UNKNOWN));
    }

    /*
     * Apply styles on event task type
     * 
     * @param LocalDateTime startDateTime
     * 
     */
    @SuppressWarnings("unused")
    private void styleEvent(LocalDateTime startDateTime) {
        numLabelBase.setFill(Color.web(COLOR_EVENT));

        if (startDateTime.isBefore(LocalDateTime.now())) {
            priorityLabel.setFill(Color.web(COLOR_OVERDUE));
        } else if (ChronoUnit.HOURS.between(LocalDateTime.now(), startDateTime) <= HOURS_PER_DAY) {
            priorityLabel.setFill(Color.web(COLOR_TODAY));
        } else {
            priorityLabel.setFill(Color.web(COLOR_SPARE));
        }
    }

    /*
     * Apply styles on deadline task type
     * 
     * @param LocalDateTime endDateTime
     */
    @SuppressWarnings("unused")
    private void styleDeadline(LocalDateTime endDateTime) {
        numLabelBase.setFill(Color.web(COLOR_DEADLINE));

        if (endDateTime.isBefore(LocalDateTime.now())) {
            priorityLabel.setFill(Color.web(COLOR_OVERDUE));
        } else if (ChronoUnit.HOURS.between(LocalDateTime.now(), endDateTime) <= HOURS_PER_DAY) {
            priorityLabel.setFill(Color.web(COLOR_TODAY));
        } else {
            priorityLabel.setFill(Color.web(COLOR_SPARE));
        }
    }

    /*
     * Apply styles on floating task type
     */
    @SuppressWarnings("unused")
    private void styleFloatingTask() {
        numLabelBase.setFill(Color.web(COLOR_FLOATING));
        priorityLabel.setFill(Color.web(COLOR_SPARE));
    }

    /*
     * Apply styles on task
     * 
     * @param LocalDateTime startDateTime, LocalDateTime endDateTime, boolean
     * isCompleted
     * 
     */
    private void setDateTimeRelStyle(LocalDateTime startDateTime, LocalDateTime endDateTime, boolean isCompleted) {

        // Overdue Priority
        if (isOverdue(endDateTime, isCompleted)) {
            numLabelBase.setFill(Color.web(COLOR_OVERDUE));
            priorityLabel.setFill(Color.web(COLOR_OVERDUE));
        // Today Priority
        } else if (isToday(endDateTime, isCompleted)) {
            numLabelBase.setFill(Color.web(COLOR_TODAY));
            priorityLabel.setFill(Color.web(COLOR_TODAY));
        // Normal Priority
        } else {
            numLabelBase.setFill(Color.web(COLOR_SPARE));
            priorityLabel.setFill(Color.web(COLOR_SPARE));
        }

    }

    /*
     * isToday checks if the current task is an ongoing task due today
     * 
     * @param LocalDateTime endDateTime, boolean isCompleted
     * 
     * @return boolean isToday
     * 
     */
    private boolean isToday(LocalDateTime endDateTime, boolean isCompleted) {
        return endDateTime != null && ChronoUnit.HOURS.between(LocalDateTime.now(), endDateTime) <= 24
                && !isCompleted;
    }

    /*
     * isOverdue checks if the current task is an expired task due before today
     * 
     * @param LocalDateTime endDateTime, boolean isCompleted
     * 
     * @return boolean isOverdue
     */
    private boolean isOverdue(LocalDateTime endDateTime, boolean isCompleted) {
        return endDateTime != null && endDateTime.isBefore(LocalDateTime.now()) && !isCompleted;
    }
}
```
###### /todolist/ui/controllers/TodayController.java
``` java

/* 
 * TodayController controls and manipulates data for display on the main display area, for the today tab.
 * 
 * @author Huang Lie Jun (A0123994W)
 */
public class TodayController extends MainViewController {

    // Logger messages
    private static final String MESSAGE_UPDATED_TODAY_TASKLIST = "Updated display task list [TODAY].";

    /*
     * Constructor overrides super constructor and intializes the display task
     * list and list view.
     * 
     */
    public TodayController() {
        // Initialise models
        tasksToDisplay = FXCollections.observableArrayList();
        listView = new ListView<TaskWrapper>();
    }

    /*
     * (non-Javadoc)
     * 
     * @see todolist.ui.controllers.MainViewController#initialize()
     */
    @FXML
    public void initialize() {
        initTaskListView();
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * todolist.ui.controllers.MainViewController#setTasks(java.util.ArrayList)
     */
    @Override
    public void setTasks(ArrayList<Task> tasks) {

        // List provided by logic must be valid
        assert (tasks != null);

        // Prepare to load new list of tasks
        ArrayList<TaskWrapper> arrayOfWrappers = new ArrayList<TaskWrapper>();
        listView.getItems().clear();

        // Convert Task to TaskWrapper for display handling
        for (int i = 0; i < tasks.size(); ++i) {
            Task task = tasks.get(i);
            if (isToday(task) && !isCompleted(task)) {
                TaskWrapper wrappedTask = new TaskWrapper(tasks.get(i));
                arrayOfWrappers.add(wrappedTask);
            }
        }

        // Load up updated list of tasks
        listView.getItems().addAll(arrayOfWrappers);
        logger.logAction(Component.UI, MESSAGE_UPDATED_TODAY_TASKLIST);

    }

    /*
     * isToday is a utility function that checks if a given task is due today.
     * 
     * @param Task task is the given task to check
     * 
     * @return boolean isToday
     * 
     */
    private boolean isToday(Task task) {
        return task.getEndTime() != null 
                && task.getEndTime().getYear() == LocalDateTime.now().getYear()
                && task.getEndTime().getDayOfYear() == LocalDateTime.now().getDayOfYear();
    }
}
```
###### /todolist/ui/controllers/WeekController.java
``` java

/* 
 * WeekController controls and manipulates data for display on the main display area, for the week tab.
 * 
 * @author Huang Lie Jun (A0123994W)
 */
public class WeekController extends MainViewController {

    // Logger messages
    private static final String MESSAGE_UPDATED_WEEK_TASKLIST = "Updated display task list [WEEK].";

    /*
     * Constructor overrides super constructor and intializes the display task
     * list and list view.
     * 
     */
    public WeekController() {
        // Initialise models
        tasksToDisplay = FXCollections.observableArrayList();
        listView = new ListView<TaskWrapper>();
    }

    /*
     * (non-Javadoc)
     * 
     * @see todolist.ui.controllers.MainViewController#initialize()
     */
    @FXML
    public void initialize() {
        initTaskListView();
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * todolist.ui.controllers.MainViewController#setTasks(java.util.ArrayList)
     */
    @Override
    public void setTasks(ArrayList<Task> tasks) {

        // List provided by logic must be valid
        assert (tasks != null);

        // Prepare to load updated list of tasks
        ArrayList<TaskWrapper> arrayOfWrappers = new ArrayList<TaskWrapper>();
        listView.getItems().clear();

        // Convert Task to TaskWrapper for display handling
        for (int i = 0; i < tasks.size(); ++i) {
            Task task = tasks.get(i);
            // To qualify, task must be within current week and ongoing
            if (isWithinWeek(task) && !isCompleted(task)) {
                TaskWrapper wrappedTask = new TaskWrapper(tasks.get(i));
                arrayOfWrappers.add(wrappedTask);
            }
        }

        // Load up new list to model
        listView.getItems().addAll(arrayOfWrappers);
        logger.logAction(Component.UI, MESSAGE_UPDATED_WEEK_TASKLIST);
    }

    /*
     * isWithinWeek takes in a task to determine if the end date-time of the
     * task is within 7-days from today
     * 
     * @param Task task is the task provided for checking
     * 
     * @return boolean isWithinWeek
     */
    private boolean isWithinWeek(Task task) {
        return task.getEndTime() != null && LocalDateTime.now().until(task.getEndTime(), ChronoUnit.DAYS) <= 7;
    }
}
```
###### /todolist/ui/TaskListCell.java
``` java

/*
 * TaskListCell formats task views by assigning every task node to a controller.
 * 
 * @author Huang Lie Jun (A0123994W)
 * 
 */
public class TaskListCell extends ListCell<TaskWrapper> {

    /*
     * (non-Javadoc)
     * 
     * @see javafx.scene.control.Cell#updateItem(java.lang.Object, boolean)
     */
    @Override
    public void updateItem(TaskWrapper task, boolean empty) throws IllegalArgumentException {
        // Only displays tasks if they are not empty
        if (task != null) {
            super.updateItem(task, empty);

            // Link task to graphic node
            try {
                
                TaskNodeController taskNode = new TaskNodeController(task, this.getIndex());
                setGraphic(taskNode.getNode());
            } catch (IllegalArgumentException iae) {
                iae.printStackTrace();
                throw iae;
            }
        } else {
            nullifyItem();
        }
    }

    /*
     * nullifyItem hides empty task views.
     */
    private void nullifyItem() {
        setText(null);
        setGraphic(null);
    }
}
```
###### /todolist/ui/TaskWrapper.java
``` java

/*
 * TaskWrapper is the wrapper class for Task class. It wraps each attribute into a property for display.
 * 
 * @author Huang Lie Jun (A0123994W)
 * 
 */
public class TaskWrapper {

    private Task task;
    private StringProperty taskTitle;
    private ObjectProperty<LocalDateTime> startTime;
    private ObjectProperty<LocalDateTime> endTime;
    private ObjectProperty<Category> category;
    private ObjectProperty<Reminder> reminder;
    private ObjectProperty<Boolean> isDone;
    private ObjectProperty<Boolean> isRecurring;
    private ObjectProperty<String> interval;

    /*
     * Constructor builds the TaskWrapper class with the given task.
     * 
     * @param Task task is the task being wrapped around
     * 
     */
    public TaskWrapper(Task task) {
        this.taskTitle = new SimpleStringProperty(task.getName().getName());
        this.startTime = new SimpleObjectProperty<LocalDateTime>(task.getStartTime());
        this.endTime = new SimpleObjectProperty<LocalDateTime>(task.getEndTime());
        this.category = new SimpleObjectProperty<Category>(task.getCategory());
        this.reminder = new SimpleObjectProperty<Reminder>(task.getReminder());
        this.isDone = new SimpleObjectProperty<Boolean>(task.getDoneStatus());
        this.isRecurring = new SimpleObjectProperty<Boolean>(task.getRecurringStatus());
        this.interval = new SimpleObjectProperty<String>(task.getInterval());
        this.task = task;
    }

    /*** GETTER-SETTER FUNCTIONS ***/

    /*
     * getTaskTitleProperty returns the string property of the title.
     * 
     * @return StringProperty taskTitle
     */
    public StringProperty getTaskTitleProperty() {
        return taskTitle;
    }

    /*
     * setTaskTitle takes in a string and sets it as the task title.
     * 
     * @param String taskTitle
     */
    public void setTaskTitle(String taskTitle) {
        this.taskTitle.set(taskTitle);
    }

    /*
     * getTaskTitle returns the task title.
     * 
     * @return String taskTitle
     */
    public String getTaskTitle() {
        return taskTitle.get();
    }

    /*
     * getStartTimeProperty returns the property of the start time.
     * 
     * @return ObjectProperty<LocalDateTime> startTime
     */
    public ObjectProperty<LocalDateTime> getStartTimeProperty() {
        return startTime;
    }

    /*
     * setStartTime sets the given startTime as the task start time.
     * 
     * @param LocalDateTime startTime
     */
    public void setStartTime(LocalDateTime startTime) {
        this.startTime.set(startTime);
    }

    /*
     * getStartTime returns the task start time.
     * 
     * @return LocalDateTime startTime
     * 
     */
    public LocalDateTime getStartTime() {
        return startTime.get();
    }

    /*
     * getEndTimeProperty returns the property of the end time.
     * 
     * @return ObjectProperty<LocalDateTime> endTime
     */
    public ObjectProperty<LocalDateTime> getEndTimeProperty() {
        return endTime;
    }

    /*
     * setEndTime sets the given endTime as the task end time.
     * 
     * @param LocalDateTime endTime
     */
    public void setEndTime(LocalDateTime endTime) {
        this.endTime.set(endTime);
    }

    /*
     * getEndTime returns the task end time.
     * 
     * @return LocalDateTime endTime
     * 
     */
    public LocalDateTime getEndTime() {
        return endTime.get();
    }

    /*
     * getCategoryProperty returns the property of the category.
     * 
     * @return ObjectProperty<Category> category
     */
    public ObjectProperty<Category> getCategoryProperty() {
        return category;
    }

    /*
     * setCategory sets the task category as the given category.
     * 
     * @param Category category
     * 
     */
    public void setCategory(Category category) {
        this.category.set(category);
    }

    /*
     * getCategory returns the category of the task.
     * 
     * @return Category category
     * 
     */
    public Category getCategory() {
        return category.get();
    }

    /*
     * getReminderProperty returns the property of the reminder.
     * 
     * @return ObjectProperty<Reminder> reminder
     */
    public ObjectProperty<Reminder> getReminderProperty() {
        return reminder;
    }

    /*
     * setReminder sets the task reminder as the given reminder.
     * 
     * @param Reminder reminder
     * 
     */
    public void setReminder(Reminder reminder) {
        this.reminder.set(reminder);
    }

    /*
     * getReminder returns the task reminder.
     * 
     * @return Reminder reminder
     * 
     */
    public Reminder getReminder() {
        return reminder.get();
    }

    /*
     * getIsCompletedProperty returns the property of the completion status.
     * 
     * @return ObjectProperty<Boolean> isDone
     */
    public ObjectProperty<Boolean> getIsCompletedProperty() {
        return isDone;
    }

    /*
     * setIsCompleted sets the completion status of the task.
     * 
     * @param ObjectProperty<Boolean> isDone
     */
    public void setIsCompleted(ObjectProperty<Boolean> isDone) {
        this.isDone = isDone;
    }

    /*
     * getIsCompleted returns the completion status of the task.
     * 
     * @return Boolean isDone
     */
    public Boolean getIsCompleted() {
        return isDone.get();
    }

    /*
     * getRecurringStatusProperty returns the property of the recurrence status.
     * 
     * @return ObjectProperty<Boolean> isRecurring
     */
    public ObjectProperty<Boolean> getRecurringStatusProperty() {
        return isRecurring;
    }

    /*
     * setIsRecurring sets the recurrence status of the task.
     * 
     * @param ObjectProperty<Boolean> isRecurring
     * 
     */
    public void setIsRecurring(ObjectProperty<Boolean> isRecurring) {
        this.isRecurring = isRecurring;
    }

    /*
     * getIsRecurring returns the recurrence status of the task.
     * 
     * @return Boolean isRecurring
     */
    public Boolean getIsRecurring() {
        return isRecurring.get();
    }

    /*
     * getIntervalProperty returns the property of the recurrence interval.
     * 
     * @return ObjectProperty<String> interval
     */
    public ObjectProperty<String> getIntervalProperty() {
        return interval;
    }

    /*
     * setInterval sets the recurrence interval of the task.
     * 
     * @param ObjectProperty<String> interval
     * 
     */
    public void setInterval(ObjectProperty<String> interval) {
        this.interval = interval;
    }

    /*
     * getInterval returns the recurrence interval of the task.
     * 
     * @return String interval
     * 
     */
    public String getInterval() {
        return interval.get();
    }

    /*
     * getTaskObject returns the task object reference.
     * 
     * @return Task task
     * 
     */
    public Task getTaskObject() {
        return task;
    }

    public boolean getIsExpired() {
        return getEndTime() != null && getEndTime().isBefore(LocalDateTime.now());
    }
    
    public enum TaskType {
        EVENT, DEADLINE, FLOATING, UNKNOWN
    };
    
    public TaskType getTaskType() {
        if(getStartTime() != null && getEndTime() != null) {
            return TaskType.EVENT;
        } else if (getStartTime() == null && getEndTime() != null) {
            return TaskType.DEADLINE;
        } else if (getStartTime() == null && getEndTime() == null) {
            return TaskType.FLOATING;
        } else {
            return TaskType.UNKNOWN;
        }
    }
}
```
###### /todolist/ui/views/ArchiveView.fxml
``` fxml

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.control.TitledPane?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.text.Text?>

<BorderPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
	minHeight="300.0" minWidth="300.0" prefHeight="540.0" prefWidth="740.0"
	xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1"
	fx:controller="todolist.ui.controllers.ArchiveController">
	<center>
		<TitledPane alignment="CENTER" animated="false"
			collapsible="false" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
			BorderPane.alignment="TOP_CENTER">
			<content>
				<ListView fx:id="listView" prefHeight="200.0" prefWidth="200.0">
					<placeholder>
						<Label style="-fx-font-weight: bold;" text="no completed tasks yet! get working now!" />
					</placeholder>
					<opaqueInsets>
						<Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
					</opaqueInsets>
					<padding>
						<Insets bottom="5.0" />
					</padding>
				</ListView>
			</content>
			<graphic>
				<HBox id="titled-pane-hbox" alignment="CENTER" maxHeight="1.7976931348623157E308"
					maxWidth="1.7976931348623157E308" spacing="10.0">
					<children>
						<Text id="titled-pane-hbox-text" fontSmoothingType="LCD"
							strokeType="OUTSIDE" strokeWidth="0.0" style="-fx-font-weight: bold;"
							text="completed tasks" textAlignment="CENTER" />
					</children>
				</HBox>
			</graphic>
		</TitledPane>
	</center>
</BorderPane>
```
###### /todolist/ui/views/EmptyView.fxml
``` fxml

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.control.TitledPane?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.text.Text?>

<BorderPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
	minHeight="300.0" minWidth="300.0" prefHeight="540.0" prefWidth="740.0"
	xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1"
	fx:controller="todolist.ui.controllers.MainViewController">
	<center>
		<TitledPane alignment="CENTER" animated="false"
			collapsible="false" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
			BorderPane.alignment="TOP_CENTER">
			<content>
				<ListView fx:id="listView" prefHeight="200.0" prefWidth="200.0">
					<placeholder>
						<Label text="THIS IS AN EMPTY VIEW" />
					</placeholder>
					<opaqueInsets>
						<Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
					</opaqueInsets>
					<padding>
						<Insets bottom="5.0" />
					</padding>
				</ListView>
			</content>
			<graphic>
				<HBox id="titled-pane-hbox" alignment="CENTER" maxHeight="1.7976931348623157E308"
					maxWidth="1.7976931348623157E308" spacing="10.0">
					<children>
						<Text id="titled-pane-hbox-text" fontSmoothingType="LCD"
							strokeType="OUTSIDE" strokeWidth="0.0" style="-fx-font-weight: bold;"
							text="empty view" textAlignment="CENTER" />
					</children>
				</HBox>
			</graphic>
		</TitledPane>
	</center>
</BorderPane>
```
###### /todolist/ui/views/HelpView.fxml
``` fxml

<?import javafx.scene.control.TableColumn?>
<?import javafx.scene.control.TableView?>
<?import javafx.scene.layout.BorderPane?>

<BorderPane id="table-view" maxHeight="1.7976931348623157E308"
	maxWidth="1.7976931348623157E308" prefHeight="200.0" prefWidth="1250"
	styleClass="table-view" xmlns="http://javafx.com/javafx/8.0.65"
	xmlns:fx="http://javafx.com/fxml/1" fx:controller="todolist.ui.controllers.HelpModalController">
	<center>
		<TableView id="helpTable" fx:id="helpTable"
			focusTraversable="false" prefHeight="200.0" prefWidth="1200.0"
			BorderPane.alignment="CENTER">
			<columns>
				<TableColumn fx:id="commandColumn" maxWidth="1.7976931348623157E308"
					prefWidth="500.0" text="Command" />
				<TableColumn fx:id="formatColumn" maxWidth="1.7976931348623157E308"
					prefWidth="700.0" text="Format" />
			</columns>
		</TableView>
	</center>
</BorderPane>
```
###### /todolist/ui/views/MainView.fxml
``` fxml

<?import java.lang.String?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.control.TitledPane?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.text.Font?>
<?import javafx.scene.text.Text?>

<BorderPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
	minHeight="300.0" minWidth="300.0" prefHeight="540.0" prefWidth="740.0"
	xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1"
	fx:controller="todolist.ui.controllers.MainViewController">
	<bottom>
		<TextField prefHeight="40.0" prefWidth="720.0"
			promptText="enter your command here ..." styleClass="text-field"
			BorderPane.alignment="TOP_LEFT">
			<font>
				<Font size="14.0" />
			</font>
			<BorderPane.margin>
				<Insets />
			</BorderPane.margin>
		</TextField>
	</bottom>
	<padding>
		<Insets left="6.0" top="6.0" />
	</padding>
	<styleClass>
		<String fx:value="main-view" />
		<String fx:value="split-pane" />
		<String fx:value="split-pane-divider" />
	</styleClass>
	<center>
		<TitledPane alignment="CENTER" animated="false"
			collapsible="false" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
			BorderPane.alignment="TOP_CENTER">
			<content>
				<ListView fx:id="listView" maxHeight="1.7976931348623157E308"
					prefHeight="200.0" prefWidth="200.0">
					<placeholder>
						<Label style="-fx-font-weight: bold;" text="not sure how to use me? enter 'help' !" />
					</placeholder>
					<opaqueInsets>
						<Insets left="5.0" right="5.0" top="5.0" />
					</opaqueInsets>
					<padding>
						<Insets bottom="5.0" />
					</padding>
				</ListView>
			</content>
			<graphic>
				<HBox id="titled-pane-hbox" alignment="CENTER" maxHeight="1.7976931348623157E308"
					maxWidth="1.7976931348623157E308" spacing="10.0">
					<children>
						<Text id="titled-pane-hbox-text" fontSmoothingType="LCD"
							strokeType="OUTSIDE" strokeWidth="0.0" style="-fx-font-weight: bold;"
							text="all ongoing tasks" textAlignment="CENTER" />
					</children>
				</HBox>
			</graphic>
		</TitledPane>
	</center>
</BorderPane>
```
###### /todolist/ui/views/OverdueView.fxml
``` fxml

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.control.TitledPane?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.text.Text?>

<BorderPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
	minHeight="300.0" minWidth="300.0" prefHeight="540.0" prefWidth="740.0"
	xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1"
	fx:controller="todolist.ui.controllers.OverdueController">
	<center>
		<TitledPane alignment="CENTER" animated="false"
			collapsible="false" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
			BorderPane.alignment="TOP_CENTER">
			<content>
				<ListView fx:id="listView" prefHeight="200.0" prefWidth="200.0">
					<placeholder>
						<Label style="-fx-font-weight: bold;"
							text="you are right on schedule! no overdues! hooray!" />
					</placeholder>
					<opaqueInsets>
						<Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
					</opaqueInsets>
					<padding>
						<Insets bottom="5.0" />
					</padding>
				</ListView>
			</content>
			<graphic>
				<HBox id="titled-pane-hbox" alignment="CENTER" maxHeight="1.7976931348623157E308"
					maxWidth="1.7976931348623157E308" spacing="10.0">
					<children>
						<Text id="titled-pane-hbox-text" fontSmoothingType="LCD"
							strokeType="OUTSIDE" strokeWidth="0.0" style="-fx-font-weight: bold;"
							text="overdue tasks" textAlignment="CENTER" />
					</children>
				</HBox>
			</graphic>
		</TitledPane>
	</center>
</BorderPane>
```
###### /todolist/ui/views/RootLayout.fxml
``` fxml

<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.FlowPane?>
<?import javafx.scene.layout.HBox?>

<BorderPane minHeight="300.0" minWidth="300.0" prefHeight="600.0"
	prefWidth="800.0" styleClass="root-layout" xmlns="http://javafx.com/javafx/8.0.65"
	xmlns:fx="http://javafx.com/fxml/1">
	<left>
		<FlowPane maxWidth="-Infinity" minWidth="-Infinity"
			prefWidth="60.0" BorderPane.alignment="TOP_LEFT" />
	</left>
	<center>
		<BorderPane minHeight="200.0" minWidth="200.0" prefHeight="540.0"
			prefWidth="740.0" BorderPane.alignment="TOP_LEFT" />
	</center>
	<top>
		<HBox maxWidth="-Infinity" minHeight="-Infinity" prefHeight="40.0"
			BorderPane.alignment="TOP_LEFT" />
	</top>
</BorderPane>
```
###### /todolist/ui/views/SettingsView.fxml
``` fxml

<?import javafx.scene.chart.CategoryAxis?>
<?import javafx.scene.chart.NumberAxis?>
<?import javafx.scene.chart.StackedBarChart?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.TitledPane?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>
<?import javafx.scene.text.Text?>
<?import javafx.scene.text.TextFlow?>

<BorderPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
	minHeight="300.0" minWidth="300.0" prefHeight="540.0" prefWidth="740.0"
	xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1"
	fx:controller="todolist.ui.controllers.SettingsController">
	<center>
		<TitledPane alignment="CENTER" animated="false"
			collapsible="false" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
			BorderPane.alignment="TOP_CENTER">
			<graphic>
				<HBox id="titled-pane-hbox" alignment="CENTER" maxHeight="1.7976931348623157E308"
					maxWidth="1.7976931348623157E308" spacing="10.0">
					<children>
						<Text id="titled-pane-hbox-text" fontSmoothingType="LCD"
							strokeType="OUTSIDE" strokeWidth="0.0" style="-fx-font-weight: bold;"
							text="settings" textAlignment="CENTER" />
					</children>
				</HBox>
			</graphic>
			<content>
				<VBox fx:id="box" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308">
					<children>
						<Label id="settingsLabel" text="Week Ahead">
							<font>
								<Font name="System Bold" size="16.0" />
							</font>
						</Label>
						<StackedBarChart fx:id="timeTable"
							alternativeColumnFillVisible="true" categoryGap="5.0" VBox.vgrow="ALWAYS">
							<xAxis>
								<CategoryAxis side="BOTTOM" />
							</xAxis>
							<yAxis>
								<NumberAxis side="LEFT" />
							</yAxis>
						</StackedBarChart>
						<Label id="settingsLabel" text="Options">
							<font>
								<Font name="System Bold" size="16.0" />
							</font>
						</Label>
						<HBox alignment="CENTER" maxHeight="-Infinity" maxWidth="1.7976931348623157E308"
							minHeight="-Infinity" minWidth="-Infinity" prefHeight="70.0"
							prefWidth="150.0">
							<children>
								<VBox alignment="CENTER_LEFT" maxHeight="-Infinity"
									maxWidth="1.7976931348623157E308" minHeight="-Infinity"
									prefHeight="100.0" spacing="10.0" HBox.hgrow="ALWAYS">
									<children>
										<Label id="settingsLabel" prefWidth="150.0" text="Current Directory">
											<font>
												<Font name="System Bold" size="12.0" />
											</font>
										</Label>
										<TextFlow>
											<children>
												<Text id="infofield" fx:id="directoryDisplay" fill="#7a9eaf"
													strokeType="OUTSIDE" strokeWidth="0.0" text="Unknown"
													wrappingWidth="177.87000274658203">
													<font>
														<Font size="14.0" />
													</font>
												</Text>
											</children>
										</TextFlow>
									</children>
								</VBox>
							</children>
						</HBox>
						<HBox alignment="CENTER" maxHeight="-Infinity" maxWidth="1.7976931348623157E308"
							minHeight="-Infinity" minWidth="-Infinity" prefHeight="70.0"
							prefWidth="150.0">
							<children>
								<VBox alignment="CENTER_LEFT" maxHeight="-Infinity"
									maxWidth="1.7976931348623157E308" minHeight="-Infinity"
									prefHeight="100.0" spacing="10.0" HBox.hgrow="ALWAYS">
									<children>
										<Label id="settingsLabel" prefWidth="150.0" text="Sound Effects">
											<font>
												<Font name="System Bold" size="12.0" />
											</font>
										</Label>
										<TextFlow>
											<children>
												<Text id="infofield" fx:id="soundStatus" fill="#7a9eaf"
													strokeType="OUTSIDE" strokeWidth="0.0" text="Sound ON">
													<font>
														<Font size="14.0" />
													</font>
												</Text>
											</children>
										</TextFlow>
									</children>
								</VBox>
							</children>
						</HBox>
						<HBox alignment="CENTER" maxHeight="-Infinity" maxWidth="1.7976931348623157E308"
							minHeight="-Infinity" minWidth="-Infinity" prefHeight="70.0"
							prefWidth="150.0">
							<children>
								<VBox alignment="CENTER_LEFT" maxHeight="-Infinity"
									maxWidth="1.7976931348623157E308" minHeight="-Infinity"
									prefHeight="100.0" spacing="10.0" HBox.hgrow="ALWAYS">
									<children>
										<Label id="settingsLabel" prefWidth="150.0" text="Reminder Ringtone">
											<font>
												<Font name="System Bold" size="12.0" />
											</font>
										</Label>
										<TextFlow>
											<children>
												<Text id="infofield" fill="#7a9eaf" strokeType="OUTSIDE"
													strokeWidth="0.0" text="TING!" wrappingWidth="168.87000274658203">
													<font>
														<Font size="14.0" />
													</font>
												</Text>
											</children>
										</TextFlow>
									</children>
								</VBox>
							</children>
						</HBox>
					</children>
				</VBox>
			</content>
		</TitledPane>
	</center>
</BorderPane>
```
###### /todolist/ui/views/SideBarView.fxml
``` fxml

<?import javafx.geometry.Insets?>
<?import javafx.geometry.Rectangle2D?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.StackPane?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>

<VBox alignment="TOP_CENTER" maxHeight="1.7976931348623157E308"
	maxWidth="-Infinity" minWidth="-Infinity" prefHeight="540.0" prefWidth="60.0"
	spacing="20.0" styleClass="side-bar" xmlns="http://javafx.com/javafx/8.0.65"
	xmlns:fx="http://javafx.com/fxml/1" fx:controller="todolist.ui.controllers.SideBarController">
	<children>
		<StackPane>
			<VBox.margin>
				<Insets top="20.0" />
			</VBox.margin>
			<children>
				<Button fx:id="all" contentDisplay="TOP" mnemonicParsing="false"
					prefHeight="50.0" prefWidth="50.0" text="ALL">
					<graphic>
						<ImageView id="home-icon" fx:id="allIcon" fitHeight="30.0"
							fitWidth="30.0" pickOnBounds="true" preserveRatio="true">
							<viewport>
								<Rectangle2D />
							</viewport>
							<image>
								<Image url="@assets/all.png" />
							</image>
						</ImageView>
					</graphic>
				</Button>
				<Label id="bubble" fx:id="allBubble" alignment="TOP_RIGHT"
					contentDisplay="RIGHT" ellipsisString="&gt;10K" maxHeight="-Infinity"
					minHeight="-Infinity" minWidth="-Infinity" nodeOrientation="LEFT_TO_RIGHT"
					prefHeight="15.0" text="0" textAlignment="CENTER"
					StackPane.alignment="TOP_LEFT">
					<padding>
						<Insets bottom="2.0" left="2.0" right="2.0" top="2.0" />
					</padding>
					<StackPane.margin>
						<Insets left="35.0" />
					</StackPane.margin>
					<font>
						<Font name="System Bold" size="10.0" />
					</font>
				</Label>
			</children>
		</StackPane>
		<StackPane>
			<children>
				<Button fx:id="expired" contentDisplay="TOP" mnemonicParsing="false"
					prefHeight="50.0" prefWidth="50.0" text="EXPIRED">
					<graphic>
						<ImageView id="button-graphics" fx:id="expiredIcon"
							fitHeight="30.0" fitWidth="30.0" pickOnBounds="true"
							preserveRatio="true">
							<viewport>
								<Rectangle2D />
							</viewport>
							<image>
								<Image url="@assets/overdue.png" />
							</image>
						</ImageView>
					</graphic>
				</Button>
				<Label id="bubble" fx:id="expiredBubble" alignment="TOP_RIGHT"
					contentDisplay="RIGHT" ellipsisString="&gt;10K" maxHeight="-Infinity"
					minHeight="-Infinity" minWidth="-Infinity" nodeOrientation="LEFT_TO_RIGHT"
					prefHeight="15.0" text="10" textAlignment="CENTER"
					StackPane.alignment="TOP_LEFT">
					<padding>
						<Insets bottom="2.0" left="2.0" right="2.0" top="2.0" />
					</padding>
					<font>
						<Font name="System Bold" size="10.0" />
					</font>
					<StackPane.margin>
						<Insets left="35.0" />
					</StackPane.margin>
				</Label>
			</children>
		</StackPane>
		<StackPane fx:id="todayStack" prefHeight="50.0" prefWidth="50.0">
			<children>
				<Button fx:id="today" contentDisplay="TOP" mnemonicParsing="false"
					prefHeight="50.0" prefWidth="50.0" text="TODAY">
					<graphic>
						<ImageView id="button-graphics" fx:id="todayIcon"
							fitHeight="30.0" fitWidth="30.0" pickOnBounds="true"
							preserveRatio="true">
							<viewport>
								<Rectangle2D />
							</viewport>
							<image>
								<Image url="@assets/today.png" />
							</image>
						</ImageView>
					</graphic>
				</Button>
				<Label id="today-label" fx:id="todayLabel" contentDisplay="CENTER"
					text="00" />
				<Label id="bubble" fx:id="todayBubble" alignment="TOP_RIGHT"
					contentDisplay="RIGHT" ellipsisString="&gt;10K" maxHeight="-Infinity"
					minHeight="-Infinity" minWidth="-Infinity" nodeOrientation="LEFT_TO_RIGHT"
					prefHeight="15.0" text="100" textAlignment="CENTER"
					StackPane.alignment="TOP_LEFT">
					<padding>
						<Insets bottom="2.0" left="2.0" right="2.0" top="2.0" />
					</padding>
					<font>
						<Font name="System Bold" size="10.0" />
					</font>
					<StackPane.margin>
						<Insets left="35.0" />
					</StackPane.margin>
				</Label>
			</children>
		</StackPane>
		<StackPane>
			<children>
				<Button fx:id="week" contentDisplay="TOP" mnemonicParsing="false"
					prefHeight="50.0" prefWidth="50.0" text="WEEK">
					<graphic>
						<ImageView id="button-graphics" fx:id="weekIcon"
							fitHeight="30.0" fitWidth="30.0" pickOnBounds="true"
							preserveRatio="true">
							<viewport>
								<Rectangle2D />
							</viewport>
							<image>
								<Image url="@assets/week.png" />
							</image>
						</ImageView>
					</graphic>
				</Button>
				<Label id="bubble" fx:id="weekBubble" alignment="TOP_RIGHT"
					contentDisplay="RIGHT" ellipsisString="&gt;10K" maxHeight="-Infinity"
					minHeight="-Infinity" minWidth="-Infinity" nodeOrientation="LEFT_TO_RIGHT"
					prefHeight="15.0" text="1000" textAlignment="CENTER"
					StackPane.alignment="TOP_LEFT">
					<padding>
						<Insets bottom="2.0" left="2.0" right="2.0" top="2.0" />
					</padding>
					<font>
						<Font name="System Bold" size="10.0" />
					</font>
					<StackPane.margin>
						<Insets left="35.0" />
					</StackPane.margin>
				</Label>
			</children>
		</StackPane>
		<StackPane>
			<children>
				<Button fx:id="done" contentDisplay="TOP" mnemonicParsing="false"
					prefHeight="50.0" prefWidth="50.0" text="DONE">
					<graphic>
						<ImageView id="button-graphics" fx:id="doneIcon"
							fitHeight="30.0" fitWidth="30.0" pickOnBounds="true"
							preserveRatio="true">
							<viewport>
								<Rectangle2D />
							</viewport>
							<image>
								<Image url="@assets/archived.png" />
							</image>
						</ImageView>
					</graphic>
				</Button>
				<Label id="bubble" fx:id="doneBubble" alignment="TOP_RIGHT"
					contentDisplay="RIGHT" ellipsisString="&gt;10K" maxHeight="-Infinity"
					minHeight="-Infinity" minWidth="-Infinity" nodeOrientation="LEFT_TO_RIGHT"
					prefHeight="15.0" text="10000" textAlignment="CENTER"
					StackPane.alignment="TOP_LEFT">
					<padding>
						<Insets bottom="2.0" left="2.0" right="2.0" top="2.0" />
					</padding>
					<font>
						<Font name="System Bold" size="10.0" />
					</font>
					<StackPane.margin>
						<Insets left="35.0" />
					</StackPane.margin>
				</Label>
			</children>
		</StackPane>
		<Button fx:id="options" contentDisplay="TOP" mnemonicParsing="false"
			prefHeight="50.0" prefWidth="50.0" text="OPTIONS">
			<graphic>
				<ImageView id="button-graphics" fx:id="optionsIcon"
					fitHeight="30.0" fitWidth="30.0" pickOnBounds="true" preserveRatio="true">
					<viewport>
						<Rectangle2D />
					</viewport>
					<image>
						<Image url="@assets/settings.png" />
					</image>
				</ImageView>
			</graphic>
		</Button>
		<Button fx:id="help" contentDisplay="TOP" mnemonicParsing="false"
			prefHeight="50.0" prefWidth="50.0" text="HELP">
			<graphic>
				<ImageView id="button-graphics" fx:id="helpIcon"
					fitHeight="30.0" fitWidth="30.0" pickOnBounds="true" preserveRatio="true">
					<viewport>
						<Rectangle2D />
					</viewport>
					<image>
						<Image url="@assets/help.png" />
					</image>
				</ImageView>
			</graphic>
		</Button>
	</children>
</VBox>
```
###### /todolist/ui/views/styles/DarkTheme.css
``` css

/* Color Template */

/* default-theme
 * --------------
 * background: #D8E9F0;
 * accent: #4AA0D5;
 * accent-two: #A9EEE6;
 * accent-three: #95E1D3;
 * accent-four: #069A8E;
 * content: #F8F3D4;
 * content-two: #FEFAEC;
 * focus: #EB586F;
 * focus-two: #F08A5D;
 * dark: #454553;
 * hint: #7A9EAF;
*/

/* dark-theme
 * --------------
 * background: #D8E9F0;
 * accent: #4AA0D5;
 * accent-two: #A9EEE6;
 * accent-three: #95E1D3;
 * content: #F8F3D4;
 * content-two: #303841;
 * focus: #EB586F;
 * focus-two: #F08A5D;
 * dark: #454553;
 * hint: #7A9EAF;
*/


/* Panel CSS Options */

.root-layout {
	-fx-background-color: #7A9EAF;
}

.main-view {
    -fx-padding: 6.0 6.0 6.0 6.0;
	-fx-border-color: transparent;
	-fx-background-color: transparent;
	-fx-box-border: transparent;
}

.split-pane:horizontal > .split-pane-divider {
    -fx-border-color: transparent;
    -fx-background-color: transparent;
}

.split-pane {
    -fx-border-color: transparent;
    -fx-background-color: transparent;
}

.titled-pane {
    -fx-padding: 0.0 0.0 6.0 0.0;
	/*-fx-text-fill: white;*/
    -fx-font-size: 12.0pt;
    -fx-font-family: "System Font";
}

.titled-pane:focused {
	/*-fx-text-fill: white;*/
}

#titled-pane-hbox-text {
	-fx-fill: #F08A5D;
	-fx-font-size: 16.0pt;
    -fx-effect: innershadow( gaussian, rgba( 0.0, 0.0, 0.0, 0.4 ), 2.0, 2.0, 2.0, 2.0 );
}

.titled-pane > .title {
	-fx-background-color: #F08A5D;
    -fx-font-size: 20.0pt;
    -fx-text-fill: #FEFAEC;
    -fx-font-weight: bold;
}

.table-view {
    
}

.titled-pane:focused > .title {
	-fx-color: #4AA0D5;
    -fx-text-fill: #FEFAEC;
    -fx-font-weight: bold;
}

.titled-pane > .content {
	-fx-background-color: #454553;
	-fx-background-radius: 0.0 0.0 6.5 6.5;
}

.list-view .scroll-bar:vertical .track {
    /*-fx-opacity: 0.0;*/
    /*-fx-padding: -12.0;*/
    -fx-background-color:transparent;
    -fx-border-color:transparent;
    -fx-background-radius: 0.0em;
    -fx-border-radius:2.0em;
}

.list-view .scroll-bar:vertical .increment-button ,
.list-view .scroll-bar:vertical .decrement-button {
    -fx-background-color:transparent;
    -fx-background-radius: 0.0em;
    -fx-padding:0.0 10.0 0.0 0.0;
}

.list-view  .scroll-bar .increment-arrow,
.list-view  .scroll-bar .decrement-arrow {
    -fx-shape: " ";
    -fx-padding:0.0;
}

.mylistview .scroll-bar:vertical .thumb {
    -fx-background-color:derive(black,90.0%);
   	-fx-background-insets: 2.0, 0.0, 0.0;
    -fx-background-radius: 2.0em;
}

.list-cell {
    -fx-background-color: transparent;
    -fx-padding: 6.5 6.5 0.0 6.5;
    -fx-background-insets: 0.0px, 10.0px;
}

.list-cell:filled:selected:focused > #task-hbox-item {
    -fx-background-color: #EB586F;
    -fx-background-color: #4AA0D5;
    /*-fx-text-fill: #FEFAEC;*/
}

.list-cell:filled:selected:focused > #task-hbox-item .label {
    -fx-text-fill: #FEFAEC;
}

.list-cell:filled:selected:focused > #task-hbox-item .text {
	-fx-fill: #FEFAEC;
}

.list-cell:filled > #task-hbox-item {
    -fx-background-color: #506F86;
    -fx-background-color: #7E858B;
    /*-fx-text-fill: #FEFAEC;*/
}

.list-cell:filled > #task-hbox-item .label {
    /*-fx-text-fill: #FEFAEC;*/
    -fx-text-fill: #454553;
}

.list-cell:filled > #task-hbox-item .text {
    -fx-fill: #454553;
}

#task-hbox-item {
    -fx-border-color: transparent;
    -fx-border-width: 0.0;
}

.text-field {
	-fx-background-color: #454553;	
    -fx-font-size: 12.0pt;
    -fx-font-family: "System Font";
    -fx-text-fill: #4AA0D5;
    -fx-prompt-text-fill: #7A9EAF;
}

#table-view {
    -fx-border-color: transparent;
    -fx-border-width: 0.0;
    -fx-focus-color: white;
    -fx-font-size: 10.0pt;
}

.title-bar {
	-fx-background-color: #3576A7;
}

.hbox-group {
	-fx-font-size: 20.0pt;
}

.image-view {
    -fx-padding: 6.0 6.0 6.0 10.0;
}

.side-bar {
	-fx-background-color: #454553;
}

.accent {
    -fx-background-color: #4AA0D5;
}

.button {
    -fx-background-color: transparent;
    -fx-background-insets: 0.0,1.0,2.0,3.0;
    -fx-background-radius: 3.0,2.0,2.0,2.0;
    -fx-text-fill: #FEFAEC;
    -fx-font-size: 8.0px;
    -fx-font-weight: bold;
}

#today-label {
    -fx-text-fill: #FEFAEC;
    -fx-font-size: 12.0px;
    -fx-font-weight: bold;
    -fx-text-alignment: center;
    -fx-padding: 0.0 0.0 8.0 0.0;
}

#bubble {
   	-fx-background-color: #F08A5D;
	-fx-background-insets: 0.0,1.0,2.0,3.0;
	-fx-background-radius: 2.0,2.0,2.0,2.0;
	-fx-padding: 2.0 4.0 2.0 4.0;
	-fx-text-fill: white;
    -fx-font-weight: bold;
    -fx-text-fill: white;
    -fx-font-size: 8.0px;
}

#placeholder {
	-fx-font-weight: bold;
	-fx-font-family: calibri;
	-fx-font-style: italic;
	-fx-text-fill: #FEFAEC;
}

.chart-plot-background {
    -fx-background-color: transparent;
}

.chart-alternative-row-fill {
    -fx-fill: transparent;
    -fx-stroke: transparent;
    -fx-stroke-width: 0.0;
}

.axis{
    -fx-tick-label-font-size: 0.7em;
    -fx-tick-label-font-weight: bold;
    -fx-tick-label-fill: #FEFAEC;
}

.chart-legend > .label{
  	-fx-text-fill: #454553;
}

#settingsLabel {
	-fx-text-fill: #FEFAEC;
}

#infofield {
	-fx-text-fill: #FEFAEC;
}
```
###### /todolist/ui/views/styles/DefaultTheme.css
``` css

/* Color Template */

/* default-theme
 * --------------
 * background: #D8E9F0;
 * accent: #4AA0D5;
 * accent-two: #A9EEE6;
 * accent-three: #95E1D3;
 * accent-four: #069A8E;
 * content: #F8F3D4;
 * content-two: #FEFAEC;
 * focus: #EB586F;
 * focus-two: #F08A5D;
 * dark: #454553;
 * hint: #7A9EAF;
*/

/* dark-theme
 * --------------
 * background: #D8E9F0;
 * accent: #4AA0D5;
 * accent-two: #A9EEE6;
 * accent-three: #95E1D3;
 * content: #F8F3D4;
 * content-two: #303841;
 * focus: #EB586F;
 * focus-two: #F08A5D;
 * dark: #454553;
 * hint: #7A9EAF;
*/


/* Panel CSS Options */

.root-layout {
	-fx-background-color: #7A9EAF;
}

.main-view {
    -fx-padding: 6.0 6.0 6.0 6.0;
	-fx-border-color: transparent;
	-fx-background-color: transparent;
	-fx-box-border: transparent;
}

.split-pane:horizontal > .split-pane-divider {
    -fx-border-color: transparent;
    -fx-background-color: transparent;
}

.titled-pane {
    -fx-padding: 0.0 0.0 6.0 0.0;
	/*-fx-text-fill: white;*/
    -fx-font-size: 12.0pt;
    -fx-font-family: "System Font";
}

#titled-pane-hbox-text {
	-fx-fill: #EB586F;
	-fx-font-size: 16.0pt;
    -fx-effect: innershadow( gaussian, rgba( 0.0, 0.0, 0.0, 0.4 ), 2.0, 2.0, 2.0, 2.0 );
}

.titled-pane > .title {
	-fx-background-color: #F08A5D;
	-fx-background-color: #EB586F;
    -fx-font-size: 20.0pt;
    -fx-font-weight: bold;
    -fx-text-fill: transparent;
}

.titled-pane:focused > .title {
	-fx-color: #4AA0D5;
    -fx-text-fill: #FEFAEC;
    -fx-font-weight: bold;
}

.titled-pane > .content {
	-fx-background-color: #454553;
	-fx-background-color: #FEFAEC;
	-fx-background-radius: 0.0 0.0 6.5 6.5;
}

.list-view .scroll-bar:vertical .track {
    /*-fx-opacity: 0.0;*/
    /*-fx-padding: -12.0;*/
    -fx-background-color:transparent;
    -fx-border-color:transparent;
    -fx-background-radius: 0.0em;
    -fx-border-radius:2.0em;
}

.list-view .scroll-bar:vertical .increment-button ,
.list-view .scroll-bar:vertical .decrement-button {
    -fx-background-color:transparent;
    -fx-background-radius: 0.0em;
    -fx-padding:0.0 10.0 0.0 0.0;
}

.list-view  .scroll-bar .increment-arrow,
.list-view  .scroll-bar .decrement-arrow {
    -fx-shape: " ";
    -fx-padding:0.0;
}

.mylistview .scroll-bar:vertical .thumb {
    -fx-background-color:derive(black,90.0%);
   	-fx-background-insets: 2.0, 0.0, 0.0;
    -fx-background-radius: 2.0em;
}


.list-cell {
    -fx-background-color: transparent;
    -fx-padding: 6.5 6.5 0.0 6.5;
    -fx-background-color: transparent;
    -fx-background-insets: 0.0px, 10.0px;
}

.list-cell:filled:selected:focused > #task-hbox-item {
    -fx-background-color: #EB586F;
    -fx-background-color: #069A8E;
    /*-fx-text-fill: #FEFAEC;*/
}

.list-cell:filled:selected:focused > #task-hbox-item .label {
    -fx-text-fill: #FEFAEC;
}

.list-cell:filled:selected:focused > #task-hbox-item .text {
	-fx-fill: #FEFAEC;
}

.list-cell:filled > #task-hbox-item {
    -fx-background-color: #506F86;
    -fx-background-color: #D8E9F0;
    /*-fx-text-fill: #FEFAEC;*/
}

.list-cell:filled > #task-hbox-item .label {
    /*-fx-text-fill: #FEFAEC;*/
    -fx-text-fill: #454553;
}

.list-cell:filled > #task-hbox-item .text {
    -fx-fill: #454553;
}

#task-hbox-item {
    -fx-border-color: transparent;
    -fx-border-width: 0.0;
}

.text-field {
	-fx-background-color: #454553;	
	-fx-background-color: #FEFAEC;
    -fx-font-size: 12.0pt;
    -fx-font-family: "System Font";
    -fx-text-fill: #454553;
    -fx-prompt-text-fill: #7A9EAF;
}

#table-view {
    -fx-border-color: transparent;
    -fx-border-width: 0.0;
    -fx-focus-color: white;
    -fx-font-size: 10.0pt;
}

.title-bar {
	-fx-background-color: #3576A7;
}

.hbox-group {
	-fx-font-size: 20.0pt;
}

.image-view {
    -fx-padding: 6.0 6.0 6.0 10.0;
}

.side-bar {
	-fx-background-color: #454553;
}

.accent {
    -fx-background-color: #4AA0D5;
}

.button {
    -fx-background-color: transparent;
    -fx-background-insets: 0.0,1.0,2.0,3.0;
    -fx-background-radius: 3.0,2.0,2.0,2.0;
    -fx-text-fill: #FEFAEC;
    -fx-font-size: 8.0px;
    -fx-font-weight: bold;
}

#today-label {
    -fx-text-fill: #FEFAEC;
    -fx-font-size: 12.0px;
    -fx-font-weight: bold;
    -fx-text-alignment: center;
    -fx-padding: 0.0 0.0 8.0 0.0;
}

#bubble {
   	-fx-background-color: #EB586F;
	-fx-background-insets: 0.0,1.0,2.0,3.0;
	-fx-background-radius: 2.0,2.0,2.0,2.0;
	-fx-padding: 2.0 4.0 2.0 4.0;
	-fx-text-fill: white;
    -fx-font-weight: bold;
    -fx-text-fill: white;
    -fx-font-size: 8.0px;
}

#placeholder {
	-fx-font-weight: bold;
	-fx-font-family: calibri;
	-fx-font-style: italic;
	-fx-fill: light grey;
}

.chart-plot-background {
    -fx-background-color: transparent;
}

.chart-alternative-row-fill {
    -fx-fill: transparent;
    -fx-stroke: transparent;
    -fx-stroke-width: 0.0;
}

.axis {
    -fx-tick-label-font-size: 0.7em;
    -fx-tick-label-font-weight: bold;
}
```
###### /todolist/ui/views/TaskNode.fxml
``` fxml

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.StackPane?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.shape.Circle?>
<?import javafx.scene.shape.Rectangle?>
<?import javafx.scene.text.Font?>
<?import javafx.scene.text.Text?>
<?import javafx.scene.text.TextFlow?>

<HBox id="task-hbox-item" fx:id="root" alignment="CENTER_LEFT"
	maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
	xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<AnchorPane maxHeight="1.7976931348623157E308" maxWidth="-Infinity"
			minWidth="-Infinity" prefWidth="5.0">
			<children>
				<Rectangle fx:id="priorityLabel" fill="#1f93ff00" height="92.0"
					stroke="BLACK" strokeType="INSIDE" strokeWidth="0.0" width="5.0"
					AnchorPane.bottomAnchor="0.0" AnchorPane.topAnchor="0.0" />
			</children>
		</AnchorPane>
		<StackPane fx:id="numberLabel" prefWidth="50.0">
			<children>
				<Circle fx:id="numLabelBase" fill="#1f93ff00" radius="25.0"
					stroke="BLACK" strokeType="INSIDE" strokeWidth="0.0">
					<StackPane.margin>
						<Insets left="10.0" right="10.0" />
					</StackPane.margin>
				</Circle>
				<Label fx:id="number" textFill="WHITE">
					<font>
						<Font name="System Bold" size="14.0" />
					</font>
				</Label>
			</children>
		</StackPane>
		<VBox fx:id="details" maxHeight="1.7976931348623157E308"
			maxWidth="1.7976931348623157E308" prefHeight="80.0" prefWidth="100.0"
			HBox.hgrow="ALWAYS">
			<children>
				<HBox fx:id="titleBox" alignment="CENTER_LEFT" maxHeight="1.7976931348623157E308"
					prefHeight="20.0">
					<children>
						<TextFlow id="titleFlow" fx:id="titleFlow" maxHeight="1.7976931348623157E308"
							maxWidth="1.7976931348623157E308" prefHeight="20.0">
							<children>
								<Text id="title" fx:id="title" fontSmoothingType="LCD"
									strokeType="OUTSIDE" strokeWidth="0.0" style="-fx-font-weight: bold;" />
							</children>
						</TextFlow>
					</children>
					<VBox.margin>
						<Insets />
					</VBox.margin>
					<padding>
						<Insets top="10.0" />
					</padding>
				</HBox>
				<HBox fx:id="relativeRangeBox" alignment="CENTER_LEFT"
					maxHeight="-Infinity" minHeight="-Infinity" prefHeight="20.0"
					prefWidth="20.0">
					<children>
						<Label fx:id="relativeRange" textFill="WHITE">
							<font>
								<Font size="12.0" />
							</font>
						</Label>
					</children>
					<VBox.margin>
						<Insets bottom="6.0" />
					</VBox.margin>
				</HBox>
				<HBox fx:id="dateRangeBox" alignment="CENTER_LEFT" layoutX="10.0"
					layoutY="40.0" maxHeight="-Infinity" minHeight="-Infinity"
					prefHeight="20.0" prefWidth="200.0">
					<children>
						<Label fx:id="dateRange" maxHeight="-Infinity" minHeight="-Infinity"
							prefHeight="20.0" textFill="WHITE">
							<font>
								<Font size="10.0" />
							</font>
						</Label>
					</children>
				</HBox>
				<HBox fx:id="categoryBox" alignment="CENTER_LEFT" maxHeight="-Infinity"
					minHeight="-Infinity" prefHeight="20.0" prefWidth="200.0">
					<children>
						<Circle fx:id="categorySprite" fill="#ababab00" radius="4.0"
							stroke="BLACK" strokeType="INSIDE" strokeWidth="0.0">
							<HBox.margin>
								<Insets right="3.0" />
							</HBox.margin>
						</Circle>
						<Label fx:id="category" textFill="WHITE">
							<font>
								<Font size="10.0" />
							</font>
						</Label>
					</children>
					<padding>
						<Insets bottom="10.0" />
					</padding>
				</HBox>
			</children>
		</VBox>
		<StackPane fx:id="completeStatus" maxHeight="-Infinity"
			minHeight="-Infinity" prefHeight="20.0">
			<children>
				<Rectangle fx:id="statusBacking" arcHeight="10.0"
					arcWidth="10.0" fill="#ffe92100" height="25.0" stroke="BLACK"
					strokeType="INSIDE" strokeWidth="0.0" width="55.0" />
				<Label fx:id="status">
					<font>
						<Font name="System Bold" size="10.0" />
					</font>
				</Label>
			</children>
			<HBox.margin>
				<Insets left="15.0" right="15.0" />
			</HBox.margin>
		</StackPane>
		<VBox fx:id="indicatorsHolder" alignment="TOP_RIGHT" maxHeight="1.7976931348623157E308"
			maxWidth="-Infinity" prefWidth="70.0" spacing="7.0">
			<children>
				<HBox alignment="CENTER_RIGHT" spacing="3.0">
					<VBox.margin>
						<Insets right="10.0" top="10.0" />
					</VBox.margin>
					<children>
						<Label fx:id="recurInterval">
							<font>
								<Font name="System Bold" size="10.0" />
							</font>
						</Label>
						<ImageView fx:id="recurringIndicator" fitHeight="10.0"
							fitWidth="10.0" pickOnBounds="true" preserveRatio="true">
							<image>
								<Image url="@assets/recurring-indicator.png" />
							</image>
						</ImageView>
					</children>
				</HBox>
				<HBox alignment="TOP_RIGHT">
					<children>
						<ImageView fx:id="reminderIndicator" fitHeight="10.0"
							fitWidth="10.0" pickOnBounds="true" preserveRatio="true">
							<image>
								<Image url="@assets/reminder-indicator.png" />
							</image>
						</ImageView>
					</children>
					<VBox.margin>
						<Insets right="10.0" />
					</VBox.margin>
				</HBox>
			</children>
		</VBox>
	</children>
	<opaqueInsets>
		<Insets />
	</opaqueInsets>
</HBox>
```
###### /todolist/ui/views/TitleBarView.fxml
``` fxml

<?import java.lang.String?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.HBox?>

<HBox alignment="CENTER" prefHeight="40.0" prefWidth="800.0"
	xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<ImageView fitHeight="28.0" fitWidth="1000.0" pickOnBounds="true"
			preserveRatio="true">
			<HBox.margin>
				<Insets />
			</HBox.margin>
			<image>
				<Image url="@assets/logo.png" />
			</image>
		</ImageView>
	</children>
	<styleClass>
		<String fx:value="title-bar" />
		<String fx:value="image-view" />
		<String fx:value="hbox-group" />
	</styleClass>
</HBox>
```
###### /todolist/ui/views/TodayView.fxml
``` fxml

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.control.TitledPane?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.text.Text?>

<BorderPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
	minHeight="300.0" minWidth="300.0" prefHeight="540.0" prefWidth="740.0"
	xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1"
	fx:controller="todolist.ui.controllers.TodayController">
	<center>
		<TitledPane alignment="CENTER" animated="false"
			collapsible="false" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
			BorderPane.alignment="TOP_CENTER">
			<content>
				<ListView fx:id="listView" prefHeight="200.0" prefWidth="200.0">
					<placeholder>
						<Label style="-fx-font-weight: bold;" text="woohoo! you've got nothing else on for today!" />
					</placeholder>
					<opaqueInsets>
						<Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
					</opaqueInsets>
					<padding>
						<Insets bottom="5.0" />
					</padding>
				</ListView>
			</content>
			<graphic>
				<HBox id="titled-pane-hbox" alignment="CENTER" maxHeight="1.7976931348623157E308"
					maxWidth="1.7976931348623157E308" spacing="10.0">
					<children>
						<Text id="titled-pane-hbox-text" fontSmoothingType="LCD"
							strokeType="OUTSIDE" strokeWidth="0.0" style="-fx-font-weight: bold;"
							text="today's agenda" textAlignment="CENTER" />
					</children>
				</HBox>
			</graphic>
		</TitledPane>
	</center>
</BorderPane>
```
###### /todolist/ui/views/WeekView.fxml
``` fxml

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.control.TitledPane?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.text.Text?>

<BorderPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
	minHeight="300.0" minWidth="300.0" prefHeight="540.0" prefWidth="740.0"
	xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1"
	fx:controller="todolist.ui.controllers.WeekController">
	<center>
		<TitledPane alignment="CENTER" animated="false"
			collapsible="false" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308"
			BorderPane.alignment="TOP_CENTER">
			<content>
				<ListView fx:id="listView" prefHeight="200.0" prefWidth="200.0">
					<placeholder>
						<Label style="-fx-font-weight: bold;" text="wow! your week is free! congratulations!" />
					</placeholder>
					<opaqueInsets>
						<Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
					</opaqueInsets>
					<padding>
						<Insets bottom="5.0" />
					</padding>
				</ListView>
			</content>
			<graphic>
				<HBox id="titled-pane-hbox" alignment="CENTER" maxHeight="1.7976931348623157E308"
					maxWidth="1.7976931348623157E308" spacing="10.0">
					<children>
						<Text id="titled-pane-hbox-text" fontSmoothingType="LCD"
							strokeType="OUTSIDE" strokeWidth="0.0" style="-fx-font-weight: bold;"
							text="next 7 days" textAlignment="CENTER" />
					</children>
				</HBox>
			</graphic>
		</TitledPane>
	</center>
</BorderPane>
```
