# A0130620B
###### /todolist/logic/CaseExecuter.java
``` java
package todolist.logic;

import todolist.model.Task;

public class CaseExecuter {
	private Logic logic;

	public CaseExecuter(Logic logic) {
		this.logic = logic;
	}

	private boolean isInteger(String s) {
		try {
			@SuppressWarnings("unused")
			int i = Integer.parseInt(s);
			return true;
		} catch (NumberFormatException er) {
			return false;
		}
	}

	public void add(String[] arg) {
		String type = arg[0];
		switch (type) {
		case "event":
			addEvent(arg);
			break;
		case "deadline":
			addDeadline(arg);
			break;
		case "task":
			addTask(arg);
			break;
		case "recurring":
			addRecurring(arg);
			break;
		default:
		}
	}

	public void addEvent(String[] arg) {
		if (arg.length == 6) {
			logic.addEvent(arg[1], arg[2], arg[3], arg[4], arg[5]);
		} else {
			logic.addEventLess(arg[1], arg[2], arg[3], arg[4]);
		}
	}

	public void addDeadline(String[] arg) {
		if (arg.length == 4) {
			logic.addDeadline(arg[1], arg[2], arg[3]);
		} else {
			logic.addDeadlineLess(arg[1], arg[2]);
		}
	}

	public void addTask(String[] arg) {
		logic.addTask(arg[1]);
	}

	public void addRecurring(String[] arg) {
		switch (arg[1]) {
		case "event":
			addRecurringEvent(arg);
			break;
		case "deadline":
			addRecurringDeadline(arg);
			break;
		default:
		}
	}

	public void addRecurringEvent(String[] arg) {
		if (arg.length == 8) {
			logic.addRecurringEvent(arg[2], arg[3], arg[4], arg[5], arg[6], arg[7]);
		} else {
			logic.addRecurringEventLess(arg[2], arg[3], arg[4], arg[5], arg[6]);
		}
	}

	public void addRecurringDeadline(String[] arg) {
		if (arg.length == 6) {
			logic.addRecurringDeadline(arg[2], arg[3], arg[4], arg[5]);
		} else {
			logic.addRecurringDeadlineLess(arg[2], arg[3], arg[4]);
		}
	}

	public void edit(String[] arg) {
		if (isInteger(arg[0])) {
			int index = Integer.parseInt(arg[0]);
			Task task = logic.getMainApp().getTaskAt(index);
			logic.edit(task.getName().getName(), arg[1], arg[2]);
		} else {
			logic.edit(arg[0], arg[1], arg[2]);
		}
	}

	public void delete(String[] arg) {
		if (isInteger(arg[0])) {
			int index = Integer.parseInt(arg[0]);
			Task task = logic.getMainApp().getTaskAt(index);
			logic.delete(task.getName().getName());
		} else {
			logic.delete(arg[0]);
		}
	}

	public void search(String[] arg) {
		logic.search(arg);
	}

	public void filter(String[] arg) {
		logic.filter(arg[0]);
	}

	public void sort(String[] arg) {
		logic.sort(arg[0], arg[1]);
	}

	public void label(String[] arg) {
		if (isInteger(arg[0])) {
			int index = Integer.parseInt(arg[0]);
			Task task = logic.getMainApp().getTaskAt(index);
			logic.label(task.getName().getName(), arg[1]);
		} else {
			logic.label(arg[0], arg[1]);
		}
	}

	public void setRecurring(String[] arg) {
		if (isInteger(arg[0])) {
			int index = Integer.parseInt(arg[0]);
			Task task = logic.getMainApp().getTaskAt(index);
			logic.setRecurring(task.getName().getName(), true, arg[1]);
		} else {
			logic.setRecurring(arg[0], true, arg[1]);
		}
	}

	public void removeRecurring(String[] arg) {
		if (isInteger(arg[0])) {
			int index = Integer.parseInt(arg[0]);
			Task task = logic.getMainApp().getTaskAt(index);
			logic.setRecurring(task.getName().getName(), false, null);
		} else {
			logic.setRecurring(arg[0], false, null);
		}
	}

	public void postpone(String[] arg) {
		if (isInteger(arg[0])) {
			int index = Integer.parseInt(arg[0]);
			Task task = logic.getMainApp().getTaskAt(index);
			logic.postpone(task.getName().getName(), arg[1], arg[2]);
		} else {
			logic.postpone(arg[0], arg[1], arg[2]);
		}
	}

	public void forward(String[] arg) {
		if (isInteger(arg[0])) {
			int index = Integer.parseInt(arg[0]);
			Task task = logic.getMainApp().getTaskAt(index);
			logic.forward(task.getName().getName(), arg[1], arg[2]);
		} else {
			logic.forward(arg[0], arg[1], arg[2]);
		}
	}

	public void addRemind(String[] arg) {
		logic.addRemind(arg);
	}

	public void remind(String[] arg) {
		if (isInteger(arg[0])) {
			int index = Integer.parseInt(arg[0]);
			Task task = logic.getMainApp().getTaskAt(index);
			logic.remind(task.getName().getName());
		} else {
			logic.remind(arg[0]);
		}
	}

	public void addRemindBef(String[] arg) {
		String[] restOfArgs = new String[arg.length - 2];
		for (int i = 0; i < arg.length; i++) {
			restOfArgs[i] = arg[i + 2];
		}
		logic.addRemindBef(arg[0], arg[1], restOfArgs);
	}

	public void remindBef(String[] arg) {
		if (isInteger(arg[0])) {
			int index = Integer.parseInt(arg[0]);
			Task task = logic.getMainApp().getTaskAt(index);
			logic.remindBef(task.getName().getName(), arg[1], arg[2]);
		} else {
			logic.remindBef(arg[0], arg[1], arg[2]);
		}
	}

	public void done(String[] arg) {
		if (isInteger(arg[0])) {
			int index = Integer.parseInt(arg[0]);
			Task task = logic.getMainApp().getTaskAt(index);
			logic.done(task.getName().getName());
		} else {
			logic.done(arg[0]);
		}
	}

	public void undone(String[] arg) {
		if (isInteger(arg[0])) {
			int index = Integer.parseInt(arg[0]);
			Task task = logic.getMainApp().getTaskAt(index);
			logic.undone(task.getName().getName());
		} else {
			logic.undone(arg[0]);
		}
	}

	public void exit(String[] arg) {
		logic.exit();
	}

	public void undo(String[] arg) {
		logic.undo(Integer.parseInt(arg[0]));
	}

	public void redo(String[] arg) {
		logic.redo(Integer.parseInt(arg[0]));
	}

	public void reset(String[] arg) {
		logic.reset();
	}
	
	public void save(String[] arg) {
		logic.setNewFile(arg[0]);
	}
	

	public void open(String[] arg) {
		logic.openNewFile(arg[0]);
	}

	public void tab(String[] arg) {
		logic.tab(arg[0]);
	}

	public void invalid(String[] arg) {
		logic.invalid(arg[0]);
	}

}
```
###### /todolist/logic/CaseSwitcher.java
``` java
package todolist.logic;

import todolist.model.InputException;
import todolist.model.Task;
import todolist.model.TokenizedCommand;

public class CaseSwitcher {

	private Logic logic;
	private InputErrorChecker inputErrorChecker;
	private CaseExecuter caseExecuter;

	public CaseSwitcher(Logic logic) {
		this.logic = logic;
		this.inputErrorChecker = new InputErrorChecker(logic);
		this.caseExecuter = new CaseExecuter(logic);
	}

	public void execute(TokenizedCommand command) {
		InputException inputException = inputErrorChecker.validate(command);
		if (inputException.getCorrectness()) {
			forceExecute(command);
		} else {
			logic.getUIHandler().sendMessage(inputException.getErrorMessage(), true);
		}
	}

	public void forceExecute(TokenizedCommand command) {

		String action = command.getAction();
		String arg[] = command.getArgs();

		switch (action) {

		case "add":
			caseExecuter.add(arg);
			break;
		case "edit":
			caseExecuter.edit(arg);
			break;
		case "delete":
			caseExecuter.delete(arg);
			break;
		case "search":
			caseExecuter.search(arg);
			break;
		case "filter":
			caseExecuter.filter(arg);
			break;
		case "sort":
			caseExecuter.sort(arg);
			break;
		case "label":
			caseExecuter.label(arg);
			break;
		case "set-recurring":
			caseExecuter.setRecurring(arg);
			break;
		case "remove-recurring":
			caseExecuter.removeRecurring(arg);
			break;
		case "postpone":
			caseExecuter.postpone(arg);
			break;
		case "forward":
			caseExecuter.forward(arg);
			break;
		case "add-remind":
			caseExecuter.addRemind(arg);
			break;
		case "remind":
			caseExecuter.remind(arg);
			break;
		case "add-remind-bef":
			caseExecuter.addRemindBef(arg);
			break;
		case "remind-bef":
			caseExecuter.addRemindBef(arg);
			break;
		case "done":
			caseExecuter.done(arg);
			break;
		case "undone":
			caseExecuter.undone(arg);
			break;
		case "exit":
			caseExecuter.exit(arg);
			break;
		case "undo":
			caseExecuter.undo(arg);
			break;
		case "redo":
			caseExecuter.redo(arg);
			break;
		case "reset":
			caseExecuter.reset(arg);
			break;
		case "save":
			caseExecuter.save(arg);
			break;
		case "open":
			caseExecuter.open(arg);
			break;
		case "tab":
			caseExecuter.tab(arg);
			break;
		case "invalid":
			caseExecuter.invalid(arg);
			break;
		default:

		}

		if (!action.equals("undo") && !action.equals("redo")) {
			logic.stepForward();
		}
	}
}
```
###### /todolist/logic/CommandChecker.java
``` java
package todolist.logic;

import todolist.model.InputException;
import todolist.model.Task;

public class CommandChecker {
	private Logic logic;
	private FunctionChecker functionChecker;
	
	
	public CommandChecker(Logic logic) {
		this.logic = logic;
		this.functionChecker = new FunctionChecker(this.logic);
	}
	
	public InputException add(String[] arg) {
		String type = "null";
		if (arg.length == 0) {
			return new InputException("ADD", "INCOMPLETE");
		} else {
			type = arg[0];
		}

		switch (type) {
		case "event":
			return addEvent(arg);
		case "deadline":
			return addDeadline(arg);
		case "task":
			return addTask(arg);
		case "recurring":
			return addRecurring(arg);
		default:
			return new InputException("ADD", "INCOMPLETE");
		}
	}

	public InputException addEvent(String[] arg) {
		if (arg.length != 6 && arg.length != 5) {
			return new InputException("ADD EVENT", "INCOMPLETE");
		} else {
			if (arg.length == 6) {
				return functionChecker.addEventChecker(arg[1], arg[2], arg[3], arg[4], arg[5]);
			} else {
				return functionChecker.addEventLessChecker(arg[1], arg[2], arg[3], arg[4]);
			}
		}
	}

	public InputException addDeadline(String[] arg) {
		if (arg.length != 4 && arg.length != 3) {
			return new InputException("ADD DEADLINE", "INCOMPLETE");
		} else {
			if (arg.length == 4) {
				return functionChecker.addDeadlineChecker(arg[1], arg[2], arg[3]);
			} else {
				return functionChecker.addDeadlineLessChecker(arg[1], arg[2]);
			}
		}
	}

	public InputException addTask(String[] arg) {
		if (arg.length != 2) {
			return new InputException("ADD TASK", "INCOMPLETE");
		} else {
			return functionChecker.addTaskChecker(arg[1]);
		}
	}

	public InputException addRecurring(String[] arg) {
		switch (arg[1]) {
		case "event":
			return addRecurringEvent(arg);
		case "deadline":
			return addRecurringDeadline(arg);
		default:
			return new InputException("ADD RECURRING", "INCOMPLETE");
		}
	}

	public InputException addRecurringEvent(String[] arg) {
		if (arg.length != 8 && arg.length != 7) {
			return new InputException("ADD RECURRING EVENT", "INCOMPLETE");
		} else {
			if (arg.length == 8) {
				return functionChecker.addRecurringEventChecker(arg[2], arg[3], arg[4], arg[5], arg[6], arg[7]);
			} else {
				return functionChecker.addRecurringEventLessChecker(arg[2], arg[3], arg[4], arg[5], arg[6]);
			}
		}
	}

	public InputException addRecurringDeadline(String[] arg) {
		if (arg.length != 6 && arg.length != 5) {
			return new InputException("ADD RECURRING DEADLINE", "INCOMPLETE");
		} else {
			if (arg.length == 6) {
				return functionChecker.addRecurringDeadlineChecker(arg[2], arg[3], arg[4], arg[5]);
			} else {
				return functionChecker.addRecurringDeadlineLessChecker(arg[2], arg[3], arg[4]);
			}
		}
	}

	public InputException edit(String[] arg) {
		if (arg.length != 3) {
			return new InputException("EDIT", "INCOMPLETE");

		} else {
			if (isInteger(arg[0])) {
				int index = Integer.parseInt(arg[0]);
				Task task = logic.getMainApp().getTaskAt(index);
				if (task == null) {
					return new InputException("EDIT", "NOT EXIST");
				} else {
					return functionChecker.editChecker(task.getName().getName(), arg[1], arg[2]);
				}
			} else {
				return functionChecker.editChecker(arg[0], arg[1], arg[2]);
			}
		}
	}

	public InputException delete(String[] arg) {
		if (arg.length != 1) {
			return new InputException("DELETE", "INCOMPLETE");
		} else {
			if (isInteger(arg[0])) {
				int index = Integer.parseInt(arg[0]);
				Task task = logic.getMainApp().getTaskAt(index);
				if (task == null) {
					return new InputException("DELETE", "NOT EXIST");
				} else {
					return functionChecker.deleteChecker(task.getName().getName());
				}
			} else {
				return functionChecker.deleteChecker(arg[0]);
			}
		}
	}

	public InputException search(String[] arg) {
		if (arg.length != 1) {
			return new InputException("SEARCH", "INCOMPLETE");
		} else {
			return functionChecker.searchChecker(arg);
		}
	}

	public InputException filter(String[] arg) {
		if (arg.length != 1) {
			return new InputException("FILTER", "INCOMPLETE");
		} else {
			return functionChecker.filterChecker(arg);
		}
	}

	public InputException sort(String[] arg) {
		if (arg.length != 2) {
			return new InputException("SORT", "INCOMPLETE");
		} else {
			return functionChecker.sortChecker(arg);
		}
	}

	public InputException label(String[] arg) {
		if (arg.length != 2) {
			return new InputException("LABEL", "INCOMPLETE");
		} else {
			if (isInteger(arg[0])) {
				int index = Integer.parseInt(arg[0]);
				Task task = logic.getMainApp().getTaskAt(index);
				if (task == null) {
					return new InputException("LABEL", "NOT EXIST");
				} else {
					return functionChecker.labelChecker(task.getName().getName(), arg[1]);
				}
			} else {
				return functionChecker.labelChecker(arg[0], arg[1]);
			}
		}
	}

	public InputException setRecurring(String[] arg) {
		if (arg.length != 2) {
			return new InputException("SET-RECURRING", "INCOMPLETE");
		} else {
			if (isInteger(arg[0])) {
				int index = Integer.parseInt(arg[0]);
				Task task = logic.getMainApp().getTaskAt(index);
				if (task == null) {
					return new InputException("SET-RECURRING", "NOT EXIST");
				} else {
					return functionChecker.setRecurringChecker(task.getName().getName(), true, arg[1]);
				}
			} else {
				return functionChecker.setRecurringChecker(arg[0], true, arg[1]);
			}
		}
	}

	public InputException removeRecurring(String[] arg) {
		if (arg.length != 2) {
			return new InputException("SET-RECURRING", "INCOMPLETE");
		} else {
			if (isInteger(arg[0])) {
				int index = Integer.parseInt(arg[0]);
				Task task = logic.getMainApp().getTaskAt(index);
				if (task == null) {
					return new InputException("REMOVE-RECURRING", "NOT EXIST");
				} else {
					return functionChecker.removeRecurringChecker(task.getName().getName(), true, arg[1]);
				}
			} else {
				return functionChecker.removeRecurringChecker(arg[0], true, arg[1]);
			}
		}
	}

	public InputException postpone(String[] arg) {
		if (arg.length != 3) {
			return new InputException("POSTPONE", "INCOMPLETE");
		} else {
			if (isInteger(arg[0])) {
				int index = Integer.parseInt(arg[0]);
				Task task = logic.getMainApp().getTaskAt(index);
				if (task == null) {
					return new InputException("POSTPONE", "NOT EXIST");
				} else {
					return functionChecker.postponeChecker(task.getName().getName(), arg[1], arg[2]);
				}
			} else {
				return functionChecker.postponeChecker(arg[0], arg[1], arg[2]);
			}
		}
	}

	public InputException forward(String[] arg) {
		if (arg.length != 3) {
			return new InputException("FORWARD", "INCOMPLETE");
		} else {
			if (isInteger(arg[0])) {
				int index = Integer.parseInt(arg[0]);
				Task task = logic.getMainApp().getTaskAt(index);
				if (task == null) {
					return new InputException("FORWARD", "NOT EXIST");
				} else {
					return functionChecker.forwardChecker(task.getName().getName(), arg[1], arg[2]);
				}
			} else {
				return functionChecker.forwardChecker(arg[0], arg[1], arg[2]);
			}
		}
	}

	public InputException addRemind(String[] arg) {
		return functionChecker.addRemindChecker(arg);
	}

	public InputException remind(String[] arg) {
		if (arg.length != 1) {
			return new InputException("REMIND", "INCOMPLETE");
		} else {
			if (isInteger(arg[0])) {
				int index = Integer.parseInt(arg[0]);
				Task task = logic.getMainApp().getTaskAt(index);
				if (task == null) {
					return new InputException("REMIND", "NOT EXIST");
				} else {
					return functionChecker.remindChecker(task.getName().getName());
				}
			} else {
				return functionChecker.remindChecker(arg[0]);
			}
		}
	}

	public InputException addRemindBef(String[] arg) {
		String[] restOfArgs = new String[arg.length - 2];
		for (int i = 0; i < arg.length; i++) {
			restOfArgs[i] = arg[i + 2];
		}
		return functionChecker.addRemindBefChecker(arg[0], arg[1], restOfArgs);
	}

	public InputException remindBef(String[] arg) {
		if (arg.length != 3) {
			return new InputException("REMIND-BEF", "INCOMPLETE");
		} else {
			if (isInteger(arg[0])) {
				int index = Integer.parseInt(arg[0]);
				Task task = logic.getMainApp().getTaskAt(index);
				if (task == null) {
					return new InputException("REMIND-BEF", "NOT EXIST");
				} else {
					return functionChecker.remindBefChecker(task.getName().getName(), arg[1], arg[2]);
				}
			} else {
				return functionChecker.remindBefChecker(arg[0], arg[1], arg[2]);
			}
		}
	}

	public InputException done(String[] arg) {
		if (arg.length != 1) {
			return new InputException("DONE", "INCOMPLETE");
		} else {
			if (isInteger(arg[0])) {
				int index = Integer.parseInt(arg[0]);
				Task task = logic.getMainApp().getTaskAt(index);
				if (task == null) {
					return new InputException("DONE", "NOT EXIST");
				} else {
					return functionChecker.doneChecker(task.getName().getName());
				}
			} else {
				return functionChecker.doneChecker(arg[0]);
			}
		}
	}

	public InputException undone(String[] arg) {
		if (arg.length != 1) {
			return new InputException("UNDONE", "INCOMPLETE");
		} else {
			if (isInteger(arg[0])) {
				int index = Integer.parseInt(arg[0]);
				Task task = logic.getMainApp().getTaskAt(index);
				if (task == null) {
					return new InputException("UNDONE", "NOT EXIST");
				} else {
					return functionChecker.undoneChecker(task.getName().getName());
				}
			} else {
				return functionChecker.undoneChecker(arg[0]);
			}
		}
	}
	
	public InputException exit(String[] arg) {
		return functionChecker.exitChecker(arg);
	}
	
	public InputException undo(String[] arg) {
		if (arg.length != 1) {
			return new InputException("UNDO", "INCOMPLETE");
		} else {
			return functionChecker.undoChecker(arg);
		}
	}
	
	public InputException redo(String[] arg) {
		if (arg.length != 1) {
			return new InputException("REDO", "INCOMPLETE");
		} else {
			return functionChecker.redoChecker(arg);
		}
	}
	
	public InputException reset(String[] arg) {
		return functionChecker.resetChecker(arg);
	}
	
	public InputException tab(String[] arg) {
		if (arg.length != 1) {
			return new InputException("TAB", "INCOMPLETE");
		} else {
			return functionChecker.tabChecker(arg);
		}
	}
	
	public InputException open(String[] arg) {
		return functionChecker.openChecker(arg);
	}
	
	public InputException save(String[] arg) {
		return functionChecker.saveChecker(arg);
	}
	
	public InputException invalid(String[] arg) {
		return functionChecker.invalidChecker(arg);
	}

	
	private boolean isInteger(String s) {
		try {
			@SuppressWarnings("unused")
			int i = Integer.parseInt(s);
			return true;
		} catch (NumberFormatException er) {
			return false;
		}
	}

}
```
###### /todolist/logic/ErrorBase.java
``` java
package todolist.logic;

import java.util.HashMap;
import java.util.Map;

public class ErrorBase {

	static Map<String, String> errorBase = new HashMap<String, String>();

	public ErrorBase() {
		errorBase.put(("ADD" + "INCOMPLETE"),
				"Your command was incomplete! To create a task, you will first need to specify the type of task that you wish to create.");
		errorBase.put(("ADD EVENT" + "INCOMPLETE"),
				"Your command was incomplete! To add an event, try: add event [title] [YYYY-MM-DD] [HH:MM] [number] [hour | day].");
		errorBase.put(("ADD DEADLINE" + "INCOMPLETE"),
				"Your command was incomplete! To add a deadline, try: add deadline [title] [YYYY-MM-DD] [HH:MM]");
		errorBase.put(("ADD TASK" + "INCOMPLETE"),
				"Your command was incomplete! To add an un-dated task: add task [title]");
		errorBase.put(("ADD RECURRING EVENT" + "INCOMPLETE"),
				"Your command was incomplete! To add a recurring event, try: add recurring event [7-day] [title] [YYYY-MM-DD] [HH:MM] [number] [hour | day]");
		errorBase.put(("ADD RECURRING DEADLINE" + "INCOMPLETE"),
				"Your command was incomplete! To add a recurring deadline, try: add recurring deadline [7-day] [title] [YYYY-MM-DD] [HH:MM]");
		errorBase.put(("EDIT" + "INCOMPLETE"),
				"Your command was incomplete! To edit a task, try: edit [title] [field-name] [new-value]");
		errorBase.put(("FILTER" + "INCOMPLETE"),
				"Your command was incomplete! To apply a filter, try: filter [category-name]");
		errorBase.put(("SET-RECURRING" + "INCOMPLETE"),
				"Your command was incomplete! To set a task to repeat, try: set-recurring [title] [interval]");
		errorBase.put(("LABEL" + "INCOMPLETE"),
				"Your command was incomplete! To categorise or label a task, try: label [title] [category-name]");
		errorBase.put(("REMOVE-RECURRING" + "INCOMPLETE"),
				"Your command was incomplete! To stop a task from repeating, try: remove-recurring [title]");
		errorBase.put(("POSTPONE" + "INCOMPLETE"),
				"Your command was incomplete! To postpone a task, try: postpone [title] [number] [hour | day]");
		errorBase.put(("FORWARD" + "INCOMPLETE"),
				"Your command was incomplete! To forward a task, try: forward [title] [number] [hour | day]");
		errorBase.put(("REMIND" + "INCOMPLETE"),
				"Your command was incomplete! To get ToDoList to remind you on a task, try: remind [title]");
		errorBase.put(("REMIND-BEF" + "INCOMPLETE"),
				"Your command was incomplete! To get ToDoList to remind you on a task sometime before it is due, try: remind-bef [title] [number] [hour | day]");
		errorBase.put(("DONE" + "INCOMPLETE"),
				"Your command was incomplete! To archive a completed task, try: done [title]");
		errorBase.put(("UNDONE" + "INCOMPLETE"),
				"Your command was incomplete! To un-archive an ongoing task, try: undone [title]");
		errorBase.put(("UNDO" + "INCOMPLETE"),
				"Your command was incomplete! To undo a few action(s), try: undo [number-of-actions]");
		errorBase.put(("REDO" + "INCOMPLETE"),
				"Your command was incomplete! To redo a few action(s), try: redo [number-of-actions]");
		errorBase.put(("TAB" + "INCOMPLETE"),
				"Your command was incomplete! To navigate to a certain page, try: tab [page-name] (as reflected on the tab bar)");
		errorBase.put(("REDO" + "INCOMPLETE"),
				"Your command was incomplete! To redo a few action(s), try: redo [number-of-actions]");
	}

	public String getErrorMessage(String commandType, String errorType) {
		for (Map.Entry<String,String> entry : errorBase.entrySet()) {
			  String key = entry.getKey();
			  String value = entry.getValue();
			  System.out.println(key + " " + value);
			  // do stuff
			}
		System.out.println(errorBase.containsKey((commandType + errorType)));
		System.out.println(commandType + errorType);
		return errorBase.get((commandType + errorType));
	}
}
```
###### /todolist/logic/InputErrorChecker.java
``` java
package todolist.logic;

import todolist.model.InputException;
import todolist.model.Task;
import todolist.model.TokenizedCommand;

public class InputErrorChecker {
	private Logic logic;
	private CommandChecker commandChecker;

	public InputErrorChecker(Logic logic) {
		this.logic = logic;
		commandChecker = new CommandChecker(this.logic);
	}
	
	public InputException validate(TokenizedCommand command) {
		String action = command.getAction();
		String arg[] = command.getArgs();

		switch (action) {
		case "add":
			return commandChecker.add(arg);
		case "edit":
			return commandChecker.edit(arg);
		case "delete":
			return commandChecker.delete(arg);
		case "search":
			return commandChecker.search(arg);
		case "filter":
			return commandChecker.filter(arg);
		case "sort":
			return commandChecker.sort(arg);
		case "label":
			return commandChecker.label(arg);
		case "set-recurring":
			return commandChecker.setRecurring(arg);
		case "remove-recurring":
			return commandChecker.removeRecurring(arg);
		case "postpone":
			return commandChecker.postpone(arg);
		case "forward":
			return commandChecker.forward(arg);
		case "add-remind":
			return commandChecker.addRemind(arg);
		case "remind":
			return commandChecker.remind(arg);
		case "add-remind-bef":
			return commandChecker.addRemindBef(arg);
		case "remind-bef":
			return commandChecker.remindBef(arg);
		case "done":
			return commandChecker.done(arg);
		case "undone":
			return commandChecker.undone(arg);
		case "exit":
			return commandChecker.exit(arg);
		case "undo":
			return commandChecker.undo(arg);
		case "redo":
			return commandChecker.redo(arg);
		case "reset":
			return commandChecker.reset(arg);
		case "save":
			return commandChecker.save(arg);
		case "open":
			return commandChecker.open(arg);
		case "tab":
			return commandChecker.tab(arg);
		case "invalid":
			return commandChecker.invalid(arg);
		default:

		}
		return new InputException();
	}
}
```
###### /todolist/logic/Logic.java
``` java
package todolist.logic;

import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalUnit;
import java.util.ArrayList;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

import todolist.MainApp;
import todolist.model.Category;
import todolist.model.Name;
import todolist.model.Reminder;
import todolist.model.SearchCommand;
import todolist.model.Task;
import todolist.model.TokenizedCommand;
import todolist.parser.MainParser;
import todolist.storage.DataBase;

public class Logic {

	private MainApp mainApp;
	public DataBase dataBase;
	private UIHandler uiHandler;
	private MainParser mainParser;
	private CaseSwitcher caseSwitcher;
	private int steps;
	private Logger logger = Logger.getLogger("Logic Logger");
	ArrayList<Task>[] snapshot;

	private static String LOGGING_ADDING_FLOATING_TASK = "tring to add floating task: ";
	private static String LOGGING_ADDING_EVENT = "tring to add event: ";
	private static String LOGGING_ADDING_DEADLINE = "tring to add deadline: ";
	private static String LOGGING_EDITING_TASK = "tring to edit task: ";
	private static String LOGGING_SEARCHING_TASK = "tring to search task: ";
	private static String LOGGING_DELETING_TASK = "tring to delete task: ";
	private static String LOGGING_REPEATED_TASK = "The task has already existed: ";
	private static String LOGGING_TIME_ERROR = "This time was in the past";

	public Logic(MainApp mainApp) {
		this.setMainApp(mainApp);
		this.dataBase = new DataBase();
		this.mainParser = new MainParser();
		this.uiHandler = new UIHandler(dataBase, mainApp, this);
		this.caseSwitcher = new CaseSwitcher(this);
		this.steps = 0;
		snapshot = new ArrayList[1000];
		snapshot[0] = dataBase.retrieveAll();
	}

	public void clean() {
		this.dataBase.clear();
	}

	public void invalid(String keyword) {
		
	}

	public UIHandler getUIHandler() {
		return uiHandler;
	}

	/**
	 * This method takes in raw user input and process it by calling parser
	 *
	 * @param String
	 *            take in the user input string
	 * @return void
	 */
	public void process(String input) {
		TokenizedCommand tokenizedCommand = mainParser.parse(input);
		caseSwitcher.execute(tokenizedCommand);
	}

	public Boolean openNewFile(String path) {
		return dataBase.openNewFile(path);
	}

	/**
	 * This method takes in an integer and increment the internal step counter
	 *
	 * @param int
	 * @return void
	 */
	public void stepForward() {
		this.steps++;
		snapshot[steps] = dataBase.retrieveAll();
	}

	/**
	 * This method returns the current step number
	 *
	 * 
	 * @return int
	 */
	public int checkStep() {
		return this.steps;
	}

	public void tab(String workplace) {
		switch (workplace) {
		case "home":
			uiHandler.tab(1);
			break;
		case "expired":
			uiHandler.tab(2);
			break;
		case "today":
			uiHandler.tab(3);
			break;
		case "week":
			uiHandler.tab(4);
			break;
		case "done":
			uiHandler.tab(5);
			break;
		case "options":
			uiHandler.tab(6);
			break;
		case "help":
			uiHandler.tab(7);
			break;
		}
	}

	/**
	 * This method resets the view
	 *
	 * 
	 * @return void
	 */
	public void reset() {
		uiHandler.refresh();
		uiHandler.sendMessage("View refreshed. All search and filter results are cleared!", true);
	}

	/**
	 * This method adds an recurring event
	 *
	 * 
	 * @return void
	 */
	public Boolean addRecurringEvent(String interval, String title, String startDate, String startTime, String quantity,
			String timeUnit) {
		Boolean addResponse = addEvent(title, startDate, startTime, quantity, timeUnit);
		Boolean setRecurringResponse = setRecurring(title, true, interval);
		return addResponse && setRecurringResponse;
	}

	/**
	 * This method adds an recurring deadline
	 *
	 * 
	 * @return void
	 */
	public Boolean addRecurringDeadline(String interval, String title, String endDate, String endTime) {
		Boolean addResponse = addDeadline(title, endDate, endTime);
		Boolean setRecurringResponse = setRecurring(title, true, interval);
		return addResponse && setRecurringResponse;
	}

	public Boolean addRecurringEventLess(String interval, String title, String fuzzyTime, String quantity,
			String timeUnit) {
		Boolean addResponse = addEventLess(title, fuzzyTime, quantity, timeUnit);
		Boolean setRecurringResponse = setRecurring(title, true, interval);
		return addResponse && setRecurringResponse;
	}

	public Boolean addRecurringDeadlineLess(String interval, String title, String fuzzyTime) {
		Boolean addResponse = addDeadlineLess(title, fuzzyTime);
		Boolean setRecurringResponse = setRecurring(title, true, interval);
		return addResponse && setRecurringResponse;
	}

	/**
	 * This method adds a new event with start date and duration
	 *
	 * 
	 * @return void
	 */
	public Boolean addEvent(String title, String startDate, String startTime, String quantity, String timeUnit) {

		if (noRepeat(title)) {
			logger.log(Level.INFO, LOGGING_ADDING_EVENT + title + startDate + startTime + quantity + timeUnit);

			Name name = new Name(title);
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
			LocalDateTime start = LocalDateTime.parse(fuzzyParseDate(startDate) + " " + startTime, formatter);
			LocalDateTime end = start.plus(Long.parseLong(quantity), generateTimeUnit(timeUnit));

			// System.out.println(start);

			if (!start.isAfter(LocalDateTime.now())) {
				logger.log(Level.INFO, LOGGING_TIME_ERROR + title);
				uiHandler.sendMessage(
						"Oh no! [" + title + "] is currently ongoing! Please attend it before it's too late!", true);
			}

			Task newEvent = new Task(name, start, end, null, null, false, false, null);

			Boolean addResponse = dataBaseAdd(newEvent);
			uiHandler.refresh();
			uiHandler.highLight(newEvent);
			uiHandler.sendMessage("A new event [" + newEvent.getName().getName()
					+ "] has been created successfully! [not what you want? try 'undo']", true);
			return addResponse;
		} else {
			return false;
		}
	}

	public String fuzzyParseDate(String fuzzyDate) {
		String myDate = null;
		int count = fuzzyDate.length() - fuzzyDate.replace("-", "").length();
		if (count == 1) {
			myDate = LocalDateTime.now().getYear() + "-" + fuzzyDate;
		} else {
			if (count == 2) {
				myDate = fuzzyDate;
			}
		}
		return myDate;
	}

	public LocalDateTime fuzzyParseTime(String fuzzyTime) {
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
		String myTime = null;

		DecimalFormat decimalFormatter = new DecimalFormat("00");

		if (fuzzyTime.contains("-")) {
			int count = fuzzyTime.length() - fuzzyTime.replace("-", "").length();
			if (count == 1) {
				myTime = LocalDateTime.now().getYear() + "-" + fuzzyTime + " " + "00:00";
			} else {
				if (count == 2) {
					myTime = fuzzyTime + " " + "00:00";
				}
			}
		} else {
			if (fuzzyTime.contains(":")) {
				myTime = LocalDateTime.now().getYear() + "-"
						+ decimalFormatter.format(LocalDateTime.now().getMonthValue()) + "-"
						+ decimalFormatter.format(LocalDateTime.now().getDayOfMonth()) + " " + fuzzyTime;
				// System.out.println(myTime);
			} else {
				uiHandler.sendMessage("no time or date detected", true);
			}
		}
		return LocalDateTime.parse(myTime, formatter);
	}

	public Boolean addEventLess(String title, String fuzzyTime, String quantity, String timeUnit) {

		if (noRepeat(title)) {
			logger.log(Level.INFO, LOGGING_ADDING_EVENT + title + fuzzyTime + quantity + timeUnit);

			LocalDateTime start = fuzzyParseTime(fuzzyTime);
			LocalDateTime end = start.plus(Long.parseLong(quantity), generateTimeUnit(timeUnit));

			Name name = new Name(title);

			if (!start.isAfter(LocalDateTime.now())) {
				logger.log(Level.INFO, LOGGING_TIME_ERROR + title);
				uiHandler.sendMessage(
						"Oh no! [" + title + "] is currently ongoing! Please attend it before it's too late!", true);
			}

			Task newEvent = new Task(name, start, end, null, null, false, false, null);

			Boolean addResponse = dataBaseAdd(newEvent);
			uiHandler.refresh();
			uiHandler.highLight(newEvent);
			uiHandler.sendMessage("A new event [" + newEvent.getName().getName()
					+ "] has been created successfully! [not what you want? try 'undo']", true);
			return addResponse;
		} else {
			return false;
		}
	}

	/**
	 * This method adds a new deadline.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean addDeadline(String title, String endDate, String endTime) {

		if (noRepeat(title)) {
			logger.log(Level.INFO, LOGGING_ADDING_DEADLINE + title + endDate + endTime);

			Name name = new Name(title);
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
			LocalDateTime end = LocalDateTime.parse(fuzzyParseDate(endDate) + " " + endTime, formatter);
			Task newEvent = new Task(name, null, end, null, null, false, false, null);

			if (!end.isAfter(LocalDateTime.now())) {
				logger.log(Level.INFO, LOGGING_TIME_ERROR + title);
				uiHandler.sendMessage(
						"Oh no! ToDoList currently does not support time travelling! Try creating a task that is due after now.",
						true);
			}

			Boolean addResponse = dataBaseAdd(newEvent);
			uiHandler.refresh();
			uiHandler.highLight(newEvent);
			uiHandler.sendMessage("A new deadline [" + newEvent.getName().getName()
					+ "] has been created successfully. [not what you want? try 'undo']", true);
			return addResponse;
		} else {
			return false;
		}
	}

	public Boolean addDeadlineLess(String title, String fuzzyTime) {

		if (noRepeat(title)) {
			logger.log(Level.INFO, LOGGING_ADDING_DEADLINE + title + fuzzyTime);

			Name name = new Name(title);
			LocalDateTime end = fuzzyParseTime(fuzzyTime);
			Task newEvent = new Task(name, null, end, null, null, false, false, null);

			if (!end.isAfter(LocalDateTime.now())) {
				logger.log(Level.INFO, LOGGING_TIME_ERROR + title);
				uiHandler.sendMessage(
						"Oh no! ToDoList currently does not support time travelling! Try creating a task that is due after now.",
						true);
			}

			Boolean addResponse = dataBaseAdd(newEvent);
			uiHandler.refresh();
			uiHandler.highLight(newEvent);
			uiHandler.sendMessage("A new deadline [" + newEvent.getName().getName()
					+ "] has been created successfully. [not what you want? try 'undo']", true);
			return addResponse;
		} else {
			return false;
		}
	}

	/**
	 * This method adds a new floating task.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean addTask(String title) {

		if (noRepeat(title)) {
			logger.log(Level.INFO, LOGGING_ADDING_FLOATING_TASK + title);

			Name name = new Name(title);
			Task newEvent = new Task(name, null, null, null, null, false, false, null);

			Boolean addResponse = dataBaseAdd(newEvent);
			uiHandler.refresh();
			uiHandler.highLight(newEvent);
			uiHandler.sendMessage("A new un-dated task [" + title
					+ "] has been created successfully. [not what you want? try 'undo']", true);
			return addResponse;
		} else {
			return false;
		}
	}

	private String getCurrentTimeStamp() {
		SimpleDateFormat sdfDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");// dd/MM/yyyy
		Date now = new Date();
		String strDate = sdfDate.format(now);
		return strDate;
	}

	/**
	 * This method takes in the title of a task and marks it as done.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean done(String title) {

		logger.log(Level.INFO, LOGGING_EDITING_TASK + title);

		if (noRepeat(title)) {
			return false;
		}

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBaseDelete(tempTask);

		tempTask.setDoneStatus(true);
		String tempName = tempTask.getName().getName();
		tempTask.setName(new Name(tempName + " finished on " + getCurrentTimeStamp()));

		Boolean addResponse = dataBaseAdd(tempTask);

		if (tempTask.getRecurringStatus()) {

			String interval = tempTask.getInterval();
			String temp[] = interval.split("-");
			String length = temp[0];
			String unit = temp[1];

			LocalDateTime oldEndTime = tempTask.getEndTime();
			LocalDateTime newEndTime = oldEndTime.plus(Long.parseLong(length), generateTimeUnit(unit));
			LocalDateTime newStartTime = null;
			if (tempTask.getStartTime() != null) {
				LocalDateTime oldStartTime = tempTask.getStartTime();
				newStartTime = oldStartTime.plus(Long.parseLong(length), generateTimeUnit(unit));
			}

			Task newTempTask = new Task(new Name(tempName), newStartTime, newEndTime, tempTask.getCategory(),
					tempTask.getReminder(), false, true, interval);
			addResponse = dataBaseAdd(newTempTask);

		}

		uiHandler.refresh();
		uiHandler.highLight(tempTask);
		// <<<<<<< Updated upstream
		uiHandler.sendMessage(
				"[" + title
						+ "] has been marked as completed! Woohoo another one down! [not what you want? try 'undo']",
				true);
		// =======
		uiHandler.sendMessage(
				"[" + title
						+ "] has been marked as completed! Woohoo another one down! [not what you want? try 'undo']",
				true);
		// >>>>>>> Stashed changes

		return deleteResponse && addResponse;
	}

	public Boolean undone(String title) {

		logger.log(Level.INFO, LOGGING_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBaseDelete(tempTask);

		tempTask.setDoneStatus(false);
		Boolean addResponse = dataBaseAdd(tempTask);

		uiHandler.refresh();
		uiHandler.highLight(tempTask);
		uiHandler.sendMessage(
				"[" + title + "] has been marked as ongoing! Go get it TIGER! [not what you want? try 'undo']", true);

		return deleteResponse && addResponse;
	}

	/**
	 * This method edits a task.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean edit(String title, String fieldName, String newValue) {

		logger.log(Level.INFO, LOGGING_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBaseDelete(tempTask);

		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd-HH:mm");

		switch (fieldName) {
		case "title":
			tempTask.setName(new Name(newValue));
			break;
		case "done":
			tempTask.setDoneStatus(true);
			break;
		case "undone":
			tempTask.setDoneStatus(false);
			break;
		case "start-time":
			LocalDateTime start = null;

			if (newValue.equals("remove")) {
				start = null;
			} else {
				start = LocalDateTime.parse(newValue, formatter);
			}
			tempTask.setStartTime(start);
			break;
		case "end-time":
			LocalDateTime end = null;

			if (newValue.equals("remove")) {
				end = null;
			} else {
				end = LocalDateTime.parse(newValue, formatter);
			}
			tempTask.setEndTime(end);
			break;
		}

		Boolean addResponse = dataBaseAdd(tempTask);

		uiHandler.refresh();
		uiHandler.highLight(tempTask);
		uiHandler.sendMessage("[" + title + "] has been edited successfully! [not what you want? try 'undo']", true);

		return deleteResponse && addResponse;

	}

	/**
	 * This method takes in the title of a task and deletes it.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean delete(String title) {

		logger.log(Level.INFO, LOGGING_DELETING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBaseDelete(tempTask);

		uiHandler.refresh();
		uiHandler.sendMessage("[" + title + "] has been deleted successfully! [not what you want? try 'undo']", true);

		return deleteResponse;
	}

	/**
	 * This method takes in the title of a task and displays it.
	 *
	 * 
	 * @return void
	 */
	public void search(String[] keyword) {
		String input = keyword[0];
		
		for(int i=1;i<keyword.length;i++) {
			input = input + " " + keyword[i];
		}
		
		logger.log(Level.INFO, LOGGING_SEARCHING_TASK + input);

		ArrayList<Task> tempTaskList = dataBase.smartSearch(keyword);

		uiHandler.display(tempTaskList);
		uiHandler.sendMessage("Here are your search results for '" + input + "'! [to clear this search, type 'reset']",
				true);
	}

	/**
	 * This method takes in the name of a category and displays tasks of that
	 * category.
	 *
	 * 
	 * @return void
	 */
	public void filter(String category) {

		logger.log(Level.INFO, LOGGING_SEARCHING_TASK + category);

		ArrayList<Task> tempTaskList = dataBase.retrieve(new SearchCommand("CATEGORY", category));

		uiHandler.display(tempTaskList);
		uiHandler.sendMessage(
				"Here are the related tasks under " + category.toUpperCase() + "! [to clear this filter, type 'reset']",
				true);
	}

	/**
	 * This method sorts all tasks in according to the field name and order.
	 *
	 * 
	 * @return void
	 */
	public void sort(String fieldName, String order) {
		if (fieldName.isEmpty()) {
			uiHandler.sendMessage(
					"Please specify a sorting order! Try sort ['start' | 'end' | 'category' | 'name'], followed by [ascending | descending].",
					true);
		}
		dataBase.sort(fieldName, order);
		uiHandler.refresh();
		uiHandler.sendMessage(
				"Ta-da! Your tasks have been sorted by " + fieldName + "! [not what you want? try 'undo']", true);
	}
	//
	// public void insert(String title, String befaft, String title) {
	// uiHandler.insert(title, befaft, title);
	// }
	//

	/*
	 * public void switchPosition(String title1, String title2) {
	 * uiHandler.insert(title1, "aft", title2); }
	 */

	/**
	 * This method takes in the title of a task and labels it with a category.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean label(String title, String category) {

		logger.log(Level.INFO, LOGGING_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBaseDelete(tempTask);

		tempTask.setCategory(new Category(category));
		Boolean addResponse = dataBaseAdd(tempTask);

		uiHandler.refresh();
		uiHandler.highLight(tempTask);
		uiHandler.sendMessage("You have categorised [" + title + "] under " + category.toUpperCase()
				+ " ! [not what you want? try 'undo']", true);

		return deleteResponse && addResponse;
	}

	/**
	 * This method edits the recurring status of a task.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean setRecurring(String title, Boolean status, String interval) {
		logger.log(Level.INFO, LOGGING_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBaseDelete(tempTask);
		if (tempTask.getEndTime() == null) {
			throw new RuntimeException();
		}
		tempTask.setRecurring(status);
		tempTask.setInterval(interval);
		Boolean addResponse = dataBaseAdd(tempTask);

		uiHandler.refresh();
		uiHandler.highLight(tempTask);

		if (status) {
			uiHandler.sendMessage("[" + title + "] is now a recurring task! [not what you want? try 'undo']", true);
		} else {
			uiHandler.sendMessage("[" + title + "] is now an ad-hoc task! [not what you want? try 'undo']", true);
		}

		return deleteResponse && addResponse;
	}

	/**
	 * This method postpones a task by a duration.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean postpone(String title, String quantity, String timeUnit) {

		logger.log(Level.INFO, LOGGING_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBaseDelete(tempTask);

		Boolean addResponse = false;

		if (tempTask.getStartTime() == null) {
			LocalDateTime tempEndTime = tempTask.getEndTime();
			tempEndTime = tempEndTime.plus(Long.parseLong(quantity), generateTimeUnit(timeUnit));

			tempTask.setEndTime(tempEndTime);
			addResponse = dataBaseAdd(tempTask);

			uiHandler.refresh();
			uiHandler.highLight(tempTask);
		} else {
			LocalDateTime tempStartTime = tempTask.getStartTime();
			LocalDateTime tempEndTime = tempTask.getEndTime();
			tempStartTime = tempStartTime.plus(Long.parseLong(quantity), generateTimeUnit(timeUnit));
			tempEndTime = tempEndTime.plus(Long.parseLong(quantity), generateTimeUnit(timeUnit));

			tempTask.setStartTime(tempStartTime);
			tempTask.setEndTime(tempEndTime);

			addResponse = dataBaseAdd(tempTask);

			uiHandler.refresh();
			uiHandler.highLight(tempTask);
			uiHandler.sendMessage("[" + title + "] has been postponed! [not what you want? try 'undo']", true);
		}

		return deleteResponse && addResponse;
	}

	/**
	 * This method forwards a task by a duration.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean forward(String title, String quantity, String timeUnit) {

		logger.log(Level.INFO, LOGGING_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		Boolean deleteResponse = dataBaseDelete(tempTask);

		Boolean addResponse = false;

		if (tempTask.getStartTime() == null) {
			LocalDateTime tempEndTime = tempTask.getEndTime();
			tempEndTime = tempEndTime.minus(Long.parseLong(quantity), generateTimeUnit(timeUnit));

			tempTask.setEndTime(tempEndTime);
			addResponse = dataBaseAdd(tempTask);

			uiHandler.refresh();
			uiHandler.highLight(tempTask);
		} else {
			LocalDateTime tempStartTime = tempTask.getStartTime();
			LocalDateTime tempEndTime = tempTask.getEndTime();
			tempStartTime = tempStartTime.minus(Long.parseLong(quantity), generateTimeUnit(timeUnit));
			tempEndTime = tempEndTime.minus(Long.parseLong(quantity), generateTimeUnit(timeUnit));

			tempTask.setStartTime(tempStartTime);
			tempTask.setEndTime(tempEndTime);

			addResponse = dataBaseAdd(tempTask);

			uiHandler.refresh();
			uiHandler.highLight(tempTask);
			uiHandler.sendMessage("[" + title + "] has been rescheduled forward! [not what you want? try 'undo']",
					true);
		}

		return deleteResponse && addResponse;
	}

	/**
	 * This method adds a task with remind and triggers the remind at the
	 * deadline.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean addRemind(String[] arg) {

		Boolean addResponse = false;

		String type = arg[0];
		switch (type) {
		case "event":
			addResponse = addEvent(arg[1], arg[2], arg[3], arg[4], arg[5]);
			break;
		case "deadline":
			addResponse = addDeadline(arg[1], arg[2], arg[3]);
			break;
		case "task":
			addResponse = addTask(arg[1]);
			break;
		}

		remind(arg[1]);

		return addResponse;
	}

	/**
	 * This method adds a task with remind and triggers the remind a duration
	 * before the deadline.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean addRemindBef(String quantity, String timeUnit, String[] arg) {

		String type = arg[0];

		Boolean addResponse = false;

		switch (type) {
		case "event":
			addResponse = addEvent(arg[1], arg[2], arg[3], arg[4], arg[5]);
			break;
		case "deadline":
			addResponse = addDeadline(arg[1], arg[2], arg[3]);
			break;
		case "task":
			addResponse = addTask(arg[1]);
			break;
		}

		remindBef(arg[1], quantity, timeUnit);

		return addResponse;
	}

	/**
	 * This method adds remind to an existing task and triggers the remind a
	 * duration before the deadline.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean remindBef(String title, String quantity, String timeUnit) {

		logger.log(Level.INFO, LOGGING_EDITING_TASK + title);

		Task tempTask = dataBase.retrieve(new SearchCommand("NAME", title)).get(0);
		LocalDateTime reminderTime = null;

		if (quantity == null) {
			if (tempTask.getStartTime() == null) {
				reminderTime = tempTask.getStartTime();
			} else {
				reminderTime = tempTask.getEndTime();
			}
		} else {
			if (tempTask.getStartTime() != null) {
				reminderTime = tempTask.getStartTime().minus(Long.parseLong(quantity), generateTimeUnit(timeUnit));
			} else {
				reminderTime = tempTask.getEndTime().minus(Long.parseLong(quantity), generateTimeUnit(timeUnit));
			}
		}

		Boolean deleteResponse = dataBaseDelete(tempTask);

		Reminder newReminder = new Reminder(true, reminderTime);

		tempTask.setReminder(newReminder);

		Boolean addResponse = dataBaseAdd(tempTask);

		uiHandler.refresh();
		uiHandler.highLight(tempTask);

		return deleteResponse && addResponse;
	}

	/**
	 * This method adds remind to an existing task and triggers the remind at
	 * the deadline.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean remind(String title) {

		logger.log(Level.INFO, LOGGING_EDITING_TASK + title);

		return remindBef(title, "0", "minute");
	}

	/**
	 * This method terminates the application.
	 *
	 * 
	 * @return void
	 */
	public void exit() {
		System.exit(0);
	}

	/**
	 * This method takes in an integer and undo that number of steps.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean undo(int undostep) {
		Boolean undoResponse = false;
		if (steps - undostep < 0) {
			uiHandler.sendMessage("Undo was unsuccessful. No actions to undo!", true);
			return false;
		}

		steps = steps - undostep;

		undoResponse = dataBase.recover(snapshot[steps]);

		if (undoResponse) {
			uiHandler.sendMessage("Undo #" + undostep + " step(s) successfully!", true);
		} else {
			uiHandler.sendMessage("Undo was unsuccessful. Try again!", true);
		}

		uiHandler.refresh();
		for(ArrayList<Task> list: snapshot) {
			System.out.println("print each step:   " + list.size());
			if(snapshot[0]!=snapshot[1]) {
				System.out.println("not equalllll  ");
			}
		}
		
		return undoResponse;
	}

	/**
	 * This method takes in an integer and redo that number of steps.
	 *
	 * 
	 * @return Boolean
	 */
	public Boolean redo(int redostep) {
		Boolean redoResponse = false;
		if(snapshot[steps + redostep] == null) {
			uiHandler.sendMessage("Redo was unsuccessful. No actions to redo!", true);
			return false;
		}

		steps = steps + redostep;
		redoResponse = dataBase.recover(snapshot[steps]);
		if (redoResponse) {
			uiHandler.sendMessage("Redo #" + redostep + " step(s) successfully!", true);
		} else {
			uiHandler.sendMessage("Redo was unsuccessful. Try again!", true);
		}
		uiHandler.refresh();
		return redoResponse;
	}

	public boolean setNewFile(String path) {
		return dataBase.setNewFile(path);
	}

	private TemporalUnit generateTimeUnit(String unit) {
		switch (unit) {
		case "day":
			return ChronoUnit.DAYS;
		case "hour":
			return ChronoUnit.HOURS;
		case "minute":
			return ChronoUnit.MINUTES;
		case "week":
			return ChronoUnit.WEEKS;
		case "month":
			return ChronoUnit.MONTHS;
		case "year":
			return ChronoUnit.YEARS;
		default:
			return null;
		}
	}

	private Boolean dataBaseAdd(Task task) {
		return dataBase.add(task);

	}

	private Boolean dataBaseDelete(Task task) {
		return dataBase.delete(task);
	}

	private Boolean noRepeat(String title) {
		ArrayList<Task> tempTaskList = dataBase.retrieve(new SearchCommand("NAME", title));
		// System.out.println(tempTaskList.size());

		if (tempTaskList.size() > 0) {
			logger.log(Level.INFO, LOGGING_REPEATED_TASK + title);
			uiHandler.sendMessage("You have added a task with same name before! Try another name!", true);
			return false;
		} else {
			return true;
		}
	}

	public MainApp getMainApp() {
		return mainApp;
	}

	public void setMainApp(MainApp mainApp) {
		this.mainApp = mainApp;
	}
}
```
###### /todolist/logic/MainAppStub.java
``` java
package todolist.logic;

import java.util.ArrayList;

import todolist.MainApp;
import todolist.model.Task;

public class MainAppStub extends MainApp{
	public MainAppStub() {
		super();
	}
	
	@Override
	public void setDisplayTasks(ArrayList<Task> listOfTasks) {
		
	}
	
	@Override
	public void notifyWithText(String message, boolean isAutohide) {
		
	}
}
```
###### /todolist/logic/Sorter.java
``` java
package todolist.logic;

public class Sorter {
    
}
```
###### /todolist/logic/UIHandler.java
``` java
package todolist.logic;

import java.util.ArrayList;

import todolist.MainApp;
import todolist.model.Task;
import todolist.storage.DataBase;

public class UIHandler {

    private DataBase dataBase;
    private MainApp mainApp;
    private Logic logic;

    public UIHandler(DataBase dataBase, MainApp mainApp, Logic logic) {
        this.dataBase = dataBase;
        this.mainApp = mainApp;
        this.logic = logic;
    }

    public void process(String input) {
        logic.process(input);
    }

    public void refresh() {
        mainApp.setDisplayTasks(dataBase.retrieveAll());
    }

    public void sendMessage(String message, boolean autohide) {
        mainApp.notifyWithText(message, autohide);
    }

    public void highLight(Task task) {
        mainApp.highlightItem(task);
    }

    public void display(ArrayList<Task> taskList) {
        mainApp.setDisplayTasks(taskList);
    }

    public void tab(int index) {
        mainApp.loadPage(index);
    }
}
```
###### /todolist/model/Category.java
``` java
package todolist.model;

public class Category implements Comparable<Category>{
    private String category;
	public Category(String category) {
    	this.category = category;
    }
	@Override
	public int compareTo(Category o) {
		return this.category.compareToIgnoreCase(o.getCategory());
	}
	
	public String getCategory() {
		return category;
	}
}
```
###### /todolist/model/InputException.java
``` java
package todolist.model;

import todolist.logic.ErrorBase;

public class InputException {
	String commandType = null;
	String errorType = null;
	Boolean error = true;
	
	public InputException() {
		this.error = true;
	}
	
	public InputException(String commandType, String errorType) {
		this.commandType = commandType;
		this.errorType = errorType;
		this.error = false;
	}
	
	public String getCommandType() {
		return commandType;
	}
	
	public String getErrorType() {
		return errorType;
	}
	
	public String getErrorMessage() {
		return new ErrorBase().getErrorMessage(commandType, errorType);
	}
	
	public Boolean getCorrectness() {
		return this.error;
	}
}
```
###### /todolist/model/Name.java
``` java
package todolist.model;

public class Name implements Comparable<Name>{

	private String name;
	
	public Name(String name) {
	    this.name = name;
	}
	
	@Override
	public int compareTo(Name o) {
		// TODO Auto-generated method stub
		return 0;
	}
	
	public String getName() {
	    return name;
	}
}
```
###### /todolist/model/Reminder.java
``` java
package todolist.model;

import java.time.LocalDateTime;

public class Reminder {
    
    private Boolean switcher = null;
    private LocalDateTime time = null;
    
    public Reminder(Boolean switcher, LocalDateTime time) {
        this.switcher = switcher;
        this.time = time;
    }
        
    public Boolean getStatus() {
        return switcher;
    }
    
    public LocalDateTime getTime() {
        return time;
    }
}
```
###### /todolist/model/SearchCommand.java
``` java
package todolist.model;

public class SearchCommand {
	private String type = null;
	private String content = null;
	
	public SearchCommand(String type, String content) {
		this.type = type;
		this.content = content;
	}

    public String getType() {
    	return type;
    }
    
    public String getContent() {
    	return content;
    }

}
```
###### /todolist/model/Task.java
``` java
package todolist.model;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalUnit;

public class Task {
	private Name name = null;
	private LocalDateTime startTime = null;
	private LocalDateTime endTime = null;
	private Category category = null;
	private Reminder reminder = null;
	private Boolean isDone = null;
	private Boolean isRecurring = null;
	private String interval = null;

	public Task(Name name, LocalDateTime startTime, LocalDateTime endTime, Category category, Reminder reminder,
			Boolean isDone, Boolean recurring, String interval) {
		this.name = name;
		this.startTime = startTime;
		this.endTime = endTime;
		this.category = category;
		this.reminder = reminder;
		this.isDone = isDone;
		this.isRecurring = recurring;
		this.interval = interval;
	}

	public void setName(Name name) {
		this.name = name;
	}

	public void setStartTime(LocalDateTime startTime) {
		this.startTime = startTime;
	}

	public void setEndTime(LocalDateTime endTime) {
		this.endTime = endTime;
	}

	public void setCategory(Category category) {
		this.category = category;
	}

	public void setReminder(Reminder reminder) {
		this.reminder = reminder;
	}

	public void setDoneStatus(Boolean isDone) {
		this.isDone = isDone;
	}

	public void setRecurring(Boolean isRecurring) {
		this.isRecurring = isRecurring;
	}

	public void setInterval(String interval) {
		this.interval = interval;
	}

	///////////////////////////////////////////

	public Name getName() {
		return name;
	}

	public LocalDateTime getStartTime() {
		/*
		if (isRecurring && startTime != null) {
			String temp[] = interval.split("-");
			String length = temp[0];
			String unit = temp[1];
			LocalDateTime now = LocalDateTime.now();
			while (now.isAfter(startTime)) {
				startTime = startTime.plus(Long.parseLong(length), generateTimeUnit(unit));
			}
			return startTime;
		} else {
		*/
			return startTime;
		//}
	}

	public LocalDateTime getEndTime() {
		/*
		if (isRecurring) {
			String temp[] = interval.split("-");
			String length = temp[0];
			String unit = temp[1];

			if (endTime == null) {
                throw new RuntimeException();
            }
			
			if (startTime != null) {
				while (startTime.isAfter(endTime)) {
					endTime = endTime.plus(Long.parseLong(length), generateTimeUnit(unit));
				}
				return endTime;
			} else {
				LocalDateTime now = LocalDateTime.now();
			
				while (now.isAfter(endTime)) {
					endTime = endTime.plus(Long.parseLong(length), generateTimeUnit(unit));
				}
				return endTime;
			}
		} else {
		*/
			return endTime;
		//}
	}

	public Category getCategory() {
		return category;
	}

	public Reminder getReminder() {
		return reminder;
	}

	public Boolean getDoneStatus() {
		return isDone;
	}

	public Boolean getRecurringStatus() {
		return isRecurring;
	}

	public String getInterval() {
		return interval;
	}

	@SuppressWarnings("unused")
    private TemporalUnit generateTimeUnit(String unit) {
		switch (unit) {
		case "day":
			return ChronoUnit.DAYS;
		case "hour":
			return ChronoUnit.HOURS;
		case "minute":
			return ChronoUnit.MINUTES;
		case "week":
			return ChronoUnit.WEEKS;
		case "month":
			return ChronoUnit.MONTHS;
		case "year":
			return ChronoUnit.YEARS;
		default:
			return null;
		}
	}
}
```
###### /todolist/model/TokenizedCommand.java
``` java
package todolist.model;

public class TokenizedCommand {
	
  private String action = null;
  private String args[];

  public TokenizedCommand(String action, String[] args) {
	  this.action = action;
	  this.args = args;
  }
    
  public String getAction() {
      return action;
  }
  
  public String[] getArgs() {
      return args;
  }
}
```
###### /todolist/parser/FlexiCommandParser.java
``` java
package todolist.parser;

import java.text.DecimalFormat;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.List;
import java.util.TimeZone;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

import todolist.model.TokenizedCommand;

public class FlexiCommandParser {

	public FlexiCommandParser() {

	}

	public TokenizedCommand parse(String input) {

		@SuppressWarnings("unused")
        String temp[] = input.split(" ");
		
		/*
		for (int i = 0; i < temp.length; i++) {
			if (temp[i].equals("add") || temp[i].equals("edit") || temp[i].equals("delete") || temp[i].equals("search")
					|| temp[i].equals("filter") || temp[i].equals("sort") || temp[i].equals("insert")
					|| temp[i].equals("switchposition") || temp[i].equals("label") || temp[i].equals("postpone")
					|| temp[i].equals("forward") || temp[i].equals("add-remind") || temp[i].equals("remind")
					|| temp[i].equals("add-remind-bef") || temp[i].equals("remind-bef") || temp[i].equals("done")
					|| temp[i].equals("undone") || temp[i].equals("exit") || temp[i].equals("undo")
					|| temp[i].equals("redo") || temp[i].equals("reset") || temp[i].equals("tab")
					|| temp[i].equals("set-recurring") || temp[i].equals("remove-recurring") || temp[i].equals("create")
					|| temp[i].equals("schedule") || temp[i].equals("cancel") || temp[i].equals("remove")
					|| temp[i].equals("modify") || temp[i].equals("change") || temp[i].equals("replace")
					|| temp[i].equals("archive") || temp[i].equals("complete") || temp[i].equals("finish")
					|| temp[i].equals("shelf") || temp[i].equals("unarchive") || temp[i].equals("incomplete")
					|| temp[i].equals("unfinish") || temp[i].equals("unshelf") || temp[i].equals("delay")
					|| temp[i].equals("advance") || temp[i].equals("categorize") || temp[i].equals("tag")
					|| temp[i].equals("load") || temp[i].equals("save") || temp[i].equals("open")) {

				return new TokenizedCommand("invalid", temp);
			}
		}
		*/

		Parser parser = new Parser(TimeZone.getTimeZone(ZoneOffset.systemDefault()));
		List<DateGroup> groups = parser.parse(input);
		List<Date> dates = null;
		int[] column = new int[] { 0, 0 };
		int[] length = new int[] { 0, 0 };
		int counter = 0;
		for (DateGroup group : groups) {
			dates = group.getDates();
			// int line = group.getLine();
			// int column = group.getPosition();
			// String matchingValue = group.getText();
			// String syntaxTree = group.getSyntaxTree().toStringTree();
			// Map parseMap = group.getParseLocations();
			// boolean isRecurreing = group.isRecurring();
			// Date recursUntil = group.getRecursUntil();
			column[counter] = group.getPosition();
			length[counter] = group.getText().length();
			counter++;
		}

		System.out.println(dates);
		System.out.println(column[0] + " " + length[0]);
		System.out.println(column[1] + " " + length[1]);

		String result = null;

		if (dates == null || dates.size() == 0) {
			return new TokenizedCommand("add", new String[] { "task", input });
		} else {
			if (column[1] == 0) {
				System.out.println(input.substring(0, column[0] - 1));
				System.out.println(input.substring(column[0] + length[0] - 1));

				result = input.substring(0, column[0] - 1) + input.substring(column[0] + length[0] - 1);
			} else {
				result = input.substring(0, column[0] - 1) + input.substring(column[0] + length[0], column[1] - 1)
						+ input.substring(column[1] + length[1] - 1);
			}

			if (dates.size() == 1) {
				Date deadline = dates.get(0);

				Instant instant = Instant.ofEpochMilli(deadline.getTime());
				LocalDateTime end = LocalDateTime.ofInstant(instant, ZoneOffset.systemDefault());

				DecimalFormat decimalFormatter = new DecimalFormat("00");
				String deadlineDate = end.getYear() + "-" + decimalFormatter.format(end.getMonthValue()) + "-"
						+ decimalFormatter.format(end.getDayOfMonth());

				String deadlineTime = decimalFormatter.format(end.getHour()) + ":"
						+ decimalFormatter.format(end.getMinute());

				if (end.isBefore(LocalDateTime.now().plus(10, ChronoUnit.SECONDS)) && end.plus(10, ChronoUnit.SECONDS).isAfter(LocalDateTime.now())
						&& input.toLowerCase().contains("today")) {
					// System.out.println("hello");
					deadlineTime = "23:59";
				}

				result = keywordFilter(result);

				if (result.toLowerCase().contains("breakfast")) {
					deadlineTime = "09:00";
				}

				if (result.toLowerCase().contains("lunch")) {
					deadlineTime = "13:00";
				}

				if (result.toLowerCase().contains("dinner")) {
					deadlineTime = "19:00";
				}
				if (result.toLowerCase().contains("supper")) {
					deadlineTime = "23:00";
				}

				/*
				 * String endDate = deadline.getYear() + "-" +
				 * deadline.getMonth() + "-" + deadline.getDay(); String endTime
				 * = deadline.getHours() + ":" + deadline.getMinutes(); return
				 * new TokenizedCommand("add", new String[]{"deadline", input,
				 * endDate, endTime});
				 */

				return new TokenizedCommand("add", new String[] { "deadline", result, deadlineDate, deadlineTime });

			} else {
				DecimalFormat decimalFormatter = new DecimalFormat("00");

				Date startTimeOriginal = dates.get(0);
				Date endTimeOriginal = dates.get(1);

				Instant startInstant = Instant.ofEpochMilli(startTimeOriginal.getTime());
				LocalDateTime start = LocalDateTime.ofInstant(startInstant, ZoneId.systemDefault());

				// Instant endInstant =
				// Instant.ofEpochMilli(endTimeOriginal.getTime());
				// LocalDateTime end = LocalDateTime.ofInstant(endInstant,
				// ZoneId.systemDefault());

				String startDate = start.getYear() + "-" + decimalFormatter.format(start.getMonthValue()) + "-"
						+ decimalFormatter.format(start.getDayOfMonth());

				String startTime = decimalFormatter.format(start.getHour()) + ":"
						+ decimalFormatter.format(start.getMinute());

				int interval = (int) getDateDiff(startTimeOriginal, endTimeOriginal) / 1000 / 60;

				/*
				 * String startDate = start.getYear() + "-" + start.getMonth() +
				 * "-" + start.getDay(); String startTime = start.getHours() +
				 * ":" + start.getMinutes();
				 * 
				 * String endDate = end.getYear() + "-" + end.getMonth() + "-" +
				 * end.getDay(); String endTime = end.getHours() + ":" +
				 * end.getMinutes();
				 */

				// return new TokenizedCommand("add", new String[]{"event",
				// input, startDate, startTime, endDate, endTime});

				result = keywordFilter(result);

				return new TokenizedCommand("add",
						new String[] { "event", result, startDate, startTime, Integer.toString(interval), "minute" });
			}
		}
	}
	
	private String keywordFilter(String input) {
		String result = input;
		if (result.endsWith(" by ")) {
			result = result.substring(0, result.length() - 3);
		}

		if (result.endsWith(" from ")) {
			result = result.substring(0, result.length() - 5);
		}

		if (result.startsWith("From ") || result.startsWith("from ")) {
			result = result.substring(6);
		}
		return result;
	}

	private long getDateDiff(Date date1, Date date2) {
		long diffInMillies = date2.getTime() - date1.getTime();
		return diffInMillies;
	}
}
```
###### /todolist/parser/MainParser.java
``` java
package todolist.parser;

import todolist.model.TokenizedCommand;

public class MainParser {

	private FlexiCommandParser flexiCommandParser;
	private NormalCommandParser normalCommandParser;

	public MainParser() {
		this.setFlexiCommandParser(new FlexiCommandParser());
		this.normalCommandParser = new NormalCommandParser();
	}

	/**
	 * This method takes in a string and parse it.
	 *
	 * 
	 * @return TokenizedCommand
	 */
	public TokenizedCommand parse(String input) {
		if (checkType(input)) {
			return normalCommandParser.parse(input);
		} else {
			// return normalCommandParser.parse(input);
			return flexiCommandParser.parse(input);
		}
	}

	/**
	 * This method takes in a string and check whether it is a flexi command.
	 *
	 * 
	 * @return Boolean
	 */
	private Boolean checkType(String input) {
		String temp[] = input.split(" ");
		String head = temp[0];
		Boolean type = head.equals("add") || head.equals("edit") || head.equals("delete") || head.equals("search")
				|| head.equals("filter") || head.equals("sort") || head.equals("insert")
				|| head.equals("switchposition") || head.equals("label") || head.equals("postpone")
				|| head.equals("forward") || head.equals("add-remind") || head.equals("remind")
				|| head.equals("add-remind-bef") || head.equals("remind-bef") || head.equals("done")
				|| head.equals("undone") || head.equals("exit") || head.equals("undo") || head.equals("redo")
				|| head.equals("reset") || head.equals("tab") || head.equals("set-recurring")
				|| head.equals("remove-recurring") || head.equals("create") || head.equals("schedule")
				|| head.equals("cancel") || head.equals("remove") || head.equals("modify") || head.equals("change")
				|| head.equals("replace") || head.equals("archive") || head.equals("complete") || head.equals("finish")
				|| head.equals("shelf") || head.equals("unarchive") || head.equals("incomplete")
				|| head.equals("unfinish") || head.equals("unshelf") || head.equals("delay") || head.equals("advance")
				|| head.equals("categorize") || head.equals("tag") || head.equals("load") || head.equals("open")
				|| head.equals("save");
		return type;
	}

	public FlexiCommandParser getFlexiCommandParser() {
		return flexiCommandParser;
	}

	public void setFlexiCommandParser(FlexiCommandParser flexiCommandParser) {
		this.flexiCommandParser = flexiCommandParser;
	}
}
```
###### /todolist/parser/NormalCommandParser.java
``` java
package todolist.parser;

import java.util.ArrayList;

import todolist.model.TokenizedCommand;

public class NormalCommandParser {

    public NormalCommandParser() {

    }

    public TokenizedCommand parse(String input) {

        String temp[] = input.split(" ");
        String action = temp[0];

        ArrayList<String> myList = new ArrayList<String>();

        String name = null;
        Boolean generateName = false;
        for (int i = 0; i < temp.length - 1; i++) {

            if (generateName == true) {
                if (temp[i + 1].contains("\"")) {
                    name = name + " " + temp[i + 1].replace("\"", "");
                    generateName = false;
                    myList.add(name);
                    // args[counter] = name;
                    // counter++;
                    name = null;

                } else {
                    name = name + " " + temp[i + 1];
                }
            } else {
                if (temp[i + 1].contains("\"")) {
                    name = temp[i + 1].replace("\"", "");
                    generateName = true;
                    int count = temp[i + 1].length() - temp[i + 1].replace("\"", "").length();
                    if (count == 2) {
                        generateName = false;
                        myList.add(name);
                        // args[counter] = name;
                        // counter++;
                        name = null;
                    }
                } else {
                    myList.add(temp[i + 1]);
                    // args[counter] = temp[i+1];
                    // counter++;
                }
            }
        }

        String[] args = myList.toArray(new String[0]);

        /*
         * String temp0[] = input.split("\" "); String temp1[] = temp0[1].split(
         * " \"");
         * 
         * String first[] = temp0[0].split(" "); String third[] =
         * temp1[1].split(" ");
         * 
         * String second = temp1[0];
         * 
         * int length = first.length + third.length + 1;
         * 
         * 
         * String temp[] = new String[length];
         * 
         * for(int i=0; i< length;i++) { if(i < first.length) { temp[i] =
         * first[i]; } else { if(i > first.length) { temp[i] = third[i -
         * first.length - 1]; } else { temp[i] = second; } } }
         * 
         * String action = temp[0]; String args[] = new String[temp.length - 1];
         * for(int i=0; i<temp.length-1; i++) { args[i] = temp[i + 1]; }
         */

        return new TokenizedCommand(convert(action), args);
    }
    
    
    private String convert(String input) {
    	if(input.equals("add") || input.equals("schedule")||input.equals("create")) {
    		return "add";
    	}
    	if(input.equals("delete") || input.equals("cancel")||input.equals("remove")) {
    		return "delete";
    	}
    	if(input.equals("edit") || input.equals("modify")||input.equals("change")||input.equals("replace")) {
    		return "edit";
    	}
    	if(input.equals("archive") || input.equals("done")||input.equals("complete") || input.equals("shelf") || input.equals("finish")) {
    		return "done";
    	}
    	if(input.equals("unarchive") || input.equals("undone")||input.equals("incomplete") || input.equals("unshelf") || input.equals("unfinish")) {
    		return "undone";
    	}
    	if(input.equals("postpone") || input.equals("delay")) {
    		return "postpone";
    	}
    	if(input.equals("forward") || input.equals("advance")) {
    		return "forward";
    	}
    	if(input.equals("label") || input.equals("categorize")||input.equals("tag")) {
    		return "label";
    	}
    	if(input.equals("open") || input.equals("load")) {
    		return "open";
    	}
    	return input;
    }
}
```
###### /todolist/ui/controllers/MainViewController.java
``` java
    // Temporary attributes for testing
    public String path = "demo.txt";
    public int demoCounter = 0;

```
###### /todolist/ui/controllers/MainViewController.java
``` java
    /*** Temporary Functions for Testing ***/

    public ArrayList<String> demoFileHandler(String path) {
        ArrayList<String> myList = new ArrayList<String>();
        try {

            File file = new File(path);
            Scanner scr = new Scanner(file);
            while (scr.hasNextLine()) {
                String temp = scr.nextLine();
                myList.add(temp);
                System.out.println(temp);
            }
            scr.close();
        } catch (Exception e) {

        }
        return myList;
    }

    Boolean isDemoing = false;

    public void setCommandLineCallbackDemo(TextField commandField) {
        // Set Callback for TextField

        EventHandler<ActionEvent> commandHandler = new EventHandler<ActionEvent>() {

            @Override
            public void handle(ActionEvent event) {
                if (!isDemoing) {
                    String commandString = commandField.getText();
                    // Command command = new Command(commandString);
                    // System.out.println(command.getCommand());

                    // Pass command line input for processing
                    try {

                        commandField.clear();
                        logger.logAction(Component.UI, MESSAGE_CLEAR_TEXTFIELD);
                        if (commandString.equals("Start demo")) {
                            isDemoing = true;
                        } else {
                            mainApplication.uiHandlerUnit.process(commandString);
                            logger.logComponentCall(Component.UI, MESSAGE_CALL_LOGIC_COMPONENT);
                        }
                    } catch (Exception exception) {
                        logger.logError(Component.UI, ERROR_PROCESSING_USER_INPUT);
                        exception.printStackTrace();
                    }
                } else {
                    synchronized (this) {
                        ArrayList<String> demoList = demoFileHandler(path);
                        String commandString = demoList.get(demoCounter);
                        demoCounter++;
                        if (commandString.equals("exit")) {
                            isDemoing = false;
                        } else {
                            // System.out.println(event.getEventType());

                            // Pass command line input for processing
                            commandField.clear();

                            final Animation animation = new Transition() {
                                {
                                    setCycleDuration(new Duration(commandString.length() * 50));
                                }

                                protected void interpolate(double frac) {
                                    final int length = commandString.length();
                                    final int n = Math.round(length * (float) frac);
                                    commandField.setText(commandString.substring(0, n));
                                }

                            };

                            animation.setOnFinished(new EventHandler<ActionEvent>() {
                                @Override
                                public void handle(ActionEvent event) {
                                    mainApplication.uiHandlerUnit.process(commandString);
                                }
                            });

                            animation.play();
                        }
                    }
                }
            }
        };

        commandField.setOnAction(commandHandler);
    }

```
