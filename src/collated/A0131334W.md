# A0131334W
###### /todolist/common/tests/CommandTest.java
``` java
package todolist.common.tests;

import static org.junit.Assert.*;

import java.text.DecimalFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

import todolist.MainApp;
import todolist.logic.Logic;
import todolist.logic.MainAppStub;
import todolist.model.Task;

public class CommandTest {
	
	private MainApp mainAppStub;
	private Logic logic;
    private ArrayList<String> input;
	private ArrayList<LocalDateTime> startdate;
    private ArrayList<LocalDateTime> enddate;
    private ArrayList<String> name;
    
	@Before
	public void setUp() throws Exception {
        mainAppStub = new MainAppStub();
        logic = new Logic(mainAppStub);
        input = new ArrayList<String>();
        startdate = new ArrayList<LocalDateTime>();
        enddate = new ArrayList<LocalDateTime>();
        name = new ArrayList<String>();
        
        initialiseInput();
        initialiseName();
        initialiseStartdate();
        initialiseEnddate();
	}
    
	private void initialiseInput() {
		input.add(0, "add event firsttitle 2017-01-01 14:00 1 day");
		input.add(1, "add event secondtitle 2016-01-01 14:00 1 day");
		input.add(2, "add event \"cs2103 lecture\" 2016-08-01 23:00 2 hour");
		input.add(3, "i want to attend lecture tmr 4pm to 6pm");
		input.add(4, "i want to add money to my account tmr 4pm to 6pm");
		input.add(5, "i want to eat lunch tmr");
		input.add(6, "add deadline title 1970-01-01 12:00");
		input.add(7, "add deadline title2 2100-01-01 12:00");
		input.add(8, "sumbit project proposal by tmr 2359");
		input.add(9, "sumbit proposal by today");
		input.add(10, "add task \"a floating task\"");
		input.add(11, "try tutorial question");
		input.add(12, "try to add amount to bank account");
		input.add(13, "delete firsttitle");
		input.add(14, "edit firsttitle title newtitle");
		input.add(15, "edit firsttitle start-time 2017-01-02-13:00");
		input.add(16, "edit firsttitle end-time 2017-01-03-13:00");
		input.add(17, "add-remind deadline \"to be reminded\" 05-01 14:00");
		input.add(18, "add recurring deadline 2-hour title 2017-01-01 14:00");		
	}
	
	private void initialiseName() {
		name.add(0, "firsttitle");
		name.add(1, "secondtitle");
		name.add(2, "cs2103 lecture");
		name.add(3, "i want to attend lecture");
		name.add(4, "i want to add money to my account");
		name.add(5, "i want to eat lunch");
		name.add(6, "title");
		name.add(7, "title2");
		name.add(8, "sumbit project proposal");
		name.add(9, "sumbit proposal");
		name.add(10, "a floating task");
		name.add(11, "try tutorial question");
		name.add(12, "try to add amount to bank account");
		name.add(13, "to be reminded");		
	}
	
	private void initialiseStartdate() {
		startdate.add(0, parseDate("2017-01-01 14:00"));
		startdate.add(1, parseDate("2016-01-01 14:00"));
		startdate.add(2, parseDate("2016-08-01 23:00"));
		startdate.add(3, parseDate(tmr_string() + " " + "16:00"));
		startdate.add(4, parseDate(tmr_string() + " " + "16:00"));
		
		
	}
	
	private void initialiseEnddate() {	
		enddate.add(0, startdate.get(0).plus(Long.parseLong("1"), ChronoUnit.DAYS));
		enddate.add(1, startdate.get(1).plus(Long.parseLong("1"), ChronoUnit.DAYS));
		enddate.add(2, startdate.get(2).plus(Long.parseLong("2"), ChronoUnit.HOURS));
		enddate.add(3, startdate.get(3).plus(Long.parseLong("2"), ChronoUnit.HOURS));
		enddate.add(4, startdate.get(4).plus(Long.parseLong("2"), ChronoUnit.HOURS));
		enddate.add(5, parseDate(tmr_string() + " " + "13:00"));
		enddate.add(6, parseDate("1970-01-01 12:00"));
		enddate.add(7, parseDate("2100-01-01 12:00"));
		enddate.add(8, parseDate(tmr_string() + " " + "23:59"));
		enddate.add(9, parseDate(today_string() + " " + "23:59"));
		
	}
	
	
	private LocalDateTime parseDate(String date) {
		
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        LocalDateTime formatedDate = LocalDateTime.parse(date, formatter);
        return formatedDate;
	}
	
	private String today_string() {
		
		DecimalFormat decimalFormatter = new DecimalFormat("00");
		String str = LocalDateTime.now().getYear() + "-"
				+ decimalFormatter.format(LocalDateTime.now().getMonthValue()) + "-"
				+ decimalFormatter.format(LocalDateTime.now().getDayOfMonth());
		
		return str;
		
	}
	
    private String tmr_string() {
    	
    	DecimalFormat decimalFormatter = new DecimalFormat("00");
		String str = LocalDateTime.now().getYear() + "-"
				+ decimalFormatter.format(LocalDateTime.now().getMonthValue()) + "-"
				+ decimalFormatter.format(LocalDateTime.now().getDayOfMonth()+1);
		
		return str;
    }

	/*
     * 0. test add function: event, normal input,start time in the future
     */
    @Test
    public void testAddCommand0() {
    	logic.clean();

    	logic.process(input.get(0));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	Boolean isEqual = taskList.size() == 1;
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	
    	// check name of the task
    	isEqual = thisTask.getName().getName().equals(name.get(0));
    	assertTrue(isEqual);

    	// check start time
    	isEqual = thisTask.getStartTime().isEqual(startdate.get(0));
    	assertTrue(isEqual);

    	// check end time
    	isEqual = thisTask.getEndTime().isEqual(enddate.get(0));
    	assertTrue(isEqual);             
    }
    
	/*
     * 1. test add function: event, normal input,start time in the past
     */
    @Test
    public void testAddCommand1() {
    	logic.clean();

    	logic.process(input.get(1));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	Boolean isEqual = taskList.size() == 1;
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	// check name of the task
    	isEqual = thisTask.getName().getName().equals(name.get(1));
    	assertTrue(isEqual);

    	// check start time
    	isEqual = thisTask.getStartTime().isEqual(startdate.get(1));
    	assertTrue(isEqual);

    	// check end time
    	isEqual = thisTask.getEndTime().isEqual(enddate.get(1));
    	assertTrue(isEqual);             
    }
    
	/*
     * 2. test add function:event,normal input,start time in the future;
     *    with event across two days
     */
    @Test
    public void testAddCommand2() {
    	logic.clean();

    	logic.process(input.get(2));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	Boolean isEqual = taskList.size() == 1;
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	// check name of the task
    	isEqual = thisTask.getName().getName().equals(name.get(2));
    	assertTrue(isEqual);

    	// check start time
    	isEqual = thisTask.getStartTime().isEqual(startdate.get(2));
    	assertTrue(isEqual);

    	// check end time
    	isEqual = thisTask.getEndTime().isEqual(enddate.get(2));
    	assertTrue(isEqual);             
    }

	/*
     * 3. test add function:add event, flexi-command input; start time in the future;
     */
    @Test
    public void testAddCommand3() {
    	logic.clean();

    	logic.process(input.get(3));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	Boolean isEqual = taskList.size() == 1;
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	// check name of the task
    	isEqual = thisTask.getName().getName().trim().equals(name.get(3));
    	assertTrue(isEqual);

    	// check start time
    	isEqual = thisTask.getStartTime().isEqual(startdate.get(3));
    	assertTrue(isEqual);

    	// check end time
    	isEqual = thisTask.getEndTime().isEqual(enddate.get(3));
    	assertTrue(isEqual);             
    }
    
	/*
     * 4. test add function:add event flexi-command input; 
     *    start time in the future;with key word 'add' in the title
     */
    @Test
    public void testAddCommand4() {
    	logic.clean();

    	logic.process(input.get(4));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	Boolean isEqual = taskList.size() == 1;
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	// check name of the task
    	isEqual = thisTask.getName().getName().trim().equals(name.get(4));
    	assertTrue(isEqual);

    	// check start time
    	isEqual = thisTask.getStartTime().isEqual(startdate.get(4));
    	assertTrue(isEqual);

    	// check end time
    	isEqual = thisTask.getEndTime().isEqual(enddate.get(4));
    	assertTrue(isEqual);             
    }
    
	/*
     * 5. test add function: add deadline flexi-command ;with key word 'lunch'
     */
    @Test
    public void testAddCommand5() {
    	logic.clean();

    	logic.process(input.get(5));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	Boolean isEqual = taskList.size() == 1;
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	// check name of the task
    	isEqual = thisTask.getName().getName().trim().equals(name.get(5));
    	assertTrue(isEqual);

    	// check end time
    	isEqual = thisTask.getEndTime().isEqual(enddate.get(5));
    	assertTrue(isEqual);             
    }
    
	/*
     * 6. test add function: add deadline,normal input;start time in the future
     */
    @Test
    public void testAddCommand6() {
    	logic.clean();

    	logic.process(input.get(6));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	Boolean isEqual = taskList.size() == 1;
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	// check name of the task
    	isEqual = thisTask.getName().getName().trim().equals(name.get(6));
    	assertTrue(isEqual);

    	// check end time
    	isEqual = thisTask.getEndTime().isEqual(enddate.get(6));
    	assertTrue(isEqual);             
    }
    
	/*
     * 7. test add function:add deadline,normal input;start time in the past
     */
    @Test
    public void testAddCommand7() {
    	logic.clean();

    	logic.process(input.get(7));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	Boolean isEqual = taskList.size() == 1;
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	// check name of the task
    	isEqual = thisTask.getName().getName().trim().equals(name.get(7));
    	assertTrue(isEqual);

    	// check end time
    	isEqual = thisTask.getEndTime().isEqual(enddate.get(7));
    	assertTrue(isEqual);             
    }
    
	/*
     * 8. test add function: add deadline,flexi input;start time in the future
     */
    @Test
    public void testAddCommand8() {
    	logic.clean();

    	logic.process(input.get(8));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	Boolean isEqual = taskList.size() == 1;
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	// check name of the task
    	isEqual = thisTask.getName().getName().trim().equals(name.get(8));
    	assertTrue(isEqual);

    	// check end time
    	isEqual = thisTask.getEndTime().isEqual(enddate.get(8));
    	assertTrue(isEqual);             
    }
    
	/*
     * 9. test add function: add deadline, flexi-command,with key word today
     */
    @Test
    public void testAddCommand9() {
    	logic.clean();

    	logic.process(input.get(9));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	Boolean isEqual = taskList.size() == 1;
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	// check name of the task
    	isEqual = thisTask.getName().getName().trim().equals(name.get(9));
    	assertTrue(isEqual);

//    	// check end time
//    	isEqual = thisTask.getEndTime().isEqual(enddate.get(9));
//    	assertTrue(isEqual);             
    }
    
	/*
     * 10. test add function:add floating task, normal input
     */
    @Test
    public void testAddCommand10() {
    	logic.clean();

    	logic.process(input.get(10));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	Boolean isEqual = taskList.size() == 1;
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	// check name of the task
    	isEqual = thisTask.getName().getName().trim().equals(name.get(10));
    	assertTrue(isEqual);             
    }
    
	/*
     * 11. test add function:add floating task, flexi input
     */
    @Test
    public void testAddCommand11() {
    	logic.clean();

    	logic.process(input.get(11));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	Boolean isEqual = taskList.size() == 1;
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	// check name of the task
    	isEqual = thisTask.getName().getName().trim().equals(name.get(11));
    	assertTrue(isEqual);             
    }
    
	/*
     * 12. test add function: add floating task command with flexi command; 
     *     with 'add' keyword in the middle
     */
    @Test
    public void testAddCommand12() {
    	logic.clean();

    	logic.process(input.get(12));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	Boolean isEqual = taskList.size() == 1;
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	// check name of the task
    	isEqual = thisTask.getName().getName().trim().equals(name.get(12));
    	assertTrue(isEqual);             
    }
    
	/*
     * 13. test add function: add a deadline with reminder
     */
    @Test
    public void testAddCommand13() {
    	logic.clean();

    	logic.process(input.get(17));

    	//check size of database
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();
    	assertEquals(1, taskList.size());

    	Task thisTask = taskList.get(0);
    	// check name of the task
    	boolean isEqual;
    	isEqual = thisTask.getName().getName().trim().equals(name.get(13));
    	assertTrue(isEqual);
    	
    	//check the status of reminder
    	assertTrue(thisTask.getReminder().getStatus()); 
    }
        
	/*
     * 14. test add recurring deadline
     */
    @Test
    public void testAddCommand14() {
        logic.clean();

        logic.process(input.get(18));

        // check size of database
        ArrayList<Task> taskList = logic.dataBase.retrieveAll();
        assertEquals(1, taskList.size());
        
        //check recurring status
        assertTrue(taskList.get(0).getRecurringStatus());
        
    }
    
    
    /*
     * 15. test delete function
     */
    @Test
    public void testDelete() {
        logic.clean();
        
        //add a task
        logic.process(input.get(0));
        ArrayList<Task> taskList = logic.dataBase.retrieveAll();       
        assertTrue(taskList.size() == 1);
        
        //delete the task
        logic.process(input.get(13));
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.isEmpty());        
    }
    
    /*
     * 16. test edit function: edit title of the task
     */
    @Test
    public void testEdit() {
        logic.clean();
        
        //add a task
        logic.process(input.get(0));
        ArrayList<Task> taskList = logic.dataBase.retrieveAll();       
        assertTrue(taskList.size() == 1);
        
        //edit the title
        logic.process(input.get(14));
        
        //check that the task is still there 
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);
        
        //check name of the task
        boolean isEqual = taskList.get(0).getName().getName().equals("newtitle");
        assertTrue(isEqual);     
    }
    
    /*
     * 17/18. test edit function: edit the start/end time of the task
     */
    @Test
    public void testEdit2() {
        logic.clean();
        
        //add a task
        logic.process(input.get(0));
        ArrayList<Task> taskList = logic.dataBase.retrieveAll();       
        assertTrue(taskList.size() == 1);
        
        //edit the start time
        logic.process(input.get(15));
        
        //check that the task is still there 
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);
        
        //check start time of the task
        boolean isEqual = taskList.get(0).getStartTime().toString().equals("2017-01-02T13:00");
        assertTrue(isEqual); 
        
        //edit the end time
        logic.process(input.get(16));
        
        //check end time of the task
        taskList = logic.dataBase.retrieveAll();
        isEqual = taskList.get(0).getEndTime().toString().equals("2017-01-03T13:00");
        assertTrue(isEqual);      
    }
    
    /*
     * 19/20. test edit function: remove start/end time
     */
    @Test
    public void testEdit3() {
        logic.clean();
        
        //add a task
        logic.process(input.get(0));
        ArrayList<Task> taskList = logic.dataBase.retrieveAll();       
        assertTrue(taskList.size() == 1);
        
        //edit the start time
        logic.process("edit firsttitle start-time remove");
        
        //check that the task is still there 
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);
        
        //check start time of the task
        boolean isEqual = taskList.get(0).getStartTime() == null;
        assertTrue(isEqual); 
        
        //edit the end time
        logic.process("edit firsttitle end-time remove");
        
        //check end time of the task
        taskList = logic.dataBase.retrieveAll();
        isEqual = taskList.get(0).getEndTime() == null;
        assertTrue(isEqual);      
    }

    /*
     * 21. test label function: label the task to certain category
     */
    @Test
    public void testLabel() {
    	logic.clean();

    	//add a task
    	logic.process(input.get(0));
    	ArrayList<Task> taskList = logic.dataBase.retrieveAll();       
    	assertTrue(taskList.size() == 1);

    	//edit the start time
    	logic.process("label firsttitle cat1");

    	//check that the task is still there 
    	taskList = logic.dataBase.retrieveAll();
    	assertTrue(taskList.size() == 1);

    	//check label of the task
    	boolean isEqual = taskList.get(0).getCategory().getCategory().equals("cat1");;
    	assertTrue(isEqual); 
    }

    /*
     * 22. test remind function: set reminder to an event
     */
    @Test
    public void testRemind() {
        logic.clean();
        
        //add a task
        logic.process(input.get(0));
        ArrayList<Task> taskList = logic.dataBase.retrieveAll();       
        assertTrue(taskList.size() == 1);
        
        //edit the start time
        logic.process("remind firsttitle");
        
        //check that the task is still there 
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);
        
        //check label of the task
        assertTrue(taskList.get(0).getReminder().getStatus()); 
    }
    
    /*
     * 23. test remind function: set reminder to an event
     */
    @Test
    public void testDone() {
        logic.clean();
        
        //add a task
        logic.process(input.get(0));
        ArrayList<Task> taskList = logic.dataBase.retrieveAll();       
        assertTrue(taskList.size() == 1);
        
        //edit the start time
        logic.process("done firsttitle");
        
        //check that the task is still there 
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);
        
        //check done status of the task
        assertTrue(taskList.get(0).getDoneStatus()); 
        
        logic.process("undone firsttitle");
        taskList = logic.dataBase.retrieveAll();
        assertFalse(taskList.get(0).getDoneStatus());       
    }
    
    /*
     * 24. test undo/redo function
     */
    @Test
    public void testUndo() {
        logic.clean();
        
        //add tasks
        logic.process(input.get(0));
        logic.process(input.get(1));        
        ArrayList<Task> taskList = null;
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 2);
        
        //delete tasks         
        logic.process(input.get(13));
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);

        logic.process("undo 1");
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 2);
        
        logic.process("redo 1");
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1); 
        
        //add another two task
        logic.process(input.get(2));
        logic.process(input.get(3));
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 3);
        
        logic.process("undo 2");
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);
        
        logic.process("redo 2");
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 3);      
    }
    
    /*
     * 25. test set-recurring function
     */
    @Test
    public void testSetRemoveRecurring() {
        logic.clean();
        
        //add tasks
        logic.process(input.get(0));        
        ArrayList<Task> taskList = null;
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);

        logic.process("set-recurring " + name.get(0) + " 3-month");
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);
        
        //check the recurring status and interval
        assertTrue(taskList.get(0).getRecurringStatus());
        assertTrue(taskList.get(0).getInterval().equals("3-month")); 
        
        logic.process("remove-recurring " + name.get(0));
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);
        
        //check the recurring status and interval
        assertFalse(taskList.get(0).getRecurringStatus());
        assertTrue(taskList.get(0).getInterval() == null); 
    }
    
    /*
     * 26. test set-recurring function
     */
    @Test
    public void testRemoveRecurring() {
        logic.clean();
        
        //add tasks
        logic.process(input.get(0));        
        ArrayList<Task> taskList = null;
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);
           
        logic.process("remove-recurring " + name.get(0));
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);
        //check the recurring status and interval
        assertFalse(taskList.get(0).getRecurringStatus());
        assertTrue(taskList.get(0).getInterval() == null); 
    }
    
    /*
     * 27/28. test postpone/forward function
     */
    @Test
    public void testPostponeForward() {
        logic.clean();
        
        //add tasks
        logic.process(input.get(0));        
        ArrayList<Task> taskList = null;
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);
           
        logic.process("postpone " + name.get(0) + " 2 day");
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);
        
        //check the start and end time        
        assertTrue(taskList.get(0).getStartTime().equals(startdate.get(0).plus(Long.parseLong("2"), ChronoUnit.DAYS)));
        assertTrue(taskList.get(0).getEndTime().equals(enddate.get(0).plus(Long.parseLong("2"), ChronoUnit.DAYS))); 
        
        logic.process("forward " + name.get(0) + " 2 day");
        taskList = logic.dataBase.retrieveAll();
        assertTrue(taskList.size() == 1);
        
        //check the start and end time        
        assertTrue(taskList.get(0).getStartTime().equals(startdate.get(0)));
        assertTrue(taskList.get(0).getEndTime().equals(enddate.get(0))); 
    }
}
```
###### /todolist/common/tests/DataBaseTest.java
``` java
package todolist.common.tests;

import static org.junit.Assert.*;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

import todolist.model.Category;
import todolist.model.Name;
import todolist.model.SearchCommand;
import todolist.model.Task;
import todolist.storage.DataBase;

public class DataBaseTest {

	private DataBase db;
	private ArrayList<String> name;
	private ArrayList<String> date;
    private ArrayList<Task> eventList;

	@Before
	public void setUp() throws Exception {
		
		db = new DataBase();
		name = new ArrayList<String>();
		date = new ArrayList<String>();
		eventList = new ArrayList<Task>();
		
		initialiseName();
		initialiseDate();
				
	}
	   
	private void initialiseDate() {
		date.add(0, "2030-11-01 14:00");
		date.add(1, "2030-01-01 15:00");
		date.add(2, "2030-01-01 10:00");
		date.add(3, "2030-01-01 10:00");
		date.add(4, "2009-01-01 10:00");
		date.add(5, "2016-01-01 10:00");
		date.add(6, "2012-03-01 10:00");
		date.add(7, "2020-01-22 10:00");
		date.add(8, "2030-01-01 10:00");
		date.add(9, "2011-01-01 10:00");
	}

	private void initialiseName() {
		name.add(0, "hello jenny");
		name.add(1, "hello world");
		name.add(2, "some random title");
		name.add(3, "finish proposal");
		name.add(4, "do laundry");
		name.add(5, "buy lunch for girfriend");
		name.add(6, "buy jay chou cd");
		name.add(7, "do homework");
		name.add(8, "have date with girlfriend");
		name.add(9, "rewrite taskstorage");
	}

	private void initialiseEventList() {
		
		for(int i = 0; i < name.size(); i++) {
			Task eachTask = createTask(name.get(i), date.get(i), date.get(i), "cat1");
			eventList.add(eachTask);			
		}
	}
	
	private void addEvents() {
		
		if(eventList.size() == 0) {
			initialiseEventList();
		}
		
		for(int i = 0; i < eventList.size(); i++) {
			db.add(eventList.get(i));
		}
	}
	
	private Task createTask(String taskName, String taskStart, String taskEnd, String cat) {
		
		Name name = new Name(taskName);

		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
		
		LocalDateTime start = null;
		if(taskStart != null) {
			start = LocalDateTime.parse(taskStart, formatter);			
		}
				
		LocalDateTime end = null;
		if(taskEnd != null) {
			end = LocalDateTime.parse(taskEnd, formatter);
		}
			
		Category category = null;
		if(cat != null) {
			category = new Category(cat);
		}
		
		Task newEvent = new Task(name, start, end, category, null, false, false, null);
		
		return newEvent;
	}
	
	@Test
	/*
	 * test add event to the database
	 * 
	 */
	public void testAdd1() {
		db.clear();
		
		eventList = new ArrayList<Task>();
		// test whether can add an event to database
		for(int i = 0; i < eventList.size(); i++) {
			assertTrue(db.add(eventList.get(i)));
		}
		
		// test whether it is really written into the file
		db.loadFromFile();
		ArrayList<Task> listReadFromFile = db.taskList;
		assertEquals(listReadFromFile.size(), eventList.size());
		
		//assert the title of task written into file
		for(int i = 0; i < listReadFromFile.size(); i++) {
			boolean isEqual = listReadFromFile.get(0).getName().getName().equals(name.get(i));
			assertTrue(isEqual);
		}
		
	}
    
	/*
	 * test delete an (existing) event from database
	 */
	@Test
	public void testDelete1() {
		db.clear();
		
		addEvents();

		for(int i = 0; i < eventList.size(); i++) {
			assertTrue(db.delete(eventList.get(i)));
		}

		// check whether it is really deleted from the file
		db.loadFromFile();
		assertTrue(db.taskList.isEmpty());
	}
	
	/*
	 * test delete an (not existing) event from database
	 */
	@Test
	public void testDelete2() {
		db.clear();
		
		addEvents();
		
		Task taskToDelete = createTask("title not exit", date.get(0), date.get(0), null);
		assertFalse(db.delete(taskToDelete));
	}
	
    /*
     * test check existence for an event (existing) in the database
     */
	@Test
	public void testCheckExistence1() {
		db.clear();
		
		addEvents();

		// check the existence
		for(int i = 0; i < eventList.size(); i++) {
			assertTrue(db.checkExistence(eventList.get(i)));
		}
		
	}
	/*
     * test check existence for an event (not existing) in the database
     */
	@Test
	public void testCheckExistence2() {
		db.clear();

		addEvents();
		
		//check the existence for another event
		Task taskToCheck = createTask("new task", date.get(0), date.get(0), null);
		assertFalse(db.checkExistence(taskToCheck));
	}
    
	/*
	 * test retrieve by (existing) name
	 */
	@Test
	public void testRetrieve1() {
		db.clear();
		
		addEvents();
        
		for(int i = 0; i < name.size(); i++) {
			ArrayList<Task> taskList = db.retrieve(new SearchCommand("name", name.get(0)));
			
			//check the size of the resultant list
			boolean isEqual = taskList.size() == 1;
			assertTrue(isEqual);
			
			// check the element is the task we add in
			isEqual = taskList.get(0).getName().getName().equals(name.get(0));
			assertTrue(isEqual);
		}		
	}
	
	/*
	 * test retrieve by (not existing) name
	 */
	@Test
	public void testRetrieve2() {
		db.clear();
		
		addEvents();

		// retrieve the task for the name of the ( not existing) task
		ArrayList<Task> taskList = db.retrieve(new SearchCommand("name", "different-name"));
		//check the size of the resultant list
		boolean isEqual = taskList.size() == 0;
		assertTrue(isEqual);
	}
	
	/*
	 * test retrieve by (existing) category
	 */
	@Test
	public void testRetrieve3() {
		db.clear();
		
		addEvents();

		// retrieve the task for the specific (existing) category
		ArrayList<Task> taskList = db.retrieve(new SearchCommand("category", "cat1"));
		//check the size of the resultant list
		assertEquals(taskList.size(), 10);
	}
	
	/*
	 * test retrieve by (not existing) category
	 */
	@Test
	public void testRetrieve4() {
		db.clear();
		
		addEvents();

		// retrieve the task for the specific (existing) category
		ArrayList<Task> taskList = db.retrieve(new SearchCommand("category", "not_existing_cat"));
		boolean expected = false;
		//check the size of the resultant list
		boolean isEqual = taskList.size() >= 1;
		assertEquals(expected, isEqual);
	}
    
	/*
	 * test retrieveSmartSearch function
	 */
	@Test
	public void testSmartSearch() {
		db.clear();
		
        addEvents();

        // retrieve the task for the keywords
        String[] keywords = ("hello word").split(" ");
        ArrayList<Task> taskList = db.smartSearch(keywords);

        //check the size of the resultant list
        assertEquals(2, taskList.size());
        boolean isEqual = taskList.get(0).getName().getName().equals(name.get(0));
        assertTrue(isEqual);
        isEqual = taskList.get(1).getName().getName().equals(name.get(1));
        assertTrue(isEqual);
	}
	
	/*
	 * test retrieveSmartSearch function
	 */
	@Test
	public void testSmartSearch2() {
		db.clear();
		
        addEvents();

        // retrieve the task for the keywords
        String[] keywords = ("hello").split(" ");
        ArrayList<Task> taskList = db.smartSearch(keywords);

        //check the size of the resultant list      
        assertEquals(2, taskList.size());      
      
        boolean isEqual = taskList.get(0).getName().getName().equals(name.get(0));
        assertTrue(isEqual);
        
        isEqual = taskList.get(1).getName().getName().equals(name.get(1));
        assertTrue(isEqual);
	}
	
	/*
	 * test retrieveAll function
	 */
	@Test
	public void testRetrieveAll() {
		db.clear();
		
        addEvents();

		// check size of the database
		ArrayList<Task> taskList = db.retrieveAll();
		assertEquals(taskList.size(), 10);
		
		// check the element is the task we add in
		for(int i = 0; i < eventList.size(); i++) {
			boolean isEqual = taskList.get(i).getName().getName().equals(name.get(9-i));
			assertTrue(isEqual);
		}
	}
	
	
	/*
	 * test change directory method
	 */
	@Test 
	public void testChangeDir() {
		db.clear();
		
        addEvents();
		
		//change the directory
		assertTrue(db.setNewFile("/Users/Xyx/Desktop/jim"));
	}

}
```
###### /todolist/common/tests/FlexiCommandParserTest.java
``` java
package todolist.common.tests;

import static org.junit.Assert.*;

import java.text.DecimalFormat;
import java.time.LocalDateTime;

import org.junit.Before;
import org.junit.Test;

import todolist.model.TokenizedCommand;
import todolist.parser.FlexiCommandParser;

public class FlexiCommandParserTest {
    
	FlexiCommandParser flexiParser;
	
	@Before
	public void setUp() throws Exception {
		flexiParser = new FlexiCommandParser();
	}

	/*
	 * test flexi-command for add deadline
	 */
	@Test
	public void testParseDeadline() {
		//parse the command
		String input = "sumbit proposal tmr 2359";
		LocalDateTime date = LocalDateTime.now();
		DecimalFormat decimalFormatter = new DecimalFormat("00");
	    String deadlineDate = date.getYear() + "-"
				+ decimalFormatter.format(date.getMonthValue()) + "-"
				+ decimalFormatter.format(date.getDayOfMonth()+1);
	    
		TokenizedCommand command = flexiParser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("deadline"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("sumbit proposal".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(deadlineDate));
		//check the time
		assertTrue(tokonizedCommand[3].trim().equals("23:59"));
	}
	
		
	/*
	 * test flexi-command for add event
	 */
	@Test
	public void testParseEvent() {
		//parse the command
		String input = "2013 lecture 4/12/16 4pm to 6pm";
	    String date = "2016-04-12";
	    String startTime = "16:00";
	    String timeInterval = Integer.toString(2*60);
	    String unit = "minute";
		TokenizedCommand command = flexiParser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("event"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("2013 lecture".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check the start time
		assertTrue(tokonizedCommand[3].trim().equals(startTime));
		//check timeInterval
		assertTrue(tokonizedCommand[4].trim().equals(timeInterval));
		//check unit
		assertTrue(tokonizedCommand[5].trim().equals(unit));
	}
	
	/*
	 * test flexi-command for add floating task
	 */
	@Test
	public void testParseTask() {
		//parse the command
		String input = "attend lecture";
		TokenizedCommand command = flexiParser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("task"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("attend lecture".trim()));
	}	

}
```
###### /todolist/common/tests/LogicTest.java
``` java
package todolist.common.tests;

import static org.junit.Assert.*;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

import todolist.MainApp;
import todolist.logic.Logic;
import todolist.logic.MainAppStub;
import todolist.model.Name;
import todolist.model.SearchCommand;
import todolist.model.Task;


public class LogicTest {

    private MainApp mainAppStub;
    private Logic logic;

    @Before
    public void setUp() throws Exception {
        mainAppStub = new MainAppStub();
        logic = new Logic(mainAppStub);
    }

    /**
     * test process method with add (event) command from user
     */
    @Test
    public void testProcess1() {
        logic.clean();
        boolean expected = true;

        String name = "title";
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        LocalDateTime start = LocalDateTime.parse("2017-01-01" + " " + "14:00", formatter);
        LocalDateTime end = start.plus(Long.parseLong("1"), ChronoUnit.DAYS);
        // add in the command to add a new event
        logic.process("add event title 2017-01-01 14:00 1 day");

        // check size of database
        ArrayList<Task> taskList = logic.dataBase.retrieveAll();
        Boolean isEqual = taskList.size() == 1;
        assertEquals(isEqual, expected);
        // check name of the task
        isEqual = taskList.get(0).getName().getName().equals(name);
        assertEquals(isEqual, expected);
        // check start time
        isEqual = taskList.get(0).getStartTime().isEqual(start);
        assertEquals(isEqual, expected);
        // check end time
        isEqual = taskList.get(0).getEndTime().isEqual(end);
        assertEquals(isEqual, expected);
    }

    /**
     * test process method with add (deadline) command from user
     */
    @Test
    public void testProcess2() {
        logic.clean();
        boolean expected = true;

        String name = "title";
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        LocalDateTime end = LocalDateTime.parse("1970-01-01" + " " + "12:00", formatter);

        // pass in the command to add a new deadline
        logic.process("add deadline title 1970-01-01 12:00");

        // check size of database
        ArrayList<Task> taskList = logic.dataBase.retrieveAll();
        Boolean isEqual = taskList.size() == 1;
        assertEquals(isEqual, expected);
        // check name of the task
        isEqual = taskList.get(0).getName().getName().equals(name);
        assertEquals(isEqual, expected);
        // check end time
        isEqual = taskList.get(0).getEndTime().isEqual(end);
        assertEquals(isEqual, expected);
    }

    /**
     * test process method with add (floating task) command from user
     */
    @Test
    public void testProcess3() {
        logic.clean();
        
        String name = "title";

        // pass in command to add a floating task
        logic.process("add task title");
        // check size of database
        ArrayList<Task> taskList = logic.dataBase.retrieveAll();
        Boolean isEqual = taskList.size() == 1;
        assertTrue(isEqual);
        // check name of the task
        isEqual = taskList.get(0).getName().getName().equals(name);
        assertTrue(isEqual);
    }
    
    /**
     * test add event function ( a future event)
     */
    @Test
    public void testAddEvent() {
        logic.clean();

        String name = "title";
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        LocalDateTime start = LocalDateTime.parse("2017-01-01" + " " + "14:00", formatter);
        LocalDateTime end = start.plus(Long.parseLong("1"), ChronoUnit.DAYS);
        // add in the command to add a new event
        logic.addRecurringEvent("7-day", "title", "2017-01-01", "14:00", "1", "day");

        // check size of database
        ArrayList<Task> taskList = logic.dataBase.retrieveAll();
        Boolean isEqual = taskList.size() == 1;
        assertTrue(isEqual);
        // check name of the task
        isEqual = taskList.get(0).getName().getName().equals(name);
        assertTrue(isEqual);
        // check start time
        isEqual = taskList.get(0).getStartTime().isEqual(start);
        assertTrue(isEqual);
        // check end time
        isEqual = taskList.get(0).getEndTime().isEqual(end);
        assertTrue(isEqual);
        // check whether it is set to be recurring
        isEqual = taskList.get(0).getRecurringStatus();
        assertTrue(taskList.get(0).getRecurringStatus());
        // check the interval of recurring
        isEqual = taskList.get(0).getInterval().equals("7-day");
        assertTrue(isEqual);
    }

    /**
     * test add recurring event function
     */
    @Test
    public void testAddRecurringEvent() {
        logic.clean();

        String name = "title";
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        LocalDateTime start = LocalDateTime.parse("2017-01-01" + " " + "14:00", formatter);
        LocalDateTime end = start.plus(Long.parseLong("1"), ChronoUnit.DAYS);
        // add in the command to add a new event
        logic.addRecurringEvent("7-day", "title", "2017-01-01", "14:00", "1", "day");

        // check size of database
        ArrayList<Task> taskList = logic.dataBase.retrieveAll();
        Boolean isEqual = taskList.size() == 1;
        assertTrue(isEqual);
        // check name of the task
        isEqual = taskList.get(0).getName().getName().equals(name);
        assertTrue(isEqual);
        // check start time
        isEqual = taskList.get(0).getStartTime().isEqual(start);
        assertTrue(isEqual);
        // check end time
        isEqual = taskList.get(0).getEndTime().isEqual(end);
        assertTrue(isEqual);
        // check whether it is set to be recurring
        isEqual = taskList.get(0).getRecurringStatus();
        assertTrue(taskList.get(0).getRecurringStatus());
        // check the interval of recurring
        isEqual = taskList.get(0).getInterval().equals("7-day");
        assertTrue(isEqual);
    }

    /**
     * test add recurring deadline function
     */
    @Test
    public void testAddRecurringDeadline() {
        logic.clean();

        String name = "title";
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        LocalDateTime end = LocalDateTime.parse("2117-04-02" + " " + "12:00", formatter);

        // pass in the command to add a new deadline
        logic.addRecurringDeadline("7-day", "title", "2117-04-02", "12:00");

        // check size of database
        ArrayList<Task> taskList = logic.dataBase.retrieveAll();
        Boolean isEqual = taskList.size() == 1;
        assertTrue(isEqual);
        // check name of the task
        isEqual = taskList.get(0).getName().getName().equals(name);
        assertTrue(isEqual);
        // check end time
        isEqual = taskList.get(0).getEndTime().isEqual(end);
        assertTrue(isEqual);
        // check whether it is set to be recurring
        isEqual = taskList.get(0).getRecurringStatus();
        assertTrue(taskList.get(0).getRecurringStatus());
        // check the interval of recurring
        isEqual = taskList.get(0).getInterval().equals("7-day");
        assertTrue(isEqual);
    }

    /**
     * test the archive function with existing task
     */
    @Test
    public void testDone1() {
        logic.clean();
        // add a new event
        Name name = new Name("title");
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        LocalDateTime start = LocalDateTime.parse("2017-01-01" + " " + "14:00", formatter);
        LocalDateTime end = start.plus(Long.parseLong("1"), ChronoUnit.DAYS);
        Task newEvent = new Task(name, start, end, null, null, false, false, null);
        logic.dataBase.add(newEvent);

        // archive this event
        assertTrue(logic.done("title"));
        // check the status of the task
        newEvent = logic.dataBase.retrieve(new SearchCommand("name", "title")).get(0);
        Boolean isEqual = newEvent.getDoneStatus().equals(true);
        assertTrue(isEqual);
    }

    @Test
    public void testStepForward() {
    	logic.clean();
    	
        int original = logic.checkStep();
        logic.stepForward();
        assertEquals(logic.checkStep(), original + 1);
    }

    @Test
    public void testUndone() {
    	logic.clean();
    	
        logic.addTask("title");
        logic.done("title");        
        logic.undone("title");
        
        //check the size of the task list
        assertEquals(logic.dataBase.taskList.size(),1);
        //check the title of the task
        Boolean isEqual = logic.dataBase.taskList.get(0).getName().getName().equals("title");
        assertTrue (isEqual);
        isEqual = logic.dataBase.taskList.get(0).getDoneStatus();
    }
   
    /*
     * test edit function--to edit title of a floating task
     */
    @Test
    public void testEditTitle() {
    	logic.clean();
    	//add a task and then edit its name
    	boolean result = true;
    	result = logic.addTask("title");
    	assertTrue(result);
    	result = logic.edit("title", "title", "newTitle");
    	assertTrue(result);
        
        result = logic.dataBase.taskList.get(0).getName().getName().equals("newTitle");
        assertTrue (result);
    }
    
    /*
     * test edit function--to 'done' a floating task
     */
    @Test
    public void testEdit_Done() {
    	logic.clean();
    	//add a task and then edit its name
    	boolean result = true;
    	result = logic.addTask("title");
    	assertTrue(result);
    	result = logic.edit("title", "done",null);
    	assertTrue(result);
        
        result = logic.dataBase.taskList.get(0).getDoneStatus();
        assertTrue(result);
    }
    
    /*
     * test edit function--to edit end date of a deadline
     */
    @Test
    public void testEdit_Enddate() {
    	logic.clean();
    	DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        LocalDateTime end = LocalDateTime.parse("2016-04-01" + " " + "14:00", formatter);
    	//add a task and then edit its name
    	boolean result = true;
    	result = logic.addDeadline("title","2016-03-31","13:00");
    	assertTrue(result);
    	result = logic.edit("title", "end-time", "2016-04-01-14:00");
    	assertTrue(result);
        
        result = logic.dataBase.taskList.get(0).getName().getName().equals("title");
        assertTrue (result);
        result = logic.dataBase.taskList.get(0).getEndTime().equals(end);
        assertTrue(result);
    }
    


    public void testDelete() {
        fail("Not yet implemented");
    }

    public void testSearch() {
        fail("Not yet implemented");
    }

    public void testLabel() {
        fail("Not yet implemented");
    }

    public void testSetRecurring() {
        fail("Not yet implemented");
    }

    public void testPostpone() {
        fail("Not yet implemented");
    }

    public void testForward() {
        fail("Not yet implemented");
    }

    public void testAddRemind() {
        fail("Not yet implemented");
    }

    public void testAddRemindBef() {
        fail("Not yet implemented");
    }

    public void testRemindBef() {
        fail("Not yet implemented");
    }

    public void testRemind() {
        fail("Not yet implemented");
    }

    public void testExit() {
        fail("Not yet implemented");
    }

    public void testUndo() {
        fail("Not yet implemented");
    }

    public void testRedo() {
        fail("Not yet implemented");
    }

}
```
###### /todolist/common/tests/MainParserTest.java
``` java
package todolist.common.tests;

import static org.junit.Assert.*;

import java.text.DecimalFormat;
import java.time.LocalDateTime;

import org.junit.Before;
import org.junit.Test;

import todolist.model.TokenizedCommand;
import todolist.parser.MainParser;

public class MainParserTest {
    MainParser mainparser = null;
    
	@Before
	public void setUp() throws Exception {
		mainparser = new MainParser();
	}

	/*
	 * 1. test normal-command for add event
	 */
	@Test
	public void testAddEvent1() {
		//parse the command
		String input = "add event \"cs2013 lecture\" 2019-05-01 16:00 2 hour";
	    String date = "2019-05-01";
	    String startTime = "16:00";
	    String timeInterval = "2";
	    String unit = "hour";
		TokenizedCommand command = mainparser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("event"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("cs2013 lecture".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check the start time
		assertTrue(tokonizedCommand[3].trim().equals(startTime));
		//check timeInterval
		assertTrue(tokonizedCommand[4].trim().equals(timeInterval));
		//check unit
		assertTrue(tokonizedCommand[5].trim().equals(unit));
	}
	
	/*
	 * 2. test normal-command for add event (with keyword 'add')
	 */
	@Test
	public void testAddEvent2() {
		//parse the command
		String input = "add event \"add amount to bank account\" 2017-01-01 16:00 2 hour";
	    String date = "2017-01-01";
	    String startTime = "16:00";
	    String timeInterval = "2";
	    String unit = "hour";
		TokenizedCommand command = mainparser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("event"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("add amount to bank account".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check the start time
		assertTrue(tokonizedCommand[3].trim().equals(startTime));
		//check timeInterval
		assertTrue(tokonizedCommand[4].trim().equals(timeInterval));
		//check unit
		assertTrue(tokonizedCommand[5].trim().equals(unit));
	}
	
	/*
	 * 3. test normal-command for add deadline
	 */
	@Test
	public void testAddDeadline() {
		//parse the command
		String input = "add deadline \"submit proposal\" 2017-01-01 23:59";
	    String date = "2017-01-01";
	    String startTime = "23:59";
		TokenizedCommand command = mainparser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("deadline"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("submit proposal".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check the start time
		assertTrue(tokonizedCommand[3].trim().equals(startTime));
	}
	
	/*
	 * 3. test normal-command for add floating task
	 */
	@Test
	public void testAddFloating() {
		//parse the command
		String input = "add deadline \"submit proposal\" 2017-01-01 23:59";
	    String date = "2017-01-01";
	    String startTime = "23:59";
		TokenizedCommand command = mainparser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("deadline"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("submit proposal".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check the start time
		assertTrue(tokonizedCommand[3].trim().equals(startTime));
	}
	
	/*
	 * 5. test flexi-command for add event
	 */
	@Test
	public void testFlexiAddEvent() {
		//parse the command
		String input = "2013 lecture 4/12/16 4pm to 6pm";
	    String date = "2016-04-12";
	    String startTime = "16:00";
	    String timeInterval = Integer.toString(2*60);
	    String unit = "minute";
		TokenizedCommand command = mainparser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("event"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("2013 lecture".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check the start time
		assertTrue(tokonizedCommand[3].trim().equals(startTime));
		//check timeInterval
		assertTrue(tokonizedCommand[4].trim().equals(timeInterval));
		//check unit
		assertTrue(tokonizedCommand[5].trim().equals(unit));
	}
	
	
	/*
	 * 6. test flexi-command for add floating task
	 */
	@Test
	public void testFlexiAddTask() {
		//parse the command
		String input = "attend lecture";
		TokenizedCommand command = mainparser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("task"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("attend lecture".trim()));
	}
	
	/*
	 * 7. test flexi-command for add deadline
	 */
	@Test
	public void testFlexiAddDeadline() {
		//parse the command
		String input = "sumbit proposal tmr 2359";
		LocalDateTime date = LocalDateTime.now();
		DecimalFormat decimalFormatter = new DecimalFormat("00");
	    String deadlineDate = date.getYear() + "-"
				+ decimalFormatter.format(date.getMonthValue()) + "-"
				+ decimalFormatter.format(date.getDayOfMonth()+1);
	    
		TokenizedCommand command = mainparser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("deadline"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("sumbit proposal".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(deadlineDate));
		//check the time
		assertTrue(tokonizedCommand[3].trim().equals("23:59"));
	}
	

}
```
###### /todolist/common/tests/NormalCommandParserTest.java
``` java
package todolist.common.tests;

import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

import todolist.model.TokenizedCommand;
import todolist.parser.NormalCommandParser;

public class NormalCommandParserTest {
    NormalCommandParser normalCommandParser = null;

    @Before
    public void initNormalCommandParser() {
        normalCommandParser = new NormalCommandParser();
    }
    
	/*
	 * test normal-command for add event (in the future)
	 */
	@Test
	public void testParseAdd1() {
		//parse the command
		String input = "add event \"cs2013 lecture\" 2019-05-01 16:00 2 hour";
	    String date = "2019-05-01";
	    String startTime = "16:00";
	    String timeInterval = "2";
	    String unit = "hour";
		TokenizedCommand command = normalCommandParser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("event"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("cs2013 lecture".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check the start time
		assertTrue(tokonizedCommand[3].trim().equals(startTime));
		//check timeInterval
		assertTrue(tokonizedCommand[4].trim().equals(timeInterval));
		//check unit
		assertTrue(tokonizedCommand[5].trim().equals(unit));
	}
	
	/*
	 * test normal-command for add event (in the future)
	 */
	@Test
	public void testParseAdd2() {
		//parse the command
		String input = "add event \"cs2013 lecture\" 2019-05-01 16:00 2 hour";
	    String date = "2019-05-01";
	    String startTime = "16:00";
	    String timeInterval = "2";
	    String unit = "hour";
		TokenizedCommand command = normalCommandParser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("event"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("cs2013 lecture".trim()));
		//check the date
		
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check the start time
		assertTrue(tokonizedCommand[3].trim().equals(startTime));
		//check timeInterval
		assertTrue(tokonizedCommand[4].trim().equals(timeInterval));
		//check unit
		assertTrue(tokonizedCommand[5].trim().equals(unit));
	}
    
	/*
	 * test normal-command for add event (in the past)
	 */
	@Test
	public void testParseAdd3() {
		//parse the command
		String input = "add event \"cs2013 lecture\" 2100-05-01 16:00 2 hour";
	    String date = "2100-05-01";
	    String startTime = "16:00";
	    String timeInterval = "2";
	    String unit = "hour";
		TokenizedCommand command = normalCommandParser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("event"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("cs2013 lecture".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check the start time
		assertTrue(tokonizedCommand[3].trim().equals(startTime));
		//check timeInterval
		assertTrue(tokonizedCommand[4].trim().equals(timeInterval));
		//check unit
		assertTrue(tokonizedCommand[5].trim().equals(unit));
	}
	
	/*
	 * test normal-command for add event (in the past)
	 */
	@Test
	public void testParseEvent4() {
		//parse the command
		String input = "add event \"cs2013 lecture\" 1970-01-01 16:00 2 hour";
	    String date = "1970-01-01";
	    String startTime = "16:00";
	    String timeInterval = "2";
	    String unit = "hour";
		TokenizedCommand command = normalCommandParser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("event"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("cs2013 lecture".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check the start time
		assertTrue(tokonizedCommand[3].trim().equals(startTime));
		//check timeInterval
		assertTrue(tokonizedCommand[4].trim().equals(timeInterval));
		//check unit
		assertTrue(tokonizedCommand[5].trim().equals(unit));
	}
	
	/*
	 * test normal-command for add event (with keyword 'add')
	 */
	@Test
	public void testParseEvent5() {
		//parse the command
		String input = "add event \"add amount to bank account\" 2017-01-01 16:00 2 hour";
	    String date = "2017-01-01";
	    String startTime = "16:00";
	    String timeInterval = "2";
	    String unit = "hour";
		TokenizedCommand command = normalCommandParser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("event"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("add amount to bank account".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check the start time
		assertTrue(tokonizedCommand[3].trim().equals(startTime));
		//check timeInterval
		assertTrue(tokonizedCommand[4].trim().equals(timeInterval));
		//check unit
		assertTrue(tokonizedCommand[5].trim().equals(unit));
	}
	
	/*
	 * test normal-command for add event (without the 'year')
	 */
	@Test
	public void testParseEvent6() {
		//parse the command
		String input = "add event \"cs2013 lecture\" 05-01 16:00 2 hour";
	    String date = "05-01";
	    String startTime = "16:00";
	    String timeInterval = "2";
	    String unit = "hour";
		TokenizedCommand command = normalCommandParser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("event"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("cs2013 lecture".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check the start time
		assertTrue(tokonizedCommand[3].trim().equals(startTime));
		//check timeInterval
		assertTrue(tokonizedCommand[4].trim().equals(timeInterval));
		//check unit
		assertTrue(tokonizedCommand[5].trim().equals(unit));
	}
	
	/*
	 * test normal-command for add event (without the 'year' & 'start time') ,
	 */
	@Test
	public void testParseEvent7() {
		//parse the command
		String input = "add event \"cs2013 lecture\" 05-01 2 hour";
	    String date = "05-01";
	    String timeInterval = "2";
	    String unit = "hour";
		TokenizedCommand command = normalCommandParser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("event"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("cs2013 lecture".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check timeInterval
		assertTrue(tokonizedCommand[3].trim().equals(timeInterval));
		//check unit
		assertTrue(tokonizedCommand[4].trim().equals(unit));
	}
	
	/*
	 * test normal-command for add deadline
	 */
	@Test
	public void testDeadline1() {
		//parse the command
		String input = "add deadline \"submit proposal\" 2017-01-01 23:59";
	    String date = "2017-01-01";
	    String startTime = "23:59";
		TokenizedCommand command = normalCommandParser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("add");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("deadline"));
		//check the title of the task
		assertTrue(tokonizedCommand[1].trim().equals("submit proposal".trim()));
		//check the date
		assertTrue(tokonizedCommand[2].trim().equals(date));
		//check the start time
		assertTrue(tokonizedCommand[3].trim().equals(startTime));
	}
	
	/*
	 * test normal-command for delete a task
	 */
	@Test
	public void testDelete() {
		//parse the command
		String input = "delete \"title\"";
		TokenizedCommand command = normalCommandParser.parse(input);
		
		//check the action
		boolean isEqual = command.getAction().equals("delete");
		assertTrue(isEqual);
		//check the array of string
		String[] tokonizedCommand = command.getArgs();
		//check the type of the task
		assertTrue(tokonizedCommand[0].equals("title"));
	}	
    
}
```
###### /todolist/storage/DataBase.java
``` java
package todolist.storage;

import java.io.IOException;
import java.util.ArrayList;
//import java.util.logging.Level;
//import java.util.logging.Logger;

import todolist.common.UtilityLogger;
import todolist.common.UtilityLogger.Component;
import todolist.model.SearchCommand;
import todolist.model.Task;


/*
 * This class is the storage class, handling the read and write of local file with relative commands.
 * It will be called by the logic.
 *
 * for the retrieve method, now can support 3 search command
 * 1:"category" + category
 * 2:"name" + keyword
 * 3:"view"+view (overdue, archived)
 *
 * for the sorting methods, can now sort by
 * 1:name
 * 2:end date
 * 3:start date
 * 4:category
 * but they are not integrated with the search method yet!!
 *
 */
public class DataBase {

	private static String MESSAGE_ADDING_TASK = "tring to add task: ";
	private static String MESSAGE_SUCCESSFULLY_ADD_TASK = "successfully add task: ";
	private static String MESSAGE_DELETING_TASK = "tring to delete task: ";
	private static String MESSAGE_SUCCESSFULLY_DELETE_TASK = "The task is deleted from database: ";
	private static String MESSAGE_RETRIEVE_TASK = "trying to retrieve: ";
	private static String MESSAGE_SETTING_NEW_PATH = "trying to set new path: ";
	private static String MESSAGE_SMART_SEARCH = "tring to smart search for task:  ";
	private static String MESSAGE_SUCCESSFULLY_SMART_SEARCH_TASK = "successfully smart search for task: ";
	private static String MESSAGE_NO_RESULT_SMART_SEARCH_TASK = "no result for smart search for task: ";
	private static String MESSAGE_SUCCESSFULLY_SET_PATH = "successfully set new path: ";
	private static String MESSAGE_FAIL_SET_PATH = "fail to set new path: ";
	private static String MESSAGE_OPEN_NEW_FILE = "trying to open a new file in new directory: ";
	private static String MESSAGE_SUCCESSFULLY_OPEN_NEW_FILE = "successfully open new file in new directory: ";
	private static String MESSAGE_FAIL_OPEN_NEW_FILE = "fail to open new file in the new directory: ";
	private static String MESSAGE_SORT = "trying to sort based on %1$ in %2s order";
	
	private static String ERROR_REPEATED_TASK = "The task has already existed: ";
	private static String ERROR_TASK_NOT_EXIST = "The task to delete does not exist: ";

	protected static Component COMPONENT_STORAGE = UtilityLogger.Component.Storage;

	private FileHandler fh;
	public ArrayList<Task> taskList;
	private TaskRetriever retriever;
	private TaskSorter sorter;
	private DatabaseModifier modifier;
	private UtilityLogger logger = null;

    public DataBase() {
		fh = new FileHandler();
		retriever = new TaskRetriever();
		sorter = new TaskSorter();
		modifier = new DatabaseModifier();
		logger = new UtilityLogger();

		loadFromFile();		
	}
    /**
     * This method write the the list of the tasks into local file
     */
	public void writeToFile() {
		fh.write(taskList);
	}
    
	/**
	 * This method is to clear the database and the local file
	 */
	public void clear() {
		taskList = new ArrayList<Task>();
		
		writeToFile();
	}
    
	/**
	 * This method read from local file
	 */
	public void loadFromFile() {
		taskList = fh.read();
	}

	/**
	 * This method handles the writing into the text file with the add command.
	 * It returns true if the task is successfully written into the file.
	 *
	 * @param Task
	 *            the task to be added
	 * @return TRUE whether the task is successfully added\
	 *
	 * @throws IOException
	 *             when task already exist
	 */
	public boolean add(Task task) {		
		assert (task != null);
		
		logger.logAction(COMPONENT_STORAGE, MESSAGE_ADDING_TASK + task.getName().getName());
		
		try {
			taskList = modifier.addTask(taskList, task);
		} catch (IOException e) {
			logger.logError(COMPONENT_STORAGE, ERROR_REPEATED_TASK + task.getName().getName());
			return false;
		}
		
		writeToFile();	
		logger.logAction(COMPONENT_STORAGE, MESSAGE_SUCCESSFULLY_ADD_TASK + task.getName().getName());
		
		return true;
	}

	/**
	 * This method handles the updating of text file when the specified task is
	 * to be deleted. Returns true if the task is successfully deleted.
	 *
	 * @param Task
	 *            the task to be deleted
	 * @return boolean true if the task is successfully deleted; false if the
	 *         task to delete does not exist
	 */
	public boolean delete(Task taskToDelete) {
		
		if(taskToDelete == null) {
			return false;
		}
		
		loadFromFile();

		logger.logAction(COMPONENT_STORAGE, MESSAGE_DELETING_TASK + taskToDelete.getName().getName());

		try {
			taskList = modifier.deleteTask(taskList, taskToDelete);
		} catch (IOException e) {
			logger.logError(COMPONENT_STORAGE, ERROR_TASK_NOT_EXIST + taskToDelete.getName().getName());
			return false;
		}

		writeToFile();
		logger.logAction(COMPONENT_STORAGE, MESSAGE_SUCCESSFULLY_DELETE_TASK + taskToDelete.getName().getName());
		
		return true;
	}
 	
	/**
	 * This method returns whether a task is in the text file.
	 *
	 * @param Task
	 *            task to search
	 * @return boolean returns true if the task is found; false if not.
	 */
	public boolean checkExistence(Task taskToCheck) {
		return retriever.isTaskExisting(taskList, taskToCheck);
	}

	/**
	 * This method returns all the tasks in the database.
	 *
	 * @return an arraylist of all the tasks in database
	 */
	public ArrayList<Task> retrieveAll() {        
		return fh.read();
	}
	
	public Boolean recover(ArrayList<Task> backup) {
		fh.write(backup);
		
		loadFromFile();
		
		return true;
	}

	/**
	 * This method search for and then return tasks from the database according
	 * to the command.
	 * 
	 * @param command
	 *            command to search for the tasks in the database
	 * @return an arraylist of all the tasks in the search result; if the search
	 *         result is empty, returns an empty arraylist
	 */
	public ArrayList<Task> retrieve(SearchCommand command) {
		assert (command != null);
		
		logger.logAction(COMPONENT_STORAGE, MESSAGE_RETRIEVE_TASK + command.getType());
		
		return retriever.retrieveHandler(taskList, command);
	}

	/**
	 * search for tasks whose names containing the passed in string as a
	 * substring
	 * 
	 * @param  keywords   array of keywords to search for
	 * @return resultList arraylist list of result tasks
	 */
	public ArrayList<Task> smartSearch(String[] keywords) {
		assert (keywords != null);
		
		logger.logAction(COMPONENT_STORAGE, MESSAGE_SMART_SEARCH + keywords.toString());
		
		ArrayList<Task> resultList = retriever.smartRetrieve(taskList, keywords);
		
		if(resultList.isEmpty()) {
			logger.logAction(COMPONENT_STORAGE, MESSAGE_NO_RESULT_SMART_SEARCH_TASK + keywords.toString());
		}else {
			logger.logAction(COMPONENT_STORAGE, MESSAGE_SUCCESSFULLY_SMART_SEARCH_TASK + keywords.toString());
		}
		
		return resultList;
	}

	/**
	 * This method is to set new file for the storage of data.
	 *
	 * @param newFile   the string that contains the new path and file name
	 *
	 * @return boolean  return true if the directory exists and the new file is set.
	 */
	public boolean setNewFile(String newFilePath) {
		assert (newFilePath != null);
		
		logger.logAction(COMPONENT_STORAGE, MESSAGE_SETTING_NEW_PATH + newFilePath);
		
		boolean isSet = false;
		isSet = fh.setFile(newFilePath);

		if (!isSet) {
			
			logger.logAction(COMPONENT_STORAGE, MESSAGE_FAIL_SET_PATH + newFilePath);
			
			return false;
		}
		
		logger.logAction(COMPONENT_STORAGE, MESSAGE_SUCCESSFULLY_SET_PATH + newFilePath);
		
		this.loadFromFile();
		
		return isSet;
	}
    
	/**
	 * This method opens a new file for task storage in another directory
	 * 
	 * @param newFilePath  the new directory to open the new file or create a new file to store the tasks
	 * 
	 * @return  boolean    true if the a new file is created in the new directory;
	 */
	public boolean openNewFile(String newFilePath) {
		assert (newFilePath != null);
		
		logger.logAction(COMPONENT_STORAGE, MESSAGE_OPEN_NEW_FILE + newFilePath);
		
		boolean isOpen = false;
		isOpen = fh.openFile(newFilePath);
		
		if (!isOpen) {
			
			logger.logAction(COMPONENT_STORAGE, MESSAGE_FAIL_OPEN_NEW_FILE + newFilePath);
			return false;
		}
		
		logger.logAction(COMPONENT_STORAGE, MESSAGE_SUCCESSFULLY_OPEN_NEW_FILE + newFilePath);
		
		this.loadFromFile();
		
		return isOpen;
	}

	/**
	 * This method returns the path of the local text file that stores all the
	 * tasks.
	 *
	 * @return a string that represents the path
	 */
	public String getPath() {
		return fh.getPath();
	}


	/**
	 * Sort the tasks in the text file in the specific order of the specific
	 * field.
	 *
	 * @param fieldName
	 *            the name of the field to sort on
	 * @param order
	 *            the order of the task list after sorting, either in ascending
	 *            order or descending order
	 */
	public void sort(String fieldName, String order) {
		
		logger.logAction(COMPONENT_STORAGE, String.format(MESSAGE_SORT, fieldName, order));
		
		taskList = sorter.sortHandler(taskList, fieldName, order);
	}
}
```
###### /todolist/storage/DatabaseModifier.java
``` java
package todolist.storage;

import java.io.IOException;
import java.util.ArrayList;

import todolist.model.Task;

 
public class DatabaseModifier {
    public static String EXCEPEPTION_REPEATED_TASK = "The task has already existed!";
    public static String EXCEPTION_TASKNOTEXIST = "The task to delete does not exist!";

    private ArrayList<Task> taskList;
   
    protected DatabaseModifier() {
        taskList = new ArrayList<Task>();
    }

    /**
     * add a task to the arraylist after checking whether it is already existing
     * 
     * @param tasks
     *            list of tasks to which the task to add
     * @param task
     *            the task to be added
     * @return the resultant task list
     * @throws IOException
     *             if the task is already existing
     */
    public ArrayList<Task> addTask(ArrayList<Task> tasks, Task task) throws IOException {
        this.taskList = tasks;
        
        if (isExistingTask(task)) {
            throw new IOException(EXCEPEPTION_REPEATED_TASK);
        }

        taskList.add(0, task);
        
        return taskList;
    }

    // helper method for add function
    private boolean isExistingTask(Task task) {
        return taskList.contains(task);
    }

    /**
     * delete the specific task from the list of tasks
     * 
     * @param tasks         list of tasks from where the task to be deleted
     * 
     * @param taskToDelete  the task to be deleted
     * 
     * @return taskList     the list of task after deleting the required task
     * 
     * @throws IOException  when the task to delete not in the task list
     */
    public ArrayList<Task> deleteTask(ArrayList<Task> tasks, Task taskToDelete) throws IOException {
        taskList = tasks;
        
        boolean isListEmpty = false;
        isListEmpty = taskList.size() == 0;
        
        if (isListEmpty) {
            throw new IOException(EXCEPTION_TASKNOTEXIST);
        }

        Integer index = searchForIndexOfTask(taskToDelete);

        if (index == null) {
            throw new IOException(EXCEPTION_TASKNOTEXIST);
        }
        
        taskList.remove(taskList.get(index));

        return taskList;
    }

    // helper methods
    private Integer searchForIndexOfTask(Task taskToDelete) {  	
        for (int i = 0; i < taskList.size(); i++) {
        	
            Task currentTask = taskList.get(i);

            String nameOfCurrentTask = currentTask.getName().getName();
            
            String nameOfTaskToDelete = taskToDelete.getName().getName();
            
            if (nameOfCurrentTask.equalsIgnoreCase(nameOfTaskToDelete)) {
                return i;
            }
        }
        return null;
    }
}
```
###### /todolist/storage/FileHandler.java
``` java

/*
 * This class is to read and write from the file directly. It will be called by the database.
 * 
 * 
 *
 */
public class FileHandler {
	private static String PATH_UPDATEDDIRECTORY = "updatedDirectory.txt";
	private static String FILENAME = "taskStorage.txt";
	private static String FILEPATH = "taskStorage.txt";

	private Gson gson = new Gson();
    
	protected FileHandler() {
		checkForUpdatedDirectory();
	}

	/**
	 * This method reads from the local file. It returns a ArrayList containing
	 * all the Strings in the file.
	 * 
	 * @return taskList   the list of tasks stored in file if no such file or the
	 *                    file is empty, return an empty arraylist.
	 */
	public ArrayList<Task> read() {
		
		ArrayList<Task> taskList = new ArrayList<Task>();
		File path = new File(FILEPATH);

		if (isFileReady(path) && !isFileEmpty(path)) {
			
			try {
				FileReader fr = new FileReader(FILEPATH);
				
				BufferedReader br = new BufferedReader(fr);
				
				String input = null;
				
				input = br.readLine();

				while (input != null && !input.equals("null")) {
					taskList.add(gson.fromJson(input, Task.class));
					
					input = br.readLine();
				}
				br.close();
				
			} catch (FileNotFoundException e) {
				
				return taskList;
				
			} catch (IOException e) {
				
				return null;
			}
		}
		return taskList;
	}
	
	/**
	 * This method write directly the list of tasks to the local file.
	 * 
	 * @param taskList  the list of tasks to be written
	 * 
	 * @return boolean  return true if it is successfully written; false if the target file
	 *                  cannot be found
	 */
	public boolean write(ArrayList<Task> taskList) {
		try {
			FileWriter fw = new FileWriter(FILEPATH);
			
			BufferedWriter bw = new BufferedWriter(fw);
			
			for (Task eachTask : taskList) {
				bw.write(gson.toJson(eachTask) + "\n");
			}
			
			bw.close();

		} catch (Exception e) {
			
			return false;
		}
		
		return true;
	}

	/**
	 * The method is to set a new direction to store the tasks in the defined
	 * path.
	 * 
	 * @param newFilePath
	 *            the path of the new file (the path + the file name); it is not
	 *            null.
	 * @return true if the file is set; false if the path is not a correct path
	 */
	public boolean setFile(String newFilePath) {
		
		//check whether the directory is valid
		if(!isPathCorrect(newFilePath)) {
			return false;
		}
		
		newFilePath = newFilePath + FILENAME;
		
		try {			
			copyFromOldFile(FILEPATH, newFilePath);
			
		} catch (IOException e) {			
			return false;
			
		}
		
        try {
			storeNewDirectory(newFilePath);
			
		} catch (IOException e) {
			return false;
			
		}
        
        FILEPATH = newFilePath;
        
		return true;
	}



	private void copyFromOldFile(String pathFrom, String pathTo) throws IOException {
		
		Path from = Paths.get(pathFrom);
		
		Path to = Paths.get(pathTo);
		
		CopyOption[] options = new CopyOption[] { StandardCopyOption.REPLACE_EXISTING,
				StandardCopyOption.COPY_ATTRIBUTES };

		
		Files.copy(from, to, options);

	}

	private void storeNewDirectory(String newFilePath) throws IOException {

		FileWriter fw = new FileWriter(PATH_UPDATEDDIRECTORY);
		
		BufferedWriter bw = new BufferedWriter(fw);
		
		// store the new path in the local file
		bw.write(newFilePath + "\n");
		
		bw.close();
	}

	public boolean openFile(String newFilePath) {
		
		//check whether the directory exist		
		String tempFilePath = newFilePath + FILENAME;
		
		if(!isPathCorrect(tempFilePath)) {
			
			new File(newFilePath).mkdir();
			
			try {
				FileWriter fw = new FileWriter(tempFilePath);
				
				BufferedWriter bw = new BufferedWriter(fw);
				
				bw.close();
				
			} catch (Exception e) {
				return false;
				
			}
			
			openFile(newFilePath);
			
			return false;
		}
		
		//check whether the txt file contains the correct format (gson format)
		if(read() == null) {		
			return false;
			
		}
		
		FILEPATH = tempFilePath;
		
		return true;
	}

	public String getPath() {
		
		if(FILEPATH.equalsIgnoreCase("taskStorage.txt")) {
			
			Path currentRelativePath = Paths.get("");
			
			String currentDirectory = currentRelativePath.toAbsolutePath().toString();
			
			return currentDirectory + "/" + FILENAME;
			
		}else {			
			return FILEPATH;
			
		}
	}

	// helper methods
	private void checkForUpdatedDirectory() {
		
		File updatedDirectory = new File(PATH_UPDATEDDIRECTORY);

		try {
			if (isFileReady(updatedDirectory) && !isFileEmpty(updatedDirectory)) {
				
				FileReader fr = new FileReader(updatedDirectory);
				
				BufferedReader br = new BufferedReader(fr);
				
				FILEPATH = br.readLine();
				
				br.close();
			}
			
		} catch (Exception e) {
			return;
			
		}
	}

	private boolean isFileReady(File filePath) {
		return filePath.exists();
	}

	private boolean isFileEmpty(File filePath) {
		
		if (isFileReady(filePath)) {
			return filePath.length() == 0;
		}
		
		return true;
	}

    private boolean isPathCorrect(String pathName) {
    	
		if (pathName.length() == 0) {
			return true;
		}
		
		File pathToCheck = new File(pathName);
		
		if (pathToCheck.isDirectory() || pathToCheck.isFile()) {
			return true;
		}
		
		return false;
	}
}
```
###### /todolist/storage/TaskRetriever.java
``` java
package todolist.storage;

import java.time.LocalDateTime;
import java.util.ArrayList;

import todolist.model.SearchCommand;
import todolist.model.Task;

public class TaskRetriever {
    
	private static final String NAME = "name";
	private static final String VIEW = "view";
	private static final String CATEGORY = "category";
	private static final String ARCHIVE = "archive";
	private static final String OVERDUE = "overdue";
	
    private static enum FilterType {
        VIEW, CATEGORY, NAME, END_DATE, START_DATE;
    }

    private static enum ViewType {
        ARCHIVE, OVERDUE, TODAY;
    }

    private ArrayList<Task> taskList;

    protected TaskRetriever() {
        taskList = new ArrayList<Task>();
    }

    protected ArrayList<Task> retrieveHandler(ArrayList<Task> tasks, SearchCommand command) {
        assert (command instanceof SearchCommand);

        taskList = tasks;

        ArrayList<Task> resultList = new ArrayList<Task>();
        
        FilterType type = getFilterType(command);
        
        switch (type) {
        case CATEGORY:
            resultList = retrieve_Category(command);
            break;
        case NAME:
            resultList = retrieve_Name(command);
            break;
        case VIEW:
            resultList = retrieve_View(command);
            break;
        default:
            return resultList;
        }

        return resultList;
    }

    private FilterType getFilterType(SearchCommand command) {
        String type = command.getType();
        
        if (isCategory(type)) {
            return FilterType.CATEGORY;
        }
        
        if (isView(type)) {
            return FilterType.VIEW;
        }
        
        if (isName(type)) {
            return FilterType.NAME;
        }
        
        return null;
    }

    private boolean isName(String type) {
        return type.equalsIgnoreCase(NAME);
    }

    private boolean isView(String type) {
        return type.equalsIgnoreCase(VIEW);
    }

    private boolean isCategory(String type) {
        return type.equalsIgnoreCase(CATEGORY);
    }

    private ArrayList<Task> retrieve_View(SearchCommand command) {
        ArrayList<Task> resultList = new ArrayList<Task>();
        
        ViewType viewToFilter = determineViewType(command.getContent());
        
        switch (viewToFilter) {
        case OVERDUE:
            resultList = retrieve_ViewOverDue();
            break;
        case ARCHIVE:
            resultList = retrieve_ViewArchive();
            break;
        default:
            return resultList;
        }
        
        return resultList;
    }

    private ArrayList<Task> retrieve_ViewArchive() {
        ArrayList<Task> resultList = new ArrayList<Task>();
        
        for (Task eachTask : taskList) {
        	
            if (eachTask.getDoneStatus()) {
            	
                resultList.add(eachTask);
            }
        }
        
        return resultList;
    }

    private ArrayList<Task> retrieve_ViewOverDue() {
        ArrayList<Task> resultList = new ArrayList<Task>();
        
        for (Task eachTask : taskList) {
        	
            if (isTaskOverdue(eachTask.getEndTime())) {
                resultList.add(eachTask);
                
            }
        }
        
        return null;
    }

    private boolean isTaskOverdue(LocalDateTime endTime) {
        if (endTime == null) {
            return false;
        }
        
        return endTime.isBefore(LocalDateTime.now());
    }

    private ViewType determineViewType(String content) {
    	
        if (isOverdue(content)) {
            return ViewType.OVERDUE;
        }
        
        if (isArchive(content)) {
            return ViewType.ARCHIVE;
        }
        
        return null;
    }

    private boolean isArchive(String content) {
        return content.equalsIgnoreCase(ARCHIVE);
    }

    private boolean isOverdue(String content) {
        return content.equalsIgnoreCase(OVERDUE);
    }

    private ArrayList<Task> retrieve_Name(SearchCommand command) {

        ArrayList<Task> resultList = new ArrayList<Task>();
        
        String requiredName = command.getContent();
        
        for (Task eachTask : taskList) {
        	
            if (eachTask.getName().getName().equalsIgnoreCase(requiredName)) {
                resultList.add(eachTask);
            }
        }
        
        return resultList;
    }
    
    protected ArrayList<Task> smartRetrieve(ArrayList<Task> taskList, String[] keywords) {
    	ArrayList<Task> resultList = new ArrayList<Task>();
    	
    	if(taskList.isEmpty()) {
    		return resultList;
    	}
    	 		
    	resultList = retrieveByTokenizedName(taskList, keywords);

        return resultList;
    }

    private ArrayList<Task> retrieveByTokenizedName(ArrayList<Task> taskList2, String[] keywords) {
		ArrayList<Task> resultList = new ArrayList<Task>();
		
		int[] numMatch = new int[taskList2.size()];
		
		if(keywords.length == 1) {			
			resultList = retrieveByInitial(taskList2, keywords[0]);
			
		}
		
		for (int i = 0; i < taskList2.size(); i++) {
			
        	Task eachTask = taskList2.get(i);
        	
        	String eachName = eachTask.getName().getName();  
        	
        	numMatch[i] = findNumMatch(keywords, eachName); 
        }
	
		//add those with more than 0 matches into resultlist in descending order
		for(int i = 1; i <= keywords.length; i++) {
			for(int j = 0; j < numMatch.length; j++) {
				
				if(numMatch[j] == i) {
					resultList.add(0, taskList2.get(j));
				}
			}			
		}		
		return resultList;
	}

	private int findNumMatch(String[] keywords, String eachName) {
		int counter = 0;
		
		String[] splitedName = eachName.trim().split(" ");
		
		for(int i = 0; i < keywords.length; i++) {
			for(int j = 0; j < splitedName.length; j++) {
				
				String eachNameWord = splitedName[j].toLowerCase();
				
				String eachKeyword = keywords[i].toLowerCase();
				
				if(eachNameWord.equalsIgnoreCase(eachKeyword)) {
					
					counter++;
					
					break;
			    }			
			}
		}

		return counter;
	}

	private ArrayList<Task> retrieveByInitial(ArrayList<Task> taskList, String keyword) {
		
		ArrayList<Task> resultList = new ArrayList<Task>();
		boolean isMatching = false;
		
		for(int i = 0; i < taskList.size(); i++) {
			
			String eachName = taskList.get(i).getName().getName();
			int nameLength = eachName.trim().split(" ")[0].length();
			int keywordLength = keyword.length();
			
			if(nameLength <= keywordLength)  {
				isMatching = false;
			} else {
				String initialPart = eachName.substring(0, keywordLength);
				isMatching = initialPart.equalsIgnoreCase(keyword);
			}
			
			if(isMatching) {
				resultList.add(taskList.get(i));
			}
		}
				
		return resultList;
	}

	private boolean isSameCategory(String cat1, String cat2) {
		boolean isSameCat = false;
		
		if(cat1 == null || cat2 == null) {
			return false;
		}else {
			isSameCat = cat1.equalsIgnoreCase(cat2);					
		}
		
        return isSameCat;
    }


    private ArrayList<Task> retrieve_Category(SearchCommand command) {
        ArrayList<Task> resultList = new ArrayList<Task>();
        String requiredCategory = command.getContent();

        for (Task eachTask : taskList) {
         
            if (eachTask.getCategory() != null && isSameCategory(eachTask.getCategory().getCategory(), requiredCategory)) {
                resultList.add(eachTask);
            }
        }
        
        return resultList;
    }

    /**
     * check whether the required task exist in the local storage file
     * 
     */
    public boolean isTaskExisting(ArrayList<Task> taskList, Task taskToCheck) {
        return taskList.contains(taskToCheck);
    }

}
```
###### /todolist/storage/TaskSorter.java
``` java
package todolist.storage;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

import todolist.model.Task;


public class TaskSorter {
	
	private ArrayList<Task> taskList;
	
    protected TaskSorter() {
    	taskList = new ArrayList<Task>();
    }
    
    
	protected ArrayList<Task> sortHandler(ArrayList<Task> tasks, String fieldName, String order) {
		
        taskList = tasks;
        
		switch (fieldName.toLowerCase()) {
		case "start":
			sort_StartDate(taskList);
			break;
		case "end":
			sort_EndDate(taskList);
			break;
		case "category":
			sort_Category(taskList);
			break;
		case "name":
			sort_Name(taskList);
			break;
		default:
			
		}
		
		if(order.equalsIgnoreCase("descending")) {
			Collections.reverse(taskList);
		}
		
		return taskList;
	}
	
    // sorting
    // 1.startDate
    private ArrayList<Task> sort_StartDate(ArrayList<Task> currentList) {
    	
        Collections.sort(currentList, new StartDateComparator());
        
        return currentList;
    }

    private class StartDateComparator implements Comparator<Task> {
    	
        public int compare(Task t1, Task t2) {
        	
            LocalDateTime firstDate = ((todolist.model.Task) t1).getStartTime();
            
            LocalDateTime secondDate = ((todolist.model.Task) t2).getStartTime();
            
            if (firstDate == null && secondDate == null) {
            	
                String t1_Name = ((todolist.model.Task) t1).getName().getName();
                
                String t2_Name = ((todolist.model.Task) t2).getName().getName();
                
                return t1_Name.compareToIgnoreCase(t2_Name);
                
            } else if (firstDate == null) {
                return -1;
                
            } else if (secondDate == null) {
                return 1;
                
            } else {
                return firstDate.compareTo(secondDate);
            }
        }
    }

    // 2.endDate
    private ArrayList<Task> sort_EndDate(ArrayList<Task> currentList) {
    	
        Collections.sort(currentList, new EndDateComparator());
        
        return currentList;
    }

    private class EndDateComparator implements Comparator<Task> {
    	
        public int compare(Task t1, Task t2) {
        	
            LocalDateTime firstDate = ((todolist.model.Task) t1).getEndTime();
            
            LocalDateTime secondDate = ((todolist.model.Task) t2).getEndTime();
            
            if (firstDate == null && secondDate == null) {
                String t1_Name = ((todolist.model.Task) t1).getName().getName();
                
                String t2_Name = ((todolist.model.Task) t2).getName().getName();
                
                return t1_Name.compareToIgnoreCase(t2_Name);
                
            } else if (firstDate == null) {
                return -1;
                
            } else if (secondDate == null) {
                return 1;
                
            } else {
                return firstDate.compareTo(secondDate);
            }
        }
    }

    // 3.category
    private ArrayList<Task> sort_Category(ArrayList<Task> currentList) {
        Collections.sort(currentList, new CategoryComparator());
        
        return currentList;
    }

    private class CategoryComparator implements Comparator<Task> {
    	
        public int compare(Task t1, Task t2) {
        	
            String firstCategory = ((todolist.model.Task) t1).getCategory().getCategory();
            
            String secondCategory = ((todolist.model.Task) t2).getCategory().getCategory();
            
            return firstCategory.compareToIgnoreCase(secondCategory);
        }
    }

    // 4.name
    private ArrayList<Task> sort_Name(ArrayList<Task> currentList) {
        Collections.sort(currentList, new NameComparator());
        
        return currentList;
    }

    private class NameComparator implements Comparator<Task> {
    	
        public int compare(Task t1, Task t2) {
        	
            String firstName = ((todolist.model.Task) t1).getName().getName();
            
            String secondName = ((todolist.model.Task) t2).getName().getName();
            
            return firstName.compareToIgnoreCase(secondName);
        }
    }
}
```
